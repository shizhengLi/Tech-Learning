### Chapter 5: Building a Simple Lambda Calculus Interpreter

1. Architecture of an Interpreter
   - Parser and abstract syntax tree (AST)
   - Overall structure of an interpreter or compiler
2. Lexical and Syntactic Analysis
   - Using a simple BNF/EBNF grammar for lambda expressions
   - Designing a basic parser
3. Evaluation Strategies
   - Normal-order vs. applicative-order evaluation
   - Lazy vs. strict evaluation
   - Example: The same lambda expression under different strategies
4. Implementation in C or Python
   - Data structures (C structs or Python classes)
   - Recursive evaluation and variable substitution
   - Detailed code listings with explanations
5. Testing and Debugging
   - Example test cases (booleans, arithmetic, recursion)
   - Common errors and how to troubleshoot them

### ç¬¬5ç« ã€€**å®ç°ä¸€ä¸ªç®€å•çš„Lambda Calculusè§£é‡Šå™¨**

1. è§£é‡Šå™¨åŸç†ä¸æ¶æ„
   - è§£æå™¨ï¼ˆParserï¼‰ä¸æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰
   - è§£é‡Šå™¨æˆ–ç¼–è¯‘å™¨çš„æ€»ä½“ç»“æ„
2. è¯æ³•ä¸è¯­æ³•åˆ†æ
   - ç”¨ç®€å•çš„BNFæˆ–EBNFå®šä¹‰Lambdaè¡¨è¾¾å¼çš„è¯­æ³•
   - è®¾è®¡ä¸€ä¸ªç®€æ˜“çš„Parser
3. æ±‚å€¼ç­–ç•¥
   - è¯„ä¼°ç­–ç•¥ï¼šæ­£å¸¸åºï¼ˆNormal Orderï¼‰ä¸åº”ç”¨åºï¼ˆApplicative Orderï¼‰
   - æƒ°æ€§æ±‚å€¼ä¸ä¸¥æ ¼æ±‚å€¼çš„å½±å“
   - å°èŠ‚ç¤ºä¾‹ï¼šåŒä¸€ä¸ªè¡¨è¾¾å¼åœ¨ä¸åŒç­–ç•¥ä¸‹çš„æ±‚å€¼è¿‡ç¨‹
4. ç”¨Cæˆ–Pythonå®ç°
   - åŸºç¡€æ•°æ®ç»“æ„å®šä¹‰ï¼ˆCè¯­è¨€ä¸­çš„ç»“æ„ä½“æˆ–Pythonç±»ï¼‰
   - é€’å½’æ±‚å€¼ä¸å˜é‡æ›¿æ¢é€»è¾‘
   - ä»£ç ç¤ºä¾‹+è¯¦ç»†æ³¨é‡Š
5. æµ‹è¯•ä¸è°ƒè¯•
   - æµ‹è¯•ç”¨ä¾‹ï¼šå¸ƒå°”è¿ç®—ã€æ•°å€¼è¿ç®—ã€é€’å½’å‡½æ•°
   - å¯èƒ½é‡åˆ°çš„é”™è¯¯åŠè°ƒè¯•æ–¹æ³•

### **5.1.1 è§£æå™¨ï¼ˆParserï¼‰ä¸æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰**

Lambda Calculus è§£é‡Šå™¨çš„ç¬¬ä¸€æ­¥æ˜¯è§£æè¾“å…¥çš„ Lambda è¡¨è¾¾å¼ï¼Œå¹¶å°†å…¶è½¬æ¢ä¸º**æŠ½è±¡è¯­æ³•æ ‘ï¼ˆAST, Abstract Syntax Treeï¼‰**ã€‚è§£æå™¨ï¼ˆParserï¼‰æ˜¯ Lambda è®¡ç®—çš„å‰ç«¯ç»„ä»¶ï¼Œå®ƒå°†æ–‡æœ¬æ ¼å¼çš„è¡¨è¾¾å¼è½¬æ¢æˆ ASTï¼Œä½¿å¾—è§£é‡Šå™¨èƒ½å¤Ÿè¿›è¡Œæ±‚å€¼ã€‚

#### **1. ä»€ä¹ˆæ˜¯æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰ï¼Ÿ**

æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰æ˜¯ä¸€ç§ç”¨äºè¡¨ç¤ºç¨‹åºè¯­æ³•ç»“æ„çš„æ ‘çŠ¶æ•°æ®ç»“æ„ã€‚AST é€šè¿‡å»é™¤å†—ä½™çš„è¯­æ³•å…ƒç´ ï¼ˆå¦‚æ‹¬å·ï¼‰æ¥æä¾›æ›´ç®€æ´å’Œç»“æ„åŒ–çš„è¡¨ç¤ºï¼Œä½¿å¾—æ±‚å€¼å™¨å¯ä»¥ç›´æ¥åŸºäº AST è¿›è¡Œè®¡ç®—ã€‚

**AST çš„ä½œç”¨ï¼š**

- **æ¶ˆé™¤æ­§ä¹‰**ï¼šä¸åŒçš„ Lambda è¡¨è¾¾å¼ä¹¦å†™æ–¹å¼å¯ä»¥æ˜ å°„åˆ°åŒä¸€ä¸ª ASTã€‚
- **ä¾¿äºæ±‚å€¼**ï¼šè®¡ç®—å¯ä»¥ç›´æ¥åŸºäº AST è¿›è¡Œï¼Œè€Œä¸éœ€è¦è§£æå­—ç¬¦ä¸²ã€‚
- **ä¼˜åŒ–ä¸è½¬æ¢**ï¼šåœ¨ç¼–è¯‘å™¨å®ç°ä¸­ï¼ŒAST å¯ä»¥ç”¨äºä»£ç ä¼˜åŒ–å’Œè½¬æ¢ã€‚

**ç¤ºä¾‹ï¼š** Lambda è¡¨è¾¾å¼ï¼š

```
Î»x. (Î»y. y) x
```

å¯¹åº”çš„ AST ç»“æ„ï¼š

```
Lambda
â”œâ”€â”€ Param: x
â””â”€â”€ Body:
    â””â”€â”€ Application
        â”œâ”€â”€ Lambda
        â”‚   â”œâ”€â”€ Param: y
        â”‚   â””â”€â”€ Body: y
        â””â”€â”€ Variable: x
```

------

#### **2. Lambda Calculus è¯­æ³•ç»“æ„**

Lambda Calculus è§£ææ—¶æ¶‰åŠä¸‰ç§åŸºæœ¬ç»“æ„ï¼š

1. **å˜é‡ï¼ˆVariableï¼‰**ï¼š
   - ä»£è¡¨æ ‡è¯†ç¬¦ï¼Œå¦‚ `x`ã€`y`ã€‚
   - åœ¨ AST ä¸­è¡¨ç¤ºä¸º `Var("x")`ã€‚
2. **Lambda æŠ½è±¡ï¼ˆLambda Abstractionï¼‰**ï¼š
   - å½¢å¼ä¸º `Î»x. E`ï¼Œè¡¨ç¤ºå®šä¹‰ä¸€ä¸ªåŒ¿åå‡½æ•°ï¼Œæ¥å— `x` ä½œä¸ºå‚æ•°ï¼Œ`E` ä¸ºå‡½æ•°ä½“ã€‚
   - åœ¨ AST ä¸­è¡¨ç¤ºä¸º `Lambda("x", body)`ã€‚
3. **åº”ç”¨ï¼ˆApplicationï¼‰**ï¼š
   - å½¢å¼ä¸º `E1 E2`ï¼Œè¡¨ç¤ºå°† `E2` ä½œä¸ºå‚æ•°ä¼ é€’ç»™ `E1`ã€‚
   - åœ¨ AST ä¸­è¡¨ç¤ºä¸º `App(func, arg)`ã€‚

**Lambda Calculus çš„ BNF è¡¨ç¤º**

```
expr ::= variable
       | abstraction
       | application

variable ::= identifier

abstraction ::= "Î»" identifier "." expr

application ::= expr expr
             | "(" expr ")"
```

**ç¤ºä¾‹è§£æ**

- **`Î»x. x`** è§£æä¸º `Lambda("x", Var("x"))`
- **`(Î»x. x) y`** è§£æä¸º `App(Lambda("x", Var("x")), Var("y"))`

------

#### **3. è§£æå™¨çš„å·¥ä½œæµç¨‹**

è§£æå™¨çš„ä¸»è¦ä»»åŠ¡æ˜¯å°†è¾“å…¥çš„ Lambda è¡¨è¾¾å¼è½¬æ¢ä¸º ASTã€‚å…¶ä¸»è¦å·¥ä½œæµç¨‹å¦‚ä¸‹ï¼š

1. **è¯æ³•åˆ†æï¼ˆLexical Analysisï¼‰**

   - è¯†åˆ« Lambda å…³é”®å­—ã€å˜é‡ã€ç‚¹å· `.` å’Œæ‹¬å· `()`ã€‚

   - ç”Ÿæˆ**æ ‡è®°ï¼ˆTokensï¼‰**ï¼Œä¾›è§£æå™¨ä½¿ç”¨ã€‚

   - ç¤ºä¾‹ï¼š

     ```
     Î»x. (Î»y. y) x
     ```

     è§£ææˆ Tokensï¼š

     ```
     [('LAMBDA', 'Î»'), ('IDENT', 'x'), ('DOT', '.'), ('LPAREN', '('),
      ('LAMBDA', 'Î»'), ('IDENT', 'y'), ('DOT', '.'), ('IDENT', 'y'),
      ('RPAREN', ')'), ('IDENT', 'x')]
     ```

2. **è¯­æ³•åˆ†æï¼ˆParsingï¼‰**

   - ä¾æ® Lambda Calculus çš„è¯­æ³•è§„åˆ™ï¼Œå°†æ ‡è®°åºåˆ—è½¬æ¢ä¸º AST ç»“æ„ã€‚

   - ç¤ºä¾‹ï¼š

     ```python
     Lambda("x", App(Lambda("y", Var("y")), Var("x")))
     ```

------

#### **4. è§£æç¤ºä¾‹**

##### **ç¤ºä¾‹ 1ï¼šLambda æŠ½è±¡**

**è¾“å…¥**

```
Î»x. x
```

**è§£æç»“æœ**

```
Lambda("x", Var("x"))
```

**AST ç»“æ„**

```
Lambda
â”œâ”€â”€ Param: x
â””â”€â”€ Body: x
```

##### **ç¤ºä¾‹ 2ï¼šåº”ç”¨**

**è¾“å…¥**

```
(Î»x. x) y
```

**è§£æç»“æœ**

```
App(Lambda("x", Var("x")), Var("y"))
```

**AST ç»“æ„**

```
Application
â”œâ”€â”€ Lambda
â”‚   â”œâ”€â”€ Param: x
â”‚   â””â”€â”€ Body: x
â””â”€â”€ Variable: y
```

##### **ç¤ºä¾‹ 3ï¼šåµŒå¥—è¡¨è¾¾å¼**

**è¾“å…¥**

```
Î»x. (Î»y. y) x
```

**è§£æç»“æœ**

```
Lambda("x", App(Lambda("y", Var("y")), Var("x")))
```

**AST ç»“æ„**

```
Lambda
â”œâ”€â”€ Param: x
â””â”€â”€ Body:
    â””â”€â”€ Application
        â”œâ”€â”€ Lambda
        â”‚   â”œâ”€â”€ Param: y
        â”‚   â””â”€â”€ Body: y
        â””â”€â”€ Variable: x
```

------

### **5.1.2 è§£é‡Šå™¨æˆ–ç¼–è¯‘å™¨çš„æ€»ä½“ç»“æ„**

Lambda Calculus çš„æ‰§è¡Œæ–¹å¼ä¸»è¦æœ‰ä¸¤ç§ï¼š

1. **è§£é‡Šå™¨ï¼ˆInterpreterï¼‰**ï¼šè§£æå¹¶ç›´æ¥æ‰§è¡Œè¡¨è¾¾å¼ã€‚
2. **ç¼–è¯‘å™¨ï¼ˆCompilerï¼‰**ï¼šå°† Lambda è¡¨è¾¾å¼è½¬æ¢ä¸ºå¯æ‰§è¡Œä»£ç ã€‚

#### **1. è§£é‡Šå™¨çš„ç»“æ„**

è§£é‡Šå™¨çš„æ ¸å¿ƒç»„ä»¶ï¼š

1. **è¯æ³•åˆ†æï¼ˆLexerï¼‰**ï¼šå°†è¾“å…¥è½¬æ¢ä¸º Tokenã€‚
2. **è¯­æ³•åˆ†æï¼ˆParserï¼‰**ï¼šå°† Token è§£æä¸º ASTã€‚
3. **æ±‚å€¼å™¨ï¼ˆEvaluatorï¼‰**ï¼šå¯¹ AST è¿›è¡Œæ±‚å€¼ï¼Œæ‰§è¡Œè®¡ç®—ã€‚

**è§£é‡Šå™¨æ‰§è¡Œæµç¨‹**

```
è¾“å…¥: "Î»x. (Î»y. y) x"

-> è¯æ³•åˆ†æï¼ˆLexerï¼‰
-> è¯­æ³•åˆ†æï¼ˆParserï¼‰-> ç”Ÿæˆ AST
-> æ±‚å€¼ï¼ˆEvaluatorï¼‰
-> ç»“æœè¾“å‡º
```

#### **2. ç¼–è¯‘å™¨çš„ç»“æ„**

ç¼–è¯‘å™¨çš„æ ¸å¿ƒç»„ä»¶ï¼š

1. å‰ç«¯ï¼ˆFront-Endï¼‰ï¼š
   - è¯æ³•åˆ†æï¼ˆLexingï¼‰â†’ è¯­æ³•åˆ†æï¼ˆParsingï¼‰â†’ ç”Ÿæˆ AST
2. ä¸­é—´å±‚ï¼ˆMiddle-Endï¼‰ï¼š
   - ä¼˜åŒ– ASTï¼ˆæ¶ˆé™¤å†—ä½™ï¼‰
   - ç”Ÿæˆ IRï¼ˆä¸­é—´è¡¨ç¤ºï¼Œå¦‚ LLVM IRï¼‰
3. åç«¯ï¼ˆBack-Endï¼‰ï¼š
   - ç›®æ ‡ä»£ç ç”Ÿæˆï¼ˆPythonã€Cã€æ±‡ç¼–ï¼‰

**ç¼–è¯‘å™¨æ‰§è¡Œæµç¨‹**

```
è¾“å…¥: "Î»x. (Î»y. y) x"

-> è¯æ³•åˆ†æï¼ˆLexerï¼‰
-> è¯­æ³•åˆ†æï¼ˆParserï¼‰-> ç”Ÿæˆ AST
-> ä»£ç ä¼˜åŒ–
-> ä»£ç ç”Ÿæˆ
-> ç›®æ ‡ä»£ç æ‰§è¡Œ
```



### **5.2.1 ç”¨ç®€å•çš„ BNF æˆ– EBNF å®šä¹‰ Lambda è¡¨è¾¾å¼çš„è¯­æ³•**

åœ¨å®ç° Lambda Calculus è§£æå™¨ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰ Lambda è¡¨è¾¾å¼çš„è¯­æ³•è§„åˆ™ã€‚æ­£å¼çš„è¯­æ³•æè¿°æœ‰åŠ©äºè§£æå™¨æ­£ç¡®è¯†åˆ«å’Œå¤„ç†è¡¨è¾¾å¼ã€‚æœ¬èŠ‚å°†ä½¿ç”¨ **BNFï¼ˆå·´ç§‘æ–¯-è¯ºå°”èŒƒå¼ï¼ŒBackus-Naur Formï¼‰** å’Œ **EBNFï¼ˆæ‰©å±• BNFï¼ŒExtended Backus-Naur Formï¼‰** æ¥å®šä¹‰ Lambda Calculus çš„è¯­æ³•ã€‚

------

#### **1. ä¸ºä»€ä¹ˆéœ€è¦å½¢å¼åŒ–è¯­æ³•ï¼Ÿ**

å½¢å¼åŒ–è¯­æ³•å®šä¹‰äº† Lambda è¡¨è¾¾å¼çš„ç»“æ„ï¼Œä½¿å¾—è§£æå™¨èƒ½å¤ŸæŒ‰ç…§ä¸¥æ ¼çš„è§„åˆ™è§£æè¾“å…¥å¹¶ç”Ÿæˆ ASTï¼ˆæŠ½è±¡è¯­æ³•æ ‘ï¼‰ã€‚æ˜ç¡®çš„è¯­æ³•å®šä¹‰å¯ä»¥ï¼š

- **æ¶ˆé™¤æ­§ä¹‰**ï¼šä¸åŒçš„ Lambda è¡¨è¾¾å¼ä¹¦å†™æ–¹å¼å¯èƒ½è¡¨è¾¾ç›¸åŒçš„è®¡ç®—é€»è¾‘ã€‚
- **æŒ‡å¯¼è§£æå™¨è®¾è®¡**ï¼šè§£æå™¨æ ¹æ®è¯­æ³•è§„åˆ™æ„é€  ASTï¼Œå¹¶è¿›è¡Œæ±‚å€¼æˆ–ç¼–è¯‘ã€‚
- **ä¼˜åŒ–è§£ææµç¨‹**ï¼šå½¢å¼åŒ–è¯­æ³•å¯ç”¨äºæ„å»ºé«˜æ•ˆçš„è§£æç®—æ³•ï¼Œå¦‚é€’å½’ä¸‹é™è§£ææˆ– LALR è§£æã€‚

------

#### **2. Lambda Calculus çš„åŸºæœ¬æ„é€ **

Lambda Calculus è¯­æ³•ä¸»è¦ç”±ä»¥ä¸‹ä¸‰ç§åŸºæœ¬æ„é€ ç»„æˆï¼š

1. **å˜é‡ï¼ˆVariableï¼‰**ï¼š
   - å˜é‡æ˜¯ Lambda è¡¨è¾¾å¼çš„åŸºæœ¬å•å…ƒï¼Œå¦‚ `x`ã€`y`ã€`z`ã€‚
   - åœ¨ AST ä¸­è¡¨ç¤ºä¸º `Var("x")`ã€‚
2. **Lambda æŠ½è±¡ï¼ˆLambda Abstractionï¼‰**ï¼š
   - å½¢å¼ä¸º `Î»x. E`ï¼Œè¡¨ç¤ºå®šä¹‰ä¸€ä¸ªåŒ¿åå‡½æ•°ï¼Œæ¥å— `x` ä½œä¸ºå‚æ•°ï¼Œ`E` ä½œä¸ºå‡½æ•°ä½“ã€‚
   - åœ¨ AST ä¸­è¡¨ç¤ºä¸º `Lambda("x", body)`ã€‚
3. **å‡½æ•°åº”ç”¨ï¼ˆApplicationï¼‰**ï¼š
   - å½¢å¼ä¸º `E1 E2`ï¼Œè¡¨ç¤ºå°† `E2` ä½œä¸ºå‚æ•°ä¼ é€’ç»™ `E1`ã€‚
   - åœ¨ AST ä¸­è¡¨ç¤ºä¸º `App(func, arg)`ã€‚

æ­¤å¤–ï¼Œä¸ºäº†æ˜ç¡®è¡¨è¾¾å¼çš„ä¼˜å…ˆçº§ï¼Œæˆ‘ä»¬ä½¿ç”¨æ‹¬å· `()` è¿›è¡Œåˆ†ç»„ã€‚

------

#### **3. ç”¨ BNF å®šä¹‰ Lambda Calculus è¯­æ³•**

BNFï¼ˆBackus-Naur Formï¼‰æ˜¯ä¸€ç§ç”¨äºæ­£å¼æè¿°è¯­æ³•çš„è¡¨ç¤ºæ–¹æ³•ï¼Œå®ƒä½¿ç”¨é€’å½’è§„åˆ™æ¥å®šä¹‰è¯­æ³•ç»“æ„ã€‚

**BNF è¯­æ³•å®šä¹‰**

```
<expr> ::= <variable> 
         | <abstraction>
         | <application>

<variable> ::= [a-zA-Z_][a-zA-Z0-9_]*

<abstraction> ::= "Î»" <variable> "." <expr>

<application> ::= <expr> <expr>
               | "(" <expr> ")"
```

##### **è§£æ**

- `<expr>` ä»£è¡¨ä»»æ„ Lambda è¡¨è¾¾å¼ï¼Œå¯ä»¥æ˜¯å˜é‡ã€æŠ½è±¡æˆ–åº”ç”¨ã€‚
- `<variable>` ä»£è¡¨å˜é‡ï¼Œç”±å­—æ¯ï¼ˆ`a-zA-Z`ï¼‰å’Œä¸‹åˆ’çº¿ `_` ç»„æˆã€‚
- `<abstraction>` è¡¨ç¤º Lambda æŠ½è±¡ï¼Œä»¥ `Î»` å¼€å¤´ï¼Œåè·Ÿå‚æ•°åå’Œä¸€ä¸ª `.`ï¼Œç„¶åæ˜¯è¡¨è¾¾å¼ä½“ã€‚
- `<application>` è¡¨ç¤ºå‡½æ•°åº”ç”¨ï¼Œä¸¤ä¸ªè¡¨è¾¾å¼ç›¸é‚»å³è¡¨ç¤ºåº”ç”¨å…³ç³»ï¼Œæ‹¬å·ç”¨äºåˆ†ç»„ã€‚

##### **ç¤ºä¾‹è§£æ**

Lambda è¡¨è¾¾å¼ `Î»x. x` çš„ç»“æ„ï¼š

```
<expr> â†’ <abstraction> â†’ "Î»" <variable> "." <expr>
```

Lambda è¡¨è¾¾å¼ `(Î»x. x) y` çš„ç»“æ„ï¼š

```
<expr> â†’ <application> â†’ <abstraction> <expr>
```

------

#### **4. ç”¨ EBNF å®šä¹‰ Lambda Calculus è¯­æ³•**

æ‰©å±• BNFï¼ˆEBNFï¼ŒExtended BNFï¼‰æ˜¯ BNF çš„å¢å¼ºç‰ˆæœ¬ï¼Œå®ƒæ”¯æŒæ›´å¼ºå¤§çš„è¡¨è¾¾èƒ½åŠ›ï¼Œä¾‹å¦‚ï¼š

- **å¯é€‰é¡¹ `[ ]`**
- **é›¶æˆ–å¤šæ¬¡ `{ }\*`**
- **ä¸€æ¬¡æˆ–å¤šæ¬¡ `{ }+`**
- **æ›¿ä»£ç¬¦å· `|`ï¼ˆè¡¨ç¤ºâ€œæˆ–â€ï¼‰**

**EBNF è¯­æ³•å®šä¹‰**

```
expr        ::= variable
              | abstraction
              | application
              | "(" expr ")"

variable    ::= [a-zA-Z_][a-zA-Z0-9_]*

abstraction ::= ("Î»" | "\\") variable "." expr

application ::= expr expr+
```

##### **è§£æ**

- `variable`ï¼šå˜é‡åç”±å­—æ¯å’Œæ•°å­—ç»„æˆã€‚
- `abstraction`ï¼šç”¨ `Î»` æˆ– `\` å¼€å¤´ï¼Œå‚æ•°åé¢å¿…é¡»è·Ÿ `.`ï¼Œç„¶åæ˜¯è¡¨è¾¾å¼ä½“ã€‚
- `application`ï¼šç”±ä¸€ä¸ªæˆ–å¤šä¸ªè¡¨è¾¾å¼è¿ç»­ç»„åˆå½¢æˆã€‚
- `expr` å¯ä»¥æ˜¯å˜é‡ã€æŠ½è±¡ã€åº”ç”¨æˆ–æ‹¬å·åŒ…å›´çš„è¡¨è¾¾å¼ã€‚

##### **ç¤ºä¾‹**

| Lambda è¡¨è¾¾å¼   | è§£æç»“æ„                      |
| --------------- | ----------------------------- |
| `Î»x. x`         | `abstraction`                 |
| `(Î»x. x) y`     | `application`                 |
| `Î»x. (Î»y. y) x` | `abstraction` + `application` |

------

#### **5. è¯­æ³•è§£æç¤ºä¾‹**

##### **ç¤ºä¾‹ 1ï¼šLambda æŠ½è±¡**

**è¾“å…¥**

```
Î»x. x
```

**è§£æ**

```
abstraction â†’ "Î»" variable "." expr
```

##### **ç¤ºä¾‹ 2ï¼šå‡½æ•°åº”ç”¨**

**è¾“å…¥**

```
(Î»x. x) y
```

**è§£æ**

```
application â†’ expr expr
    expr â†’ abstraction
    abstraction â†’ "Î»" variable "." expr
    expr â†’ variable
```

##### **ç¤ºä¾‹ 3ï¼šåµŒå¥—è¡¨è¾¾å¼**

**è¾“å…¥**

```
Î»x. (Î»y. y) x
```

**è§£æ**

```
abstraction â†’ "Î»" variable "." expr
    expr â†’ application
        application â†’ abstraction expr
        abstraction â†’ "Î»" variable "." expr
        expr â†’ variable
```

------

#### **å°ç»“**

- **BNF è¯­æ³•** æä¾›äº† Lambda Calculus çš„æ­£å¼å®šä¹‰ï¼Œé€‚ç”¨äºä¸¥æ ¼çš„è¯­æ³•åˆ†æã€‚
- **EBNF è¯­æ³•** æ›´å…·å¯è¯»æ€§ï¼Œé€‚ç”¨äºå®é™…è§£æå™¨å®ç°ã€‚
- **è§£æå™¨éœ€è¦éµå¾ªè¿™äº›è§„åˆ™**ï¼Œä»¥ç¡®ä¿æ­£ç¡®è§£æå˜é‡ã€Lambda æŠ½è±¡å’Œå‡½æ•°åº”ç”¨è¡¨è¾¾å¼ã€‚
- é€šè¿‡å…·ä½“ç¤ºä¾‹ï¼Œæˆ‘ä»¬å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ BNF/EBNF è§£æ Lambda è¡¨è¾¾å¼ï¼Œæ„å»º AST ç»“æ„ã€‚

ä¸‹ä¸€èŠ‚ï¼Œæˆ‘ä»¬å°†åŸºäºè¿™äº›è§„åˆ™**å®ç°ä¸€ä¸ªå®Œæ•´çš„è§£æå™¨ï¼ˆParserï¼‰**ï¼Œç”¨äºè§£æ Lambda è¡¨è¾¾å¼å¹¶æ„å»º ASTï¼ğŸš€

### **5.2.2 è®¾è®¡ä¸€ä¸ªç®€æ˜“çš„ Parser**

åœ¨ä¸Šä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ **BNF å’Œ EBNF** å½¢å¼åŒ–åœ°å®šä¹‰äº† Lambda Calculus çš„è¯­æ³•ç»“æ„ã€‚è§£æå™¨ï¼ˆParserï¼‰çš„ä»»åŠ¡æ˜¯å°†è¾“å…¥çš„ **Lambda è¡¨è¾¾å¼** è½¬æ¢ä¸º **æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰**ï¼Œä»¥ä¾¿è§£é‡Šå™¨å¯¹å…¶è¿›è¡Œæ±‚å€¼ã€‚

æœ¬èŠ‚å°†ä»‹ç»ï¼š

1. **è§£æå™¨çš„ä½œç”¨ä¸å·¥ä½œæµç¨‹**
2. **æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰çš„æ•°æ®ç»“æ„**
3. **é€’å½’ä¸‹é™è§£æï¼ˆRecursive Descent Parsingï¼‰**
4. **è§£æç¤ºä¾‹**

------

#### **1. è§£æå™¨çš„ä½œç”¨ä¸å·¥ä½œæµç¨‹**

è§£æå™¨ï¼ˆParserï¼‰æ˜¯è§£é‡Šå™¨çš„æ ¸å¿ƒç»„ä»¶ä¹‹ä¸€ï¼Œè´Ÿè´£å°†è¾“å…¥å­—ç¬¦ä¸²è½¬æ¢ä¸º ASTï¼Œä½¿åç»­çš„æ±‚å€¼é˜¶æ®µå¯ä»¥å¯¹å…¶è¿›è¡Œè®¡ç®—ã€‚è§£æå™¨çš„åŸºæœ¬å·¥ä½œæµç¨‹å¦‚ä¸‹ï¼š

1. **è¯æ³•åˆ†æï¼ˆLexical Analysisï¼‰**

   - è§£æè¾“å…¥å­—ç¬¦ä¸²å¹¶è½¬æ¢ä¸º**æ ‡è®°åºåˆ—ï¼ˆTokensï¼‰**ã€‚

   - ä¾‹å¦‚ï¼š

     ```
     è¾“å…¥: Î»x. (Î»y. y) x
     è¯æ³•åˆ†æç»“æœ: [('LAMBDA', 'Î»'), ('IDENT', 'x'), ('DOT', '.'), ('LPAREN', '('),
                    ('LAMBDA', 'Î»'), ('IDENT', 'y'), ('DOT', '.'), ('IDENT', 'y'),
                    ('RPAREN', ')'), ('IDENT', 'x')]
     ```

2. **è¯­æ³•åˆ†æï¼ˆParsingï¼‰**

   - æ ¹æ® Lambda Calculus çš„è¯­æ³•è§„åˆ™ï¼Œå°†æ ‡è®°åºåˆ—è§£æä¸º **AST**ã€‚

   - ä¾‹å¦‚ï¼š

     ```
     è¾“å…¥: Î»x. (Î»y. y) x
     AST: Lambda("x", App(Lambda("y", Var("y")), Var("x")))
     ```

------

#### **2. æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰çš„æ•°æ®ç»“æ„**

ä¸ºäº†è¡¨ç¤º Lambda è¡¨è¾¾å¼çš„è¯­æ³•ç»“æ„ï¼Œæˆ‘ä»¬å®šä¹‰ AST çš„æ•°æ®ç»“æ„ï¼ŒåŒ…æ‹¬ï¼š

- **å˜é‡ï¼ˆVarï¼‰**
- **Lambda æŠ½è±¡ï¼ˆLambdaï¼‰**
- **åº”ç”¨ï¼ˆAppï¼‰**

```python
class Expr:
    """Lambda Calculus æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰çš„åŸºç±»"""
    pass

class Var(Expr):
    """å˜é‡èŠ‚ç‚¹"""
    def __init__(self, name: str):
        self.name = name

    def __repr__(self):
        return self.name

class Lambda(Expr):
    """Lambda æŠ½è±¡ï¼ˆÎ»x. bodyï¼‰"""
    def __init__(self, param: str, body: Expr):
        self.param = param
        self.body = body

    def __repr__(self):
        return f"(Î»{self.param}. {self.body})"

class App(Expr):
    """å‡½æ•°åº”ç”¨ï¼ˆE1 E2ï¼‰"""
    def __init__(self, func: Expr, arg: Expr):
        self.func = func
        self.arg = arg

    def __repr__(self):
        return f"({self.func} {self.arg})"
```

------

#### **3. é€’å½’ä¸‹é™è§£æï¼ˆRecursive Descent Parsingï¼‰**

ä¸ºäº†è§£æ Lambda è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬ä½¿ç”¨ **é€’å½’ä¸‹é™è§£æï¼ˆRecursive Descent Parsingï¼‰**ï¼Œè¿™æ˜¯ä¸€ç§è‡ªé¡¶å‘ä¸‹çš„è§£ææ–¹æ³•ï¼Œé€‚ç”¨äºåŸºäºé€’å½’ç»“æ„çš„è¯­è¨€ã€‚

è§£æå™¨å°†æŒ‰ç…§ä»¥ä¸‹é¡ºåºè§£æè¡¨è¾¾å¼ï¼š

1. **å˜é‡ï¼ˆVarï¼‰**
2. **Lambda æŠ½è±¡ï¼ˆLambdaï¼‰**
3. **åº”ç”¨ï¼ˆAppï¼‰**
4. **æ‹¬å·è¡¨è¾¾å¼ï¼ˆParenthesized Expressionï¼‰**

##### **è¯æ³•åˆ†æå™¨ï¼ˆLexerï¼‰**

åœ¨è§£æä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ª**è¯æ³•åˆ†æå™¨ï¼ˆLexerï¼‰**ï¼Œå®ƒå°†è¾“å…¥å­—ç¬¦ä¸²è½¬æ¢ä¸º**æ ‡è®°ï¼ˆTokensï¼‰**ã€‚

```python
import re

TOKEN_REGEX = [
    (r"\(", "LPAREN"),
    (r"\)", "RPAREN"),
    (r"Î»|\\\\", "LAMBDA"),  # å…è®¸ "Î»" æˆ– "\\" ä½œä¸º Lambda å…³é”®å­—
    (r"\.", "DOT"),
    (r"[a-zA-Z_][a-zA-Z0-9_]*", "IDENT"),
    (r"\s+", None)  # å¿½ç•¥ç©ºæ ¼
]

def tokenize(input_str):
    """å°†è¾“å…¥å­—ç¬¦ä¸²è½¬æ¢ä¸º Token åºåˆ—"""
    tokens = []
    while input_str:
        for pattern, tag in TOKEN_REGEX:
            match = re.match(pattern, input_str)
            if match:
                text = match.group(0)
                input_str = input_str[len(text):]  # å‘å‰ç§»åŠ¨åŒ¹é…çš„éƒ¨åˆ†
                if tag:
                    tokens.append((tag, text))
                break
        else:
            raise SyntaxError(f"æ— æ³•è§£æ: {input_str}")
    return tokens
```

##### **é€’å½’ä¸‹é™è§£æå™¨ï¼ˆParserï¼‰**

```python
class Parser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.pos = 0  # å½“å‰è§£æçš„ä½ç½®

    def peek(self):
        """æŸ¥çœ‹å½“å‰ Token"""
        return self.tokens[self.pos] if self.pos < len(self.tokens) else None

    def consume(self):
        """æ¶ˆè´¹å½“å‰ Token å¹¶ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ª"""
        token = self.peek()
        self.pos += 1
        return token

    def parse_var(self):
        """è§£æå˜é‡"""
        token = self.consume()
        return Var(token[1])

    def parse_lambda(self):
        """è§£æ Lambda æŠ½è±¡"""
        self.consume()  # æ¶ˆè´¹ 'Î»' æˆ– '\\'
        param = self.consume()[1]  # å˜é‡å
        self.consume()  # æ¶ˆè´¹ '.'
        body = self.parse_expr()
        return Lambda(param, body)

    def parse_paren_expr(self):
        """è§£ææ‹¬å·å†…çš„è¡¨è¾¾å¼"""
        self.consume()  # æ¶ˆè´¹ '('
        expr = self.parse_expr()
        self.consume()  # æ¶ˆè´¹ ')'
        return expr

    def parse_expr(self):
        """è§£æè¡¨è¾¾å¼"""
        exprs = []
        while self.peek() and self.peek()[0] not in ["RPAREN"]:
            if self.peek()[0] == "LAMBDA":
                exprs.append(self.parse_lambda())
            elif self.peek()[0] == "LPAREN":
                exprs.append(self.parse_paren_expr())
            else:
                exprs.append(self.parse_var())

        # å¤„ç†å‡½æ•°åº”ç”¨ï¼ˆå·¦ç»“åˆï¼‰
        expr = exprs[0]
        for e in exprs[1:]:
            expr = App(expr, e)
        return expr

    def parse(self):
        """è§£æå…¥å£"""
        return self.parse_expr()
```

------

#### **4. è§£æç¤ºä¾‹**

##### **ç¤ºä¾‹ 1ï¼šè§£æ Lambda è¡¨è¾¾å¼**

**è¾“å…¥**

```
Î»x. x
```

**è§£æç»“æœ**

```
Lambda("x", Var("x"))
```

##### **ç¤ºä¾‹ 2ï¼šè§£æå‡½æ•°åº”ç”¨**

**è¾“å…¥**

```
(Î»x. x) y
```

**è§£æç»“æœ**

```
App(Lambda("x", Var("x")), Var("y"))
```

##### **ç¤ºä¾‹ 3ï¼šè§£æåµŒå¥—è¡¨è¾¾å¼**

**è¾“å…¥**

```
Î»x. (Î»y. y) x
```

**è§£æç»“æœ**

```
Lambda("x", App(Lambda("y", Var("y")), Var("x")))
```

------

#### **å°ç»“**

- **è§£æå™¨çš„ä½œç”¨**ï¼šå°† Lambda è¡¨è¾¾å¼è§£æä¸º ASTï¼Œä½¿å¾—è§£é‡Šå™¨å¯ä»¥è¿›è¡Œæ±‚å€¼ã€‚
- **é€’å½’ä¸‹é™è§£ææ³•** æ˜¯è§£æ Lambda ç»“æ„çš„æœ‰æ•ˆæ–¹æ³•ï¼Œèƒ½å¤Ÿå¤„ç†åµŒå¥—ç»“æ„å’Œå‡½æ•°åº”ç”¨ã€‚
- **è¯æ³•åˆ†æå™¨ï¼ˆLexerï¼‰** å°†è¾“å…¥å­—ç¬¦ä¸²è½¬æ¢ä¸º Tokenï¼Œ**è§£æå™¨ï¼ˆParserï¼‰** æ ¹æ® Token æ„å»º ASTã€‚
- å®Œæ•´çš„è§£æè¿‡ç¨‹ï¼š
  1. è§£æå˜é‡ã€Lambda æŠ½è±¡ã€åº”ç”¨å’Œæ‹¬å·è¡¨è¾¾å¼ã€‚
  2. é€’å½’æ„å»º ASTï¼Œç¡®ä¿è¡¨è¾¾å¼ç»“æ„æ­£ç¡®ã€‚
  3. ç”Ÿæˆæœ€ç»ˆ AST ç»“æ„ï¼Œä»¥ä¾›æ±‚å€¼å™¨ï¼ˆEvaluatorï¼‰ä½¿ç”¨ã€‚

ä¸‹ä¸€èŠ‚ï¼Œæˆ‘ä»¬å°†ä»‹ç» **Lambda Calculus çš„æ±‚å€¼ç­–ç•¥**ï¼ŒåŒ…æ‹¬ **æ­£å¸¸åºï¼ˆNormal Orderï¼‰å’Œåº”ç”¨åºï¼ˆApplicative Orderï¼‰**ï¼ğŸš€

### **5.3.1 è¯„ä¼°ç­–ç•¥ï¼šæ­£å¸¸åºï¼ˆNormal Orderï¼‰ä¸åº”ç”¨åºï¼ˆApplicative Orderï¼‰**

åœ¨ Lambda Calculus çš„è®¡ç®—è¿‡ç¨‹ä¸­ï¼Œä¸åŒçš„æ±‚å€¼ç­–ç•¥å†³å®šäº†è¡¨è¾¾å¼çš„è®¡ç®—é¡ºåºã€‚è¿™äº›ç­–ç•¥çš„é€‰æ‹©ä¼šå½±å“è®¡ç®—çš„æ•ˆç‡ã€æ˜¯å¦ä¼šç»ˆæ­¢ã€ä»¥åŠæœ€ç»ˆçš„è®¡ç®—ç»“æœã€‚æœ¬èŠ‚ä¸»è¦è®¨è®º **æ­£å¸¸åºï¼ˆNormal Orderï¼‰** å’Œ **åº”ç”¨åºï¼ˆApplicative Orderï¼‰** è¿™ä¸¤ç§ä¸»è¦çš„æ±‚å€¼ç­–ç•¥ã€‚

------

#### **1. ä»€ä¹ˆæ˜¯æ±‚å€¼ç­–ç•¥ï¼Ÿ**

æ±‚å€¼ç­–ç•¥ï¼ˆEvaluation Strategyï¼‰å†³å®šäº† Lambda è®¡ç®—è¿‡ç¨‹ä¸­ **å­è¡¨è¾¾å¼** ä½•æ—¶è¢«è®¡ç®—ã€‚Lambda è¡¨è¾¾å¼çš„æ±‚å€¼éµå¾ª **Î²-å½’çº¦ï¼ˆBeta Reductionï¼‰** è§„åˆ™ï¼Œå³ï¼š

```
(Î»x. E1) E2 â†’ E1[x := E2]
```

å…¶ä¸­ï¼Œ`E2` ä½œä¸º `x` çš„å‚æ•°è¢«æ›¿æ¢åˆ° `E1` ä¸­ã€‚æ±‚å€¼ç­–ç•¥å†³å®šäº†ä½•æ—¶æ‰§è¡Œè¿™ä¸ªæ›¿æ¢ã€‚

æ±‚å€¼ç­–ç•¥çš„ä¸¤ç§ä¸»è¦æ–¹å¼ï¼š

1. **æ­£å¸¸åºï¼ˆNormal Orderï¼‰**ï¼šæœ€å¤–å±‚çš„ Lambda è¡¨è¾¾å¼å…ˆè¢«å±•å¼€ï¼Œç›´åˆ°éœ€è¦å¯¹å‚æ•°è¿›è¡Œæ±‚å€¼æ—¶æ‰è¿›è¡Œæ›¿æ¢ï¼ˆä¹Ÿç§°ä¸º **å¤–éƒ¨æœ€å·¦å…ˆ**ï¼Œleftmost outermostï¼‰ã€‚
2. **åº”ç”¨åºï¼ˆApplicative Orderï¼‰**ï¼šæ‰€æœ‰çš„å‚æ•°éƒ½åœ¨æ±‚å€¼ä¹‹å‰å…ˆè¿›è¡Œè®¡ç®—ï¼ˆä¹Ÿç§°ä¸º **å†…éƒ¨æœ€å·¦å…ˆ**ï¼Œleftmost innermostï¼‰ã€‚

------

#### **2. æ­£å¸¸åºï¼ˆNormal Orderï¼‰**

**æ­£å¸¸åº**ï¼ˆNormal Orderï¼‰æ˜¯ä¸€ç§ **æƒ°æ€§æ±‚å€¼ï¼ˆLazy Evaluationï¼‰** ç­–ç•¥ï¼Œå®ƒçš„æ ¸å¿ƒåŸåˆ™æ˜¯ï¼š

- **å…ˆå±•å¼€ Lambda è¡¨è¾¾å¼**ï¼Œå†å¯¹å‚æ•°è¿›è¡Œæ›¿æ¢ã€‚
- **å‚æ•°ä¸æå‰æ±‚å€¼**ï¼Œåªæœ‰åœ¨çœŸæ­£éœ€è¦æ—¶æ‰è¿›è¡Œè®¡ç®—ã€‚
- **å¯ä»¥è®¡ç®—å‡ºæŸäº›ä¼šå¯¼è‡´æ— é™å¾ªç¯çš„è¡¨è¾¾å¼çš„ç»“æœ**ï¼ˆåªè¦ç»“æœä¸ä¾èµ–äºä¼šæ— é™å¾ªç¯çš„éƒ¨åˆ†ï¼‰ã€‚

##### **æ±‚å€¼ç¤ºä¾‹**

è€ƒè™‘è¡¨è¾¾å¼ï¼š

```
(Î»x. 1) ((Î»y. y y) (Î»y. y y))
```

æŒ‰ç…§ **æ­£å¸¸åº** è®¡ç®—ï¼š

1. ä¼˜å…ˆå±•å¼€æœ€å¤–å±‚çš„ Lambda æŠ½è±¡ï¼š

   ```
   (Î»x. 1) ((Î»y. y y) (Î»y. y y))
   â†’ 1
   ```

   ç”±äº `x` åœ¨ `Î»x. 1` çš„å‡½æ•°ä½“ä¸­ æ²¡æœ‰è¢«ä½¿ç”¨ï¼Œæ‰€ä»¥æ•´ä¸ªå‚æ•° 

   ```
   (Î»y. y y) (Î»y. y y)
   ```

   ä¸ä¼šè¢«è®¡ç®—ã€‚

**å…³é”®ç‰¹æ€§**

- **èƒ½å¤Ÿè§„é¿ä¸å¿…è¦çš„è®¡ç®—**ï¼šåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå®ƒå¯ä»¥é¿å…å¯¹æŸäº›è¡¨è¾¾å¼çš„æ±‚å€¼ï¼Œä»è€Œé¿å…æ— é™å¾ªç¯ã€‚
- **ä¿è¯æœ€å·¦å¤–çš„ Î²-å½’çº¦ä¼˜å…ˆè¿›è¡Œ**ï¼šå³ **å…ˆè®¡ç®—æœ€å¤–å±‚çš„è¡¨è¾¾å¼**ï¼Œç„¶åå†è®¡ç®—å†…éƒ¨çš„éƒ¨åˆ†ã€‚

------

#### **3. åº”ç”¨åºï¼ˆApplicative Orderï¼‰**

**åº”ç”¨åº**ï¼ˆApplicative Orderï¼‰æ˜¯ä¸€ç§ **ä¸¥æ ¼æ±‚å€¼ï¼ˆStrict Evaluationï¼‰** ç­–ç•¥ï¼Œå®ƒçš„æ ¸å¿ƒåŸåˆ™æ˜¯ï¼š

- **å‚æ•°åœ¨ä¼ é€’åˆ°å‡½æ•°ä¹‹å‰ï¼Œå¿…é¡»è¢«è®¡ç®—**ã€‚
- **æ‰€æœ‰å­è¡¨è¾¾å¼éƒ½ä¼šè¢«æ±‚å€¼**ï¼Œå³ä½¿æœ€ç»ˆçš„è®¡ç®—å¯èƒ½ä¸éœ€è¦å®ƒä»¬ã€‚
- **ä¸å¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€çš„æ±‚å€¼æ–¹å¼ä¸€è‡´**ï¼ˆå¦‚ Pythonã€Javaã€Cï¼‰ã€‚

##### **æ±‚å€¼ç¤ºä¾‹**

è€ƒè™‘ç›¸åŒçš„è¡¨è¾¾å¼ï¼š

```
(Î»x. 1) ((Î»y. y y) (Î»y. y y))
```

æŒ‰ç…§ **åº”ç”¨åº** è®¡ç®—ï¼š

1. å…ˆè®¡ç®—å‚æ•° `(Î»y. y y) (Î»y. y y)`ï¼š

   ```
   (Î»y. y y) (Î»y. y y) â†’ æ— é™å¾ªç¯
   ```

   ç”±äºå‚æ•° 

   ```
   (Î»y. y y) (Î»y. y y)
   ```

    ä¸èƒ½å½’çº¦åˆ°ä¸€ä¸ªç»ˆç»“å€¼ï¼Œå› æ­¤è®¡ç®—è¿›å…¥æ— é™å¾ªç¯ï¼Œæ— æ³•è¿”å› 1ã€‚

**å…³é”®ç‰¹æ€§**

- **éœ€è¦æ‰€æœ‰å‚æ•°æ±‚å€¼**ï¼šå³ä½¿å‚æ•°æœ€ç»ˆæ²¡æœ‰è¢«ä½¿ç”¨ï¼Œå®ƒä»¬ä»ç„¶ä¼šè¢«è®¡ç®—ã€‚
- **åœ¨æŸäº›æƒ…å†µä¸‹å¯èƒ½å¯¼è‡´éç»ˆæ­¢**ï¼šå¦‚æœä¸€ä¸ªå‚æ•°ä¼šæ— é™è®¡ç®—ï¼Œé‚£ä¹ˆæ•´ä¸ªè®¡ç®—ä¹Ÿä¸ä¼šç»ˆæ­¢ã€‚

------

#### **4. æ­£å¸¸åº vs. åº”ç”¨åºï¼šå…³é”®å¯¹æ¯”**

| ç»´åº¦                   | **æ­£å¸¸åºï¼ˆNormal Orderï¼‰**             | **åº”ç”¨åºï¼ˆApplicative Orderï¼‰**      |
| ---------------------- | -------------------------------------- | ------------------------------------ |
| **æ±‚å€¼é¡ºåº**           | å…ˆå±•å¼€ Lambda è¡¨è¾¾å¼ï¼Œå†æ±‚å€¼å‚æ•°       | å…ˆæ±‚å€¼æ‰€æœ‰å‚æ•°ï¼Œå†åº”ç”¨ Lambda è¡¨è¾¾å¼ |
| **å‚æ•°æ˜¯å¦é¢„è®¡ç®—**     | å¦ï¼ˆæƒ°æ€§æ±‚å€¼ï¼‰                         | æ˜¯ï¼ˆä¸¥æ ¼æ±‚å€¼ï¼‰                       |
| **æ˜¯å¦é¿å…æ— æ„ä¹‰è®¡ç®—** | æ˜¯ï¼Œåªè®¡ç®—çœŸæ­£éœ€è¦çš„éƒ¨åˆ†               | å¦ï¼Œæ‰€æœ‰å‚æ•°éƒ½ä¼šè®¡ç®—                 |
| **æ˜¯å¦å¯èƒ½æ— é™å¾ªç¯**   | å¦ï¼ˆå¦‚æœæœ€ç»ˆç»“æœä¸ä¾èµ–æ— ç©·é€’å½’çš„éƒ¨åˆ†ï¼‰ | æ˜¯ï¼ˆä»»ä½•é€’å½’è¡¨è¾¾å¼éƒ½ä¼šæ±‚å€¼ï¼‰         |
| **ç¼–ç¨‹è¯­è¨€ç¤ºä¾‹**       | Haskellï¼ˆé»˜è®¤æƒ°æ€§æ±‚å€¼ï¼‰                | Pythonã€Javaã€Cï¼ˆé»˜è®¤ä¸¥æ ¼æ±‚å€¼ï¼‰      |

------

#### **5. ä½•æ—¶ä½¿ç”¨ä¸åŒçš„æ±‚å€¼ç­–ç•¥ï¼Ÿ**

ä¸åŒçš„æ±‚å€¼ç­–ç•¥é€‚ç”¨äºä¸åŒçš„åœºæ™¯ï¼š

âœ… **æ­£å¸¸åºé€‚ç”¨äºï¼š**

- éœ€è¦ **çŸ­è·¯æ±‚å€¼**ï¼ˆå³è·³è¿‡ä¸å¿…è¦çš„è®¡ç®—ï¼‰ã€‚
- æƒ³è¦åœ¨ Lambda Calculus è¯æ˜ **æŸäº›è¡¨è¾¾å¼å¯ç»ˆæ­¢**ã€‚
- éœ€è¦å®ç° **æƒ°æ€§è®¡ç®—ï¼ˆLazy Evaluationï¼‰**ï¼Œå¦‚ Haskell çš„ `lazy` å…³é”®å­—ã€‚

âœ… **åº”ç”¨åºé€‚ç”¨äºï¼š**

- éœ€è¦åœ¨ **ä¼ ç»Ÿç¼–ç¨‹è¯­è¨€**ï¼ˆå¦‚ Pythonã€Javaã€Cï¼‰ä¸­å®ç° Lambda Calculusã€‚
- ä»£ç éœ€è¦ä¸¥æ ¼æ±‚å€¼ä»¥é¿å… **æ‚¬ç©ºå¼•ç”¨**ï¼ˆdangling referenceï¼‰ã€‚
- è®¡ç®—ä¸­çš„æ‰€æœ‰å‚æ•°éƒ½å¿…é¡» **æ˜¾å¼æ±‚å€¼** æ‰èƒ½å¾—åˆ°æ­£ç¡®ç»“æœã€‚

------

#### **6. ç¤ºä¾‹ä»£ç ï¼šPython å®ç°ä¸¤ç§æ±‚å€¼ç­–ç•¥**

åœ¨ Python ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æ¨¡æ‹Ÿè¿™ä¸¤ç§æ±‚å€¼æ–¹å¼ã€‚

##### **æ­£å¸¸åºï¼ˆLazy Evaluationï¼‰**

```python
def normal_order_evaluation(expr):
    if isinstance(expr, App):
        if isinstance(expr.func, Lambda):
            return normal_order_evaluation(substitute(expr.func.body, expr.func.param, expr.arg))
        else:
            return App(normal_order_evaluation(expr.func), normal_order_evaluation(expr.arg))
    return expr  # å˜é‡æˆ–æœ€ç»ˆæ±‚å€¼ç»“æœ
```

##### **åº”ç”¨åºï¼ˆStrict Evaluationï¼‰**

```python
def applicative_order_evaluation(expr):
    if isinstance(expr, App):
        evaluated_arg = applicative_order_evaluation(expr.arg)  # å…ˆæ±‚å€¼å‚æ•°
        if isinstance(expr.func, Lambda):
            return applicative_order_evaluation(substitute(expr.func.body, expr.func.param, evaluated_arg))
        else:
            return App(applicative_order_evaluation(expr.func), evaluated_arg)
    return expr  # å˜é‡æˆ–æœ€ç»ˆæ±‚å€¼ç»“æœ
```



------

#### **å°ç»“**

- **æ­£å¸¸åºï¼ˆNormal Orderï¼‰** **å…ˆå±•å¼€æœ€å¤–å±‚çš„ Lambda è¡¨è¾¾å¼**ï¼Œç„¶åå†è®¡ç®—å‚æ•°ã€‚
- **åº”ç”¨åºï¼ˆApplicative Orderï¼‰** **å…ˆè®¡ç®—å‚æ•°ï¼Œå†è¿›è¡Œ Lambda æ›¿æ¢**ã€‚
- **æ­£å¸¸åºå¯ä»¥è§„é¿ä¸å¿…è¦çš„è®¡ç®—**ï¼Œé¿å…æŸäº›æƒ…å†µä¸‹çš„æ— é™å¾ªç¯ã€‚
- **åº”ç”¨åºæ›´ç¬¦åˆå¤§å¤šæ•°ç°ä»£ç¼–ç¨‹è¯­è¨€**ï¼Œä½†å¯èƒ½ä¼šå¯¼è‡´éç»ˆæ­¢è®¡ç®—ã€‚
- **ä¸åŒçš„ç¼–ç¨‹è¯­è¨€é‡‡ç”¨ä¸åŒçš„æ±‚å€¼ç­–ç•¥**ï¼Œå¦‚ **Haskell ä½¿ç”¨æ­£å¸¸åºï¼ˆLazy Evaluationï¼‰**ï¼Œè€Œ **Python å’Œ Java ä½¿ç”¨åº”ç”¨åºï¼ˆStrict Evaluationï¼‰**ã€‚

åœ¨ä¸‹ä¸€èŠ‚ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢è®¨ **æƒ°æ€§æ±‚å€¼ï¼ˆLazy Evaluationï¼‰** å’Œ **ä¸¥æ ¼æ±‚å€¼ï¼ˆStrict Evaluationï¼‰** å¯¹è®¡ç®—æ€§èƒ½å’Œä¼˜åŒ–çš„å½±å“ï¼ğŸš€

### **5.3.2 æƒ°æ€§æ±‚å€¼ä¸ä¸¥æ ¼æ±‚å€¼çš„å½±å“**

åœ¨ä¸Šä¸€èŠ‚ï¼Œæˆ‘ä»¬è®¨è®ºäº†**æ­£å¸¸åºï¼ˆNormal Orderï¼‰\**å’Œ\**åº”ç”¨åºï¼ˆApplicative Orderï¼‰**ï¼Œå¹¶ä»‹ç»äº†å®ƒä»¬åœ¨ Lambda Calculus è®¡ç®—è¿‡ç¨‹ä¸­çš„ä½œç”¨ã€‚æˆ‘ä»¬æåˆ° **æ­£å¸¸åº** é‡‡ç”¨**æƒ°æ€§æ±‚å€¼ï¼ˆLazy Evaluationï¼‰**ï¼Œè€Œ **åº”ç”¨åº** é‡‡ç”¨**ä¸¥æ ¼æ±‚å€¼ï¼ˆStrict Evaluationï¼‰**ã€‚æœ¬èŠ‚å°†æ·±å…¥æ¢è®¨è¿™ä¸¤ç§æ±‚å€¼æ–¹å¼å¯¹**è®¡ç®—æ•ˆç‡ã€å†…å­˜ç®¡ç†** ä»¥åŠ**ç°ä»£ç¼–ç¨‹è¯­è¨€çš„å½±å“**ã€‚

------

#### **1. æƒ°æ€§æ±‚å€¼ï¼ˆLazy Evaluationï¼‰**

**æƒ°æ€§æ±‚å€¼ï¼ˆLazy Evaluationï¼‰** æ˜¯æŒ‡ **è¡¨è¾¾å¼åªæœ‰åœ¨éœ€è¦æ—¶æ‰è¢«è®¡ç®—**ï¼Œè¿™ä¸æ­£å¸¸åºçš„æ±‚å€¼ç­–ç•¥ä¸€è‡´ã€‚Lambda Calculus çš„**æ­£å¸¸åºï¼ˆNormal Orderï¼‰** å¯ä»¥è¢«è§†ä¸ºä¸€ç§æƒ°æ€§æ±‚å€¼ç­–ç•¥çš„å®ç°æ–¹å¼ã€‚

#### **1.1 æƒ°æ€§æ±‚å€¼çš„æ ¸å¿ƒç‰¹ç‚¹**

- **é¿å…ä¸å¿…è¦çš„è®¡ç®—**ï¼šå¦‚æœè®¡ç®—ç»“æœä¸ä¾èµ–æŸäº›å­è¡¨è¾¾å¼ï¼Œè¿™äº›å­è¡¨è¾¾å¼å°±ä¸ä¼šè¢«æ±‚å€¼ã€‚
- **æ”¯æŒæ— é™æ•°æ®ç»“æ„**ï¼šå…è®¸ä½¿ç”¨æƒ°æ€§ç”Ÿæˆçš„æ•°æ®ç»“æ„ï¼Œå¦‚æ— é™åˆ—è¡¨ã€‚
- **æé«˜ç¨‹åºçš„å¯è¯»æ€§**ï¼šä»£ç ç¼–å†™æ›´ç¬¦åˆæ•°å­¦ç›´è§‰ã€‚

#### **1.2 æƒ°æ€§æ±‚å€¼çš„æ€§èƒ½ä¼˜åŒ–**

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæƒ°æ€§æ±‚å€¼å¯ä»¥æ˜¾è‘—æå‡è®¡ç®—æ•ˆç‡ï¼š

```haskell
-- Haskell ä»£ç ç¤ºä¾‹ï¼šæƒ°æ€§æ±‚å€¼é¿å…ä¸å¿…è¦çš„è®¡ç®—
const x y = x    -- const æ˜¯ä¸€ä¸ªå›ºå®šè¿”å›ç¬¬ä¸€ä¸ªå‚æ•°çš„å‡½æ•°
result = const 5 (9999999 `div` 0)  -- ç”±äºç¬¬äºŒä¸ªå‚æ•°æ°¸è¿œä¸ä¼šè¢«è®¡ç®—ï¼Œå› æ­¤ä¸ä¼šå‘ç”Ÿé™¤é›¶é”™è¯¯
```

åœ¨ Python æˆ– Java ç­‰ä¸¥æ ¼æ±‚å€¼è¯­è¨€ä¸­ï¼Œè¿™ç§å†™æ³•ä¼šå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯ï¼š

```python
def const(x, y):
    return x

result = const(5, 9999999 // 0)  # Python è¿›è¡Œä¸¥æ ¼æ±‚å€¼ï¼Œå¯¼è‡´ ZeroDivisionError
```

**å…³é”®ç‚¹**ï¼š

- åœ¨ Haskellï¼ˆé»˜è®¤æƒ°æ€§æ±‚å€¼ï¼‰ä¸­ï¼Œ`const 5 (9999999 // 0)` **ä¸ä¼šæ‰§è¡Œé™¤æ³•**ï¼Œå› æ­¤ä¸ä¼šæŠ›å‡ºé”™è¯¯ã€‚
- åœ¨ Pythonï¼ˆä¸¥æ ¼æ±‚å€¼ï¼‰ä¸­ï¼Œ`9999999 // 0` **åœ¨ä¼ å…¥ `const` ä¹‹å‰å°±å·²ç»è®¡ç®—**ï¼Œå¯¼è‡´é”™è¯¯ã€‚

#### **1.3 æƒ°æ€§æ±‚å€¼çš„ç¼ºç‚¹**

- **å¢åŠ å†…å­˜å ç”¨**ï¼šæœªæ±‚å€¼çš„è¡¨è¾¾å¼ï¼ˆthunksï¼‰ä¼šå æ®é¢å¤–çš„å†…å­˜ï¼Œå¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼ã€‚
- **è°ƒè¯•éš¾åº¦å¢åŠ **ï¼šç”±äºè®¡ç®—æ˜¯æŒ‰éœ€è¿›è¡Œçš„ï¼Œç¨‹åºçš„æ‰§è¡Œé¡ºåºéš¾ä»¥é¢„æµ‹ã€‚

------

#### **2. ä¸¥æ ¼æ±‚å€¼ï¼ˆStrict Evaluationï¼‰**

**ä¸¥æ ¼æ±‚å€¼ï¼ˆStrict Evaluationï¼‰**ï¼Œä¹Ÿç§°**åŠæ—©æ±‚å€¼ï¼ˆEager Evaluationï¼‰**ï¼Œæ˜¯æŒ‡**æ‰€æœ‰å‚æ•°åœ¨ä¼ é€’åˆ°å‡½æ•°ä¹‹å‰å°±å·²ç»è¢«è®¡ç®—**ã€‚Lambda Calculus çš„**åº”ç”¨åºï¼ˆApplicative Orderï¼‰**æ˜¯ä¸¥æ ¼æ±‚å€¼çš„ä½“ç°ã€‚

#### **2.1 ä¸¥æ ¼æ±‚å€¼çš„æ ¸å¿ƒç‰¹ç‚¹**

- **è®¡ç®—é¡ºåºå›ºå®š**ï¼šæ‰€æœ‰å­è¡¨è¾¾å¼åœ¨è®¡ç®—å‰éƒ½ä¼šè¢«æ±‚å€¼ã€‚
- **å‡å°‘å†…å­˜å ç”¨**ï¼šå› ä¸ºæ‰€æœ‰çš„è¡¨è¾¾å¼éƒ½ä¼šç«‹å³æ±‚å€¼ï¼Œä¸éœ€è¦å­˜å‚¨æœªè®¡ç®—çš„ `thunk`ï¼ˆæƒ°æ€§è®¡ç®—çš„ä¸­é—´ç»“æ„ï¼‰ã€‚
- **ç¬¦åˆå¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€çš„æ‰§è¡Œæ–¹å¼**ï¼šå¦‚ Pythonã€Javaã€C++ ç­‰ã€‚

#### **2.2 ä¸¥æ ¼æ±‚å€¼çš„æ€§èƒ½å½±å“**

åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œä¸¥æ ¼æ±‚å€¼èƒ½æé«˜è®¡ç®—çš„ç¡®å®šæ€§å’Œæ‰§è¡Œæ•ˆç‡ã€‚ä¾‹å¦‚ï¼š

```python
def square(x):
    return x * x

print(square(5 + 3))  # è®¡ç®—è¿‡ç¨‹ï¼š(5 + 3) â†’ 8 â†’ 8 * 8 â†’ 64
```

åœ¨ Python ä¸­ï¼Œ`5 + 3` **å…ˆè®¡ç®—**ï¼Œç„¶åå†è°ƒç”¨ `square(8)`ã€‚

#### **2.3 ä¸¥æ ¼æ±‚å€¼çš„ç¼ºç‚¹**

- **å¯èƒ½å¯¼è‡´ä¸å¿…è¦çš„è®¡ç®—**ï¼šå³ä½¿æŸäº›è¡¨è¾¾å¼æœ€ç»ˆä¸è¢«ä½¿ç”¨ï¼Œä¹Ÿä¼šæå‰è®¡ç®—ï¼Œå¯èƒ½ä¼šå½±å“æ€§èƒ½ã€‚
- **æ— æ³•è‡ªç„¶å¤„ç†æ— é™æ•°æ®ç»“æ„**ï¼šå¦‚æœæ•°æ®ç»“æ„æ˜¯æ— é™çš„ï¼Œåˆ™ä¸¥æ ¼æ±‚å€¼ä¼šé™·å…¥æ— é™å¾ªç¯ã€‚

------

#### **3. æƒ°æ€§æ±‚å€¼ vs. ä¸¥æ ¼æ±‚å€¼ï¼šæ ¸å¿ƒå¯¹æ¯”**

| ç‰¹æ€§             | æƒ°æ€§æ±‚å€¼ï¼ˆLazy Evaluationï¼‰    | ä¸¥æ ¼æ±‚å€¼ï¼ˆStrict Evaluationï¼‰ |
| ---------------- | ------------------------------ | ----------------------------- |
| **æ±‚å€¼æ–¹å¼**     | åªæœ‰åœ¨éœ€è¦æ—¶æ‰è®¡ç®—             | ç«‹å³è®¡ç®—æ‰€æœ‰è¡¨è¾¾å¼            |
| **å‚æ•°æ±‚å€¼æ—¶æœº** | ä»…åœ¨ä½¿ç”¨æ—¶æ±‚å€¼                 | ä¼ é€’åˆ°å‡½æ•°å‰å°±å·²æ±‚å€¼          |
| **è®¡ç®—æ•ˆç‡**     | å¯èƒ½æé«˜æ•ˆç‡ï¼ˆé¿å…å†—ä½™è®¡ç®—ï¼‰   | å¯èƒ½é™ä½æ•ˆç‡ï¼ˆè®¡ç®—æ‰€æœ‰å‚æ•°ï¼‰  |
| **å†…å­˜ä½¿ç”¨**     | å¯èƒ½å¢åŠ ï¼ˆå­˜å‚¨æœªè®¡ç®—çš„è¡¨è¾¾å¼ï¼‰ | è¾ƒä½ï¼ˆæ‰€æœ‰è¡¨è¾¾å¼ç«‹å³è®¡ç®—ï¼‰    |
| **æ— é™æ•°æ®ç»“æ„** | æ”¯æŒ                           | ä¸æ”¯æŒ                        |
| **ç¼–ç¨‹è¯­è¨€ç¤ºä¾‹** | Haskellï¼ˆé»˜è®¤æƒ°æ€§ï¼‰            | Pythonã€Javaã€Cï¼ˆé»˜è®¤ä¸¥æ ¼ï¼‰   |

------

#### **4. ç¼–ç¨‹è¯­è¨€ä¸­çš„æ±‚å€¼ç­–ç•¥**

ä¸åŒçš„ç¼–ç¨‹è¯­è¨€é‡‡ç”¨ä¸åŒçš„æ±‚å€¼ç­–ç•¥ï¼š

#### **4.1 é‡‡ç”¨æƒ°æ€§æ±‚å€¼çš„è¯­è¨€**

- **Haskell**ï¼šé»˜è®¤æƒ°æ€§æ±‚å€¼ï¼Œå…è®¸æ„é€ æ— é™æ•°æ®ç»“æ„ã€‚
- **Scala**ï¼šæ”¯æŒ `lazy val` å…³é”®å­—ï¼Œå…è®¸æŒ‰éœ€æ±‚å€¼ã€‚
- **OCaml**ï¼šéƒ¨åˆ† API æ”¯æŒæƒ°æ€§æ±‚å€¼ï¼ˆå¦‚ `Lazy.t`ï¼‰ã€‚

##### **Haskell ç¤ºä¾‹**

```haskell
ones = 1 : ones  -- æ— é™åˆ—è¡¨
take 5 ones  -- [1,1,1,1,1]
```

ç”±äº Haskell é‡‡ç”¨æƒ°æ€§æ±‚å€¼ï¼Œå› æ­¤ `ones` ä¸ä¼šç«‹å³å±•å¼€ï¼Œè€Œæ˜¯**åœ¨éœ€è¦æ—¶æ‰è®¡ç®—**ã€‚

#### **4.2 é‡‡ç”¨ä¸¥æ ¼æ±‚å€¼çš„è¯­è¨€**

- **Pythonã€Javaã€C++**ï¼šé»˜è®¤ä¸¥æ ¼æ±‚å€¼ï¼Œæ‰€æœ‰å‚æ•°åœ¨ä¼ é€’å‰éƒ½ä¼šè¢«è®¡ç®—ã€‚
- **OCamlï¼ˆé»˜è®¤ä¸¥æ ¼æ±‚å€¼ï¼‰**ï¼šä½†å¯ä»¥ä½¿ç”¨ `Lazy.t` è¿›è¡Œæƒ°æ€§æ±‚å€¼ã€‚

##### **Python ä¸¥æ ¼æ±‚å€¼ç¤ºä¾‹**

```python
def ones():
    while True:
        yield 1

print(list(ones())[:5])  # éœ€è¦æ‰‹åŠ¨æ§åˆ¶ï¼Œé¿å…æ— é™å¾ªç¯
```

åœ¨ Python ä¸­ï¼Œæ— æ³•ç›´æ¥åˆ›å»ºæ— é™åˆ—è¡¨ï¼Œè€Œæ˜¯éœ€è¦æ‰‹åŠ¨å®ç°ç”Ÿæˆå™¨ï¼ˆ`yield` å…³é”®å­—ï¼‰ã€‚

------

#### **5. æƒ°æ€§æ±‚å€¼ä¸ä¸¥æ ¼æ±‚å€¼çš„é€‰æ‹©**

âœ… **ä½¿ç”¨æƒ°æ€§æ±‚å€¼çš„åœºæ™¯**

- éœ€è¦ä¼˜åŒ–è®¡ç®—æ€§èƒ½ï¼Œé¿å…ä¸å¿…è¦çš„è®¡ç®—ã€‚
- éœ€è¦æ”¯æŒæ— é™æ•°æ®ç»“æ„ï¼Œå¦‚ Haskell ä¸­çš„æ— é™åˆ—è¡¨ã€‚
- éœ€è¦å»¶è¿Ÿè®¡ç®—ï¼Œç›´åˆ°çœŸæ­£éœ€è¦ç»“æœã€‚

âœ… **ä½¿ç”¨ä¸¥æ ¼æ±‚å€¼çš„åœºæ™¯**

- è®¡ç®—é¡ºåºå¾ˆé‡è¦ï¼Œéœ€è¦ç¡®ä¿æ‰€æœ‰å‚æ•°åœ¨æ‰§è¡Œå‰å·²è®¡ç®—å®Œæˆã€‚
- éœ€è¦åœ¨**ä½å†…å­˜å ç”¨çš„ç¯å¢ƒ**ä¸‹è¿è¡Œï¼Œé¿å…å­˜å‚¨å¤§é‡æœªè®¡ç®—çš„è¡¨è¾¾å¼ï¼ˆthunksï¼‰ã€‚
- é€‚ç”¨äºå¤§å¤šæ•°ç°ä»£ç¼–ç¨‹è¯­è¨€çš„é»˜è®¤æ±‚å€¼æ¨¡å¼ã€‚

------

#### **å°ç»“**

- **æƒ°æ€§æ±‚å€¼**ï¼ˆLazy Evaluationï¼‰åªåœ¨éœ€è¦æ—¶æ‰è®¡ç®—ï¼Œå‡å°‘ä¸å¿…è¦çš„è®¡ç®—ï¼Œæ”¯æŒæ— é™æ•°æ®ç»“æ„ï¼Œä½†å¯èƒ½å¢åŠ å†…å­˜ä½¿ç”¨ã€‚
- **ä¸¥æ ¼æ±‚å€¼**ï¼ˆStrict Evaluationï¼‰ç«‹å³è®¡ç®—æ‰€æœ‰è¡¨è¾¾å¼ï¼Œæ‰§è¡Œé¡ºåºå¯é¢„æµ‹ï¼Œå‡å°‘å†…å­˜å ç”¨ï¼Œä½†å¯èƒ½å¯¼è‡´å†—ä½™è®¡ç®—ã€‚
- **Haskell é»˜è®¤ä½¿ç”¨æƒ°æ€§æ±‚å€¼**ï¼Œè€Œ Pythonã€Javaã€C++ ç­‰è¯­è¨€é‡‡ç”¨ä¸¥æ ¼æ±‚å€¼ã€‚
- **ä¸åŒçš„æ±‚å€¼ç­–ç•¥é€‚ç”¨äºä¸åŒçš„åº”ç”¨åœºæ™¯**ï¼Œæƒ°æ€§æ±‚å€¼é€‚åˆä¼˜åŒ–è®¡ç®—å’Œæ„é€ æ— é™æ•°æ®ï¼Œè€Œä¸¥æ ¼æ±‚å€¼æ›´é€‚ç”¨äºä¼ ç»Ÿç¼–ç¨‹èŒƒå¼ã€‚

åœ¨ä¸‹ä¸€èŠ‚ï¼Œæˆ‘ä»¬å°†é€šè¿‡ç¤ºä¾‹æ¯”è¾ƒ **åŒä¸€ä¸ªè¡¨è¾¾å¼åœ¨ä¸åŒæ±‚å€¼ç­–ç•¥ä¸‹çš„æ±‚å€¼è¿‡ç¨‹**ï¼Œå¹¶åˆ†æå…¶å½±å“ï¼ğŸš€

### **5.3.3 å°èŠ‚ç¤ºä¾‹ï¼šåŒä¸€ä¸ªè¡¨è¾¾å¼åœ¨ä¸åŒç­–ç•¥ä¸‹çš„æ±‚å€¼è¿‡ç¨‹**

åœ¨å‰é¢ä¸¤èŠ‚ä¸­ï¼Œæˆ‘ä»¬è¯¦ç»†è®¨è®ºäº† **æ­£å¸¸åºï¼ˆNormal Orderï¼‰** å’Œ **åº”ç”¨åºï¼ˆApplicative Orderï¼‰** è¿™ä¸¤ç§æ±‚å€¼ç­–ç•¥ï¼Œä»¥åŠ **æƒ°æ€§æ±‚å€¼ï¼ˆLazy Evaluationï¼‰** å’Œ **ä¸¥æ ¼æ±‚å€¼ï¼ˆStrict Evaluationï¼‰** çš„å½±å“ã€‚æœ¬èŠ‚é€šè¿‡ **å®é™…ç¤ºä¾‹** å±•ç¤º**ç›¸åŒçš„ Lambda è¡¨è¾¾å¼åœ¨ä¸åŒæ±‚å€¼ç­–ç•¥ä¸‹çš„æ‰§è¡Œè¿‡ç¨‹**ï¼Œåˆ†æå®ƒä»¬çš„ä¸åŒå½±å“ã€‚

ä¸ºäº†ç¡®ä¿ç¤ºä¾‹å…·æœ‰å®é™…ä»·å€¼ï¼Œæˆ‘ä»¬é€‰å–äº†ä¸€äº› **å®é™…é¡¹ç›®ä¸­çš„è¡¨è¾¾å¼** æˆ– **å¸¸è§çš„è®¡ç®—æ¨¡å¼**ï¼Œè€Œéç®€å•çš„æ•°å­¦å‡½æ•°ã€‚

------

#### **1. ç¤ºä¾‹ 1ï¼šé«˜é˜¶å‡½æ•°è°ƒç”¨ä¸å‚æ•°æ±‚å€¼é¡ºåº**

åœ¨ç°ä»£ç¼–ç¨‹è¯­è¨€ï¼ˆå¦‚ Pythonã€Haskellã€Scalaï¼‰ä¸­ï¼Œé«˜é˜¶å‡½æ•°æ˜¯å¸¸è§çš„ä»£ç æ¨¡å¼ã€‚ä¾‹å¦‚ï¼š

```haskell
f g x = g x
```

åœ¨ Lambda Calculus ä¸­ï¼Œå®ƒå¯ä»¥è¡¨ç¤ºä¸ºï¼š

```
F = Î»g. Î»x. g x
```

å½“ `g` è¢«ä¼ é€’ä¸€ä¸ªå¯èƒ½å¯¼è‡´æ— é™å¾ªç¯çš„è¡¨è¾¾å¼æ—¶ï¼Œä¸åŒçš„æ±‚å€¼ç­–ç•¥ä¼šå¯¼è‡´ä¸åŒçš„è¡Œä¸ºã€‚

#### **Lambda è¡¨è¾¾å¼**

```
(Î»g. Î»x. g x) (Î»y. y y) 5
```

å³ï¼š

```
F (Î»y. y y) 5
```

å…¶ä¸­ï¼š

- `Î»y. y y` æ˜¯ä¸€ä¸ª**æ— é™é€’å½’**è¡¨è¾¾å¼ï¼ˆå³ `Y = Î»y. y y`ï¼‰ã€‚
- `F = Î»g. Î»x. g x` æ˜¯ä¸€ä¸ªç®€å•çš„é«˜é˜¶å‡½æ•°ï¼Œå®ƒæ¥å— `g` å¹¶åº”ç”¨åˆ° `x` ä¸Šã€‚

#### **åº”ç”¨åºï¼ˆStrict Evaluationï¼‰**

æŒ‰ç…§åº”ç”¨åºï¼Œå‚æ•° `Î»y. y y` **å…ˆè¢«æ±‚å€¼**ï¼Œç„¶åå†åº”ç”¨ï¼š

```
(Î»y. y y) â†’ (Î»y. y y)
```

ç”±äº `(Î»y. y y)` **æ°¸è¿œä¸ä¼šå½’çº¦åˆ°ç»ˆç»“çŠ¶æ€**ï¼Œå› æ­¤è®¡ç®—å°†**è¿›å…¥æ— é™å¾ªç¯**ï¼Œæ— æ³•è¿”å› `5`ã€‚

#### **æ­£å¸¸åºï¼ˆLazy Evaluationï¼‰**

æŒ‰ç…§æ­£å¸¸åºï¼Œæˆ‘ä»¬**å…ˆå±•å¼€æœ€å¤–å±‚çš„ Lambda è¡¨è¾¾å¼**ï¼š

```
F (Î»y. y y) 5 â†’ (Î»x. (Î»y. y y) x) 5
```

ç„¶ååº”ç”¨ `x = 5`ï¼š

```
(Î»y. y y) 5
```

æ­¤æ—¶ `g x` éœ€è¦è¢«è®¡ç®—ï¼Œè€Œ `g = Î»y. y y`ï¼Œå› æ­¤ä»ç„¶è¿›å…¥æ— é™é€’å½’ã€‚

ğŸ’¡ **ç»“è®º**

- è¯¥è¡¨è¾¾å¼åœ¨**åº”ç”¨åºå’Œæ­£å¸¸åºä¸‹éƒ½ä¼šå¯¼è‡´æ— é™å¾ªç¯**ï¼Œä½†æ­£å¸¸åºä¼š**å…ˆå±•å¼€ Lambda è¡¨è¾¾å¼**ï¼Œåº”ç”¨åºä¼š**ç«‹å³è®¡ç®—å‚æ•°**ã€‚
- ä½†å¦‚æœ `g` **ä»ä¸è¢«ä½¿ç”¨**ï¼Œé‚£ä¹ˆæ­£å¸¸åºå¯ä»¥é¿å…ä¸å¿…è¦çš„è®¡ç®—ã€‚

------

#### **2. ç¤ºä¾‹ 2ï¼šçŸ­è·¯æ±‚å€¼**

çŸ­è·¯æ±‚å€¼ï¼ˆShort-Circuit Evaluationï¼‰åœ¨è®¸å¤šç¼–ç¨‹è¯­è¨€ä¸­è¢«å¹¿æ³›åº”ç”¨ï¼Œä¾‹å¦‚ï¼š

```python
x = False and (9999 // 0)  # ä¸ä¼šæŠ¥é”™
```

è¿™åœ¨ Lambda Calculus ä¸­å¯ä»¥ç”¨ `if-then-else` ç»“æ„æ¨¡æ‹Ÿï¼š

```
IF = Î»b. Î»x. Î»y. b x y
TRUE  = Î»x. Î»y. x
FALSE = Î»x. Î»y. y
```

è¡¨è¾¾å¼ï¼š

```
IF FALSE (9999 // 0) 5
```

#### **åº”ç”¨åºï¼ˆStrict Evaluationï¼‰**

æŒ‰ç…§åº”ç”¨åºï¼š

1. ```
   FALSE
   ```

    å…ˆè®¡ç®—ï¼š

   ```
   Î»x. Î»y. y
   ```

2. è®¡ç®— `9999 // 0` **ä¼šå¼•å‘é”™è¯¯**ï¼Œå³ä½¿ `FALSE` çš„ç»“æœä»ä¸ä½¿ç”¨ã€‚

#### **æ­£å¸¸åºï¼ˆLazy Evaluationï¼‰**

æŒ‰ç…§æ­£å¸¸åºï¼š

1. `IF FALSE (9999 // 0) 5 â†’ FALSE 5`
2. `FALSE = Î»x. Î»y. y`ï¼Œå› æ­¤ç»“æœä¸º `5`ï¼Œä¸ä¼šè®¡ç®— `9999 // 0`ï¼Œä¸ä¼šå¼•å‘é”™è¯¯ã€‚

ğŸ’¡ **ç»“è®º**

- **æ­£å¸¸åºå¯ä»¥é¿å…è®¡ç®—ä¸å¿…è¦çš„è¡¨è¾¾å¼**ï¼ˆä¾‹å¦‚ `9999 // 0`ï¼‰ã€‚
- **åº”ç”¨åºä¼šå¼ºåˆ¶è®¡ç®—æ‰€æœ‰å‚æ•°**ï¼Œå¯èƒ½å¯¼è‡´ç¨‹åºå´©æºƒã€‚

------

#### **3. ç¤ºä¾‹ 3ï¼šæµå¼è®¡ç®—ï¼ˆStreamingï¼‰**

åœ¨ç°ä»£æ•°æ®å¤„ç†ï¼ˆå¦‚**æµå¼è®¡ç®—**ã€**å¤§æ•°æ®å¤„ç†**ï¼‰ä¸­ï¼Œ**æ‡’æƒ°æ±‚å€¼** å¸¸ç”¨äºå¤„ç†æ— é™æˆ–å¤§è§„æ¨¡æ•°æ®ã€‚ä¾‹å¦‚ï¼ŒHaskell ä½¿ç”¨ `lazy lists` æ¥è¡¨ç¤ºæ— é™æµï¼š

```haskell
naturals = 0 : map (+1) naturals
take 10 naturals  -- ä»…è®¡ç®—å‰10ä¸ªæ•°
```

Lambda Calculus ç‰ˆæœ¬ï¼š

```
NATURALS = Î»f. f 0 (f 1 (f 2 ...))
```

#### **åº”ç”¨åºï¼ˆStrict Evaluationï¼‰**

ä¸¥æ ¼æ±‚å€¼ä¼šç«‹å³å±•å¼€æ•´ä¸ªæ— é™åˆ—è¡¨ï¼š

```
NATURALS â†’ 0 : 1 : 2 : 3 : 4 : ... (æ— é™å±•å¼€)
```

è¿™ä¼š**å ç”¨æ— é™å†…å­˜**ï¼Œæ— æ³•æ‰§è¡Œã€‚

#### **æ­£å¸¸åºï¼ˆLazy Evaluationï¼‰**

æ­£å¸¸åºåªåœ¨**çœŸæ­£éœ€è¦æ•°æ®æ—¶æ‰è®¡ç®—**ï¼š

```
take 10 NATURALS â†’ 0 : 1 : 2 : 3 : ... ç›´åˆ°ç¬¬10ä¸ªå…ƒç´ 
```

è®¡ç®—ä»…åœ¨è®¿é—®å…ƒç´ æ—¶å‘ç”Ÿï¼Œé¿å…å†…å­˜æº¢å‡ºã€‚

ğŸ’¡ **ç»“è®º**

- **æƒ°æ€§æ±‚å€¼é€‚åˆæµå¼è®¡ç®—ï¼Œåº”ç”¨åºä¼šå¯¼è‡´æ— é™å±•å¼€**ã€‚
- **åœ¨å¤§è§„æ¨¡æ•°æ®å¤„ç†ä¸­ï¼Œæƒ°æ€§æ±‚å€¼å¯ä»¥å‡å°‘è®¡ç®—å’Œå­˜å‚¨å¼€é”€**ã€‚

------

#### **4. ç¤ºä¾‹ 4ï¼šé€’å½’å‡½æ•°æ±‚å€¼**

è€ƒè™‘ä¸€ä¸ªé€’å½’å®šä¹‰çš„ **æ–æ³¢é‚£å¥‘æ•°åˆ—**ï¼š

```
FIB = Î»n. IF (n â‰¤ 1) 1 (FIB (n - 1) + FIB (n - 2))
```

#### **åº”ç”¨åºï¼ˆStrict Evaluationï¼‰**

- è®¡ç®— `FIB(5)`ï¼š

```
FIB(5) = FIB(4) + FIB(3)
       = (FIB(3) + FIB(2)) + (FIB(2) + FIB(1))
       ...
```

- **é—®é¢˜**ï¼šç”±äºä¸¥æ ¼æ±‚å€¼ **éœ€è¦å…ˆæ±‚ `FIB(n-1)` å’Œ `FIB(n-2)`**ï¼Œå¯¼è‡´**å¤§é‡å†—ä½™è®¡ç®—**ã€‚

#### **æ­£å¸¸åºï¼ˆLazy Evaluationï¼‰**

- è®¡ç®— `FIB(5)`ï¼š

```
FIB(5) â†’ IF FALSE 1 (FIB(4) + FIB(3))
```

- **IF çš„åˆ†æ”¯ä¸ä¼šè¢«æ±‚å€¼ï¼Œå‡å°‘è®¡ç®—æ¬¡æ•°**ã€‚
- **é¿å…é‡å¤è®¡ç®— `FIB(n-1)`ï¼Œæå‡æ•ˆç‡**ã€‚

ğŸ’¡ **ç»“è®º**

- **æ­£å¸¸åºå‡å°‘é‡å¤è®¡ç®—ï¼Œæé«˜æ•ˆç‡**ã€‚
- **åº”ç”¨åºå¯èƒ½å¯¼è‡´æŒ‡æ•°çº§è®¡ç®—å¼€é”€**ã€‚

------

#### **å°ç»“**

- **é«˜é˜¶å‡½æ•°çš„å‚æ•°æ±‚å€¼**ï¼šåº”ç”¨åºä¼šç«‹å³è®¡ç®—ï¼Œå¯èƒ½å¯¼è‡´æ— é™é€’å½’ï¼Œæ­£å¸¸åºå¯ä»¥æ¨è¿Ÿè®¡ç®—ã€‚
- **çŸ­è·¯æ±‚å€¼**ï¼šåº”ç”¨åºæ— æ³•é¿å…é”™è¯¯è®¡ç®—ï¼Œæ­£å¸¸åºå¯ä»¥ã€‚
- **æµå¼è®¡ç®—**ï¼šæ­£å¸¸åºå¯ä»¥æ”¯æŒæ— é™æ•°æ®ï¼Œåº”ç”¨åºä¼šå¯¼è‡´æ— é™å±•å¼€ã€‚
- **é€’å½’ä¼˜åŒ–**ï¼šæ­£å¸¸åºå‡å°‘ä¸å¿…è¦çš„è®¡ç®—ï¼Œæå‡æ€§èƒ½ã€‚

**æ€»ç»“**

| **ç¤ºä¾‹**         | **åº”ç”¨åºï¼ˆStrict Evaluationï¼‰** | **æ­£å¸¸åºï¼ˆLazy Evaluationï¼‰** |
| ---------------- | ------------------------------- | ----------------------------- |
| **é«˜é˜¶å‡½æ•°é€’å½’** | å¯èƒ½å¯¼è‡´æ— é™å¾ªç¯                | å…ˆå±•å¼€ï¼Œå¯èƒ½é¿å…æ— ç©·é€’å½’      |
| **çŸ­è·¯æ±‚å€¼**     | è®¡ç®—æ‰€æœ‰å‚æ•°ï¼Œå¯èƒ½å´©æºƒ          | ä»…è®¡ç®—å¿…è¦å‚æ•°ï¼Œé¿å…é”™è¯¯      |
| **æµå¼è®¡ç®—**     | æ— é™å±•å¼€ï¼Œå†…å­˜æº¢å‡º              | æŒ‰éœ€è®¡ç®—ï¼Œé€‚åˆæµå¤„ç†          |
| **é€’å½’ä¼˜åŒ–**     | å¯èƒ½äº§ç”Ÿå†—ä½™è®¡ç®—                | è®¡ç®—æ›´é«˜æ•ˆ                    |

åœ¨ä¸‹ä¸€èŠ‚ï¼Œæˆ‘ä»¬å°†æ¢è®¨ **Lambda Calculus è§£é‡Šå™¨çš„å…·ä½“å®ç°**ï¼ŒåŒ…æ‹¬**å¦‚ä½•æ„é€ åŸºç¡€æ•°æ®ç»“æ„å¹¶å¤„ç†å˜é‡æ›¿æ¢**ï¼ğŸš€

### **5.4.1 åŸºç¡€æ•°æ®ç»“æ„å®šä¹‰ï¼ˆCè¯­è¨€ä¸­çš„ç»“æ„ä½“æˆ–Pythonç±»ï¼‰**

åœ¨æ„å»º Lambda Calculus è§£é‡Šå™¨æ—¶ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦å®šä¹‰é€‚å½“çš„æ•°æ®ç»“æ„æ¥è¡¨ç¤º Lambda è¡¨è¾¾å¼çš„æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰ã€‚è¿™ä¸€éƒ¨åˆ†çš„æ•°æ®ç»“æ„å°†ä½œä¸ºè§£æå™¨ï¼ˆParserï¼‰å’Œæ±‚å€¼å™¨ï¼ˆEvaluatorï¼‰å…±åŒä½¿ç”¨çš„æ ¸å¿ƒç»„ä»¶ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦é€‰æ‹©åˆé€‚çš„ç¼–ç¨‹è¯­è¨€å¹¶å»ºç«‹ä¸€ä¸ªæ¸…æ™°ã€æ˜“æ‰©å±•çš„ç»“æ„ï¼Œä»¥ä¾¿åç»­çš„æ“ä½œã€‚

æœ¬èŠ‚å†…å®¹ï¼š

1. **Lambda Calculus AST ç»“æ„**
2. **C è¯­è¨€ä¸­çš„æ•°æ®ç»“æ„å®ç°**
3. **Python è¯­è¨€ä¸­çš„æ•°æ®ç»“æ„å®ç°**
4. **æ•°æ®ç»“æ„çš„æ‰©å±•æ€§**

------

#### **1. Lambda Calculus AST ç»“æ„**

Lambda Calculus ç”±ä¸‰ç§åŸºæœ¬ç»“æ„ç»„æˆï¼š

- **å˜é‡ï¼ˆVariableï¼‰**ï¼šç”¨äºå¼•ç”¨ç»‘å®šçš„å€¼ï¼Œä¾‹å¦‚ `x`ã€‚
- **Lambda æŠ½è±¡ï¼ˆLambda Abstractionï¼‰**ï¼šç”¨äºå®šä¹‰åŒ¿åå‡½æ•°ï¼Œä¾‹å¦‚ `Î»x. x + 1`ã€‚
- **å‡½æ•°åº”ç”¨ï¼ˆApplicationï¼‰**ï¼šç”¨äºè°ƒç”¨ Lambda è¡¨è¾¾å¼ï¼Œä¾‹å¦‚ `(Î»x. x + 1) 5`ã€‚

#### **AST ç»“æ„**

```
Expression (é€šç”¨çˆ¶ç±»)
â”œâ”€â”€ Variable (å˜é‡)
â”œâ”€â”€ Lambda (Lambda æŠ½è±¡)
â””â”€â”€ Application (å‡½æ•°åº”ç”¨)
```

ä¸ºäº†æ”¯æŒè§£æã€æ±‚å€¼å’Œå˜é‡æ›¿æ¢ï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰æ•°æ®ç»“æ„æ¥è¡¨ç¤ºè¿™äº›åŸºæœ¬æ„é€ ã€‚

------

#### **2. C è¯­è¨€ä¸­çš„æ•°æ®ç»“æ„å®ç°**

ç”±äº C è¯­è¨€ä¸æ”¯æŒé¢å‘å¯¹è±¡ç¼–ç¨‹ï¼Œæˆ‘ä»¬ä½¿ç”¨ `struct` æ¥å®šä¹‰ Lambda Calculus çš„ AST ç»“æ„ï¼ŒåŒæ—¶ä½¿ç”¨ `enum` æ¥åŒºåˆ†ä¸åŒçš„ AST èŠ‚ç‚¹ç±»å‹ã€‚

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// å®šä¹‰ AST èŠ‚ç‚¹ç±»å‹
typedef enum { VAR, LAMBDA, APP } NodeType;

// AST ç»“æ„ä½“å®šä¹‰
typedef struct Expr {
    NodeType type;
    union {
        struct { char *name; } var;  // å˜é‡
        struct { char *param; struct Expr *body; } lambda; // Lambda æŠ½è±¡
        struct { struct Expr *func; struct Expr *arg; } app; // å‡½æ•°åº”ç”¨
    };
} Expr;

// åˆ›å»ºå˜é‡èŠ‚ç‚¹
Expr *new_var(char *name) {
    Expr *expr = malloc(sizeof(Expr));
    expr->type = VAR;
    expr->var.name = strdup(name);
    return expr;
}

// åˆ›å»º Lambda æŠ½è±¡èŠ‚ç‚¹
Expr *new_lambda(char *param, Expr *body) {
    Expr *expr = malloc(sizeof(Expr));
    expr->type = LAMBDA;
    expr->lambda.param = strdup(param);
    expr->lambda.body = body;
    return expr;
}

// åˆ›å»ºåº”ç”¨èŠ‚ç‚¹
Expr *new_app(Expr *func, Expr *arg) {
    Expr *expr = malloc(sizeof(Expr));
    expr->type = APP;
    expr->app.func = func;
    expr->app.arg = arg;
    return expr;
}

// æ‰“å° ASTï¼ˆç”¨äºè°ƒè¯•ï¼‰
void print_expr(Expr *expr) {
    if (!expr) return;
    switch (expr->type) {
        case VAR:
            printf("%s", expr->var.name);
            break;
        case LAMBDA:
            printf("(Î»%s. ", expr->lambda.param);
            print_expr(expr->lambda.body);
            printf(")");
            break;
        case APP:
            printf("(");
            print_expr(expr->app.func);
            printf(" ");
            print_expr(expr->app.arg);
            printf(")");
            break;
    }
}

// é‡Šæ”¾ AST ç»“æ„
void free_expr(Expr *expr) {
    if (!expr) return;
    if (expr->type == VAR) {
        free(expr->var.name);
    } else if (expr->type == LAMBDA) {
        free(expr->lambda.param);
        free_expr(expr->lambda.body);
    } else if (expr->type == APP) {
        free_expr(expr->app.func);
        free_expr(expr->app.arg);
    }
    free(expr);
}

// ç¤ºä¾‹
int main() {
    Expr *expr = new_app(new_lambda("x", new_var("x")), new_var("y"));
    print_expr(expr);  // è¾“å‡º: (Î»x. x y)
    free_expr(expr);
    return 0;
}
```

#### **C è¯­è¨€å®ç°çš„ç‰¹ç‚¹**

- **æ‰‹åŠ¨ç®¡ç†å†…å­˜**ï¼šéœ€è¦ä½¿ç”¨ `malloc/free` è¿›è¡ŒåŠ¨æ€åˆ†é…å’Œé‡Šæ”¾å†…å­˜ã€‚
- **ç»“æ„æ¸…æ™°**ï¼šä½¿ç”¨ `union` ç»“åˆ `enum`ï¼Œæé«˜å†…å­˜åˆ©ç”¨ç‡ã€‚
- **æ“ä½œçµæ´»**ï¼šé€‚åˆåµŒå…¥å¼å’Œåº•å±‚è®¡ç®—æœºç³»ç»Ÿçš„å®ç°ã€‚

------

#### **3. Python è¯­è¨€ä¸­çš„æ•°æ®ç»“æ„å®ç°**

ç›¸æ¯”äº C è¯­è¨€ï¼ŒPython æä¾›äº†æ›´é«˜çº§çš„æŠ½è±¡ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨ **ç±»ï¼ˆClassï¼‰** è¿›è¡Œå°è£…ï¼Œä½¿ä»£ç æ›´å…·å¯è¯»æ€§å’Œå¯æ‰©å±•æ€§ã€‚

```python
class Expr:
    """Lambda Calculus AST åŸºç±»"""
    pass

class Var(Expr):
    """å˜é‡"""
    def __init__(self, name: str):
        self.name = name

    def __repr__(self):
        return self.name

class Lambda(Expr):
    """Lambda æŠ½è±¡"""
    def __init__(self, param: str, body: Expr):
        self.param = param
        self.body = body

    def __repr__(self):
        return f"(Î»{self.param}. {self.body})"

class App(Expr):
    """å‡½æ•°åº”ç”¨"""
    def __init__(self, func: Expr, arg: Expr):
        self.func = func
        self.arg = arg

    def __repr__(self):
        return f"({self.func} {self.arg})"

# æµ‹è¯•ç¤ºä¾‹
expr = App(Lambda("x", Var("x")), Var("y"))
print(expr)  # è¾“å‡º: (Î»x. x y)
```

#### **Python å®ç°çš„ç‰¹ç‚¹**

- **å†…å­˜è‡ªåŠ¨ç®¡ç†**ï¼šä¸éœ€è¦æ‰‹åŠ¨ `malloc/free`ï¼Œæé«˜ä»£ç å®‰å…¨æ€§ã€‚
- **é¢å‘å¯¹è±¡**ï¼šå¯ä»¥è½»æ¾æ‰©å±• AST ç»“æ„ï¼Œä¾‹å¦‚åŠ å…¥ç±»å‹ç³»ç»Ÿã€‚
- **æ›´æ˜“è¯»**ï¼šPython ä»£ç æ›´ç®€æ´ï¼Œé€‚ç”¨äºé«˜å±‚æ¬¡çš„å®ç°ã€‚

------

#### **4. æ•°æ®ç»“æ„çš„æ‰©å±•æ€§**

æ— è®ºä½¿ç”¨ **C è¿˜æ˜¯ Python**ï¼ŒLambda Calculus çš„æ•°æ®ç»“æ„éƒ½å¯ä»¥æ‰©å±•ï¼Œä»¥æ”¯æŒæ›´å¤šç‰¹æ€§ï¼Œä¾‹å¦‚ï¼š

- **ç±»å‹æ³¨é‡Šï¼ˆTyped Lambda Calculusï¼‰**ï¼šæ‰©å±• `Lambda` ç»“æ„ï¼Œä½¿å…¶æ”¯æŒç±»å‹ä¿¡æ¯ã€‚
- **æ¨¡å¼åŒ¹é…**ï¼šç”¨äºæ›´å¤æ‚çš„æ±‚å€¼æœºåˆ¶ï¼Œå¦‚ `case` è¯­å¥ã€‚
- **ä¼˜åŒ–**ï¼šå¦‚ `å…±äº«ç»“æ„`ï¼Œå‡å°‘ AST èŠ‚ç‚¹çš„å†—ä½™å­˜å‚¨ï¼Œæé«˜æ±‚å€¼æ•ˆç‡ã€‚

------

#### **å°ç»“**

- **C è¯­è¨€å®ç°**ï¼šä½¿ç”¨ `struct` å’Œ `union` ç»„ç»‡æ•°æ®ï¼Œæ‰‹åŠ¨ç®¡ç†å†…å­˜ï¼Œé€‚åˆä½çº§å®ç°ã€‚
- **Python å®ç°**ï¼šä½¿ç”¨é¢å‘å¯¹è±¡çš„æ–¹å¼å°è£… ASTï¼Œæ›´å®¹æ˜“æ‰©å±•å’Œç»´æŠ¤ã€‚
- **AST ç»“æ„æ¸…æ™°**ï¼šåˆ†ä¸º `Var`ã€`Lambda` å’Œ `App`ï¼Œé€‚ç”¨äºè§£æå’Œæ±‚å€¼ã€‚
- **å¯ä»¥æ‰©å±•**ï¼šæœªæ¥å¯æ”¯æŒ **ç±»å‹ç³»ç»Ÿã€ä¼˜åŒ–ã€æ¨¡å¼åŒ¹é…** ç­‰åŠŸèƒ½ã€‚

åœ¨ä¸‹ä¸€èŠ‚ï¼Œæˆ‘ä»¬å°†åŸºäº AST ç»“æ„ **å®ç° Lambda è®¡ç®—çš„é€’å½’æ±‚å€¼ä¸å˜é‡æ›¿æ¢**ï¼ğŸš€

### **5.4.2 é€’å½’æ±‚å€¼ä¸å˜é‡æ›¿æ¢é€»è¾‘**

åœ¨ä¸Šä¸€èŠ‚ï¼Œæˆ‘ä»¬å®šä¹‰äº† Lambda Calculus çš„æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰ç»“æ„ï¼ŒåŒ…æ‹¬å˜é‡ï¼ˆ`Var`ï¼‰ã€Lambda æŠ½è±¡ï¼ˆ`Lambda`ï¼‰å’Œå‡½æ•°åº”ç”¨ï¼ˆ`App`ï¼‰ã€‚æœ¬èŠ‚çš„é‡ç‚¹æ˜¯ **å¦‚ä½•åŸºäº AST ç»“æ„å®ç° Lambda Calculus çš„æ±‚å€¼å™¨ï¼ˆEvaluatorï¼‰**ï¼Œå¹¶æ¢è®¨ **Î²-å½’çº¦ï¼ˆBeta Reductionï¼‰** å’Œ **å˜é‡æ›¿æ¢ï¼ˆSubstitutionï¼‰** è¿™ä¸¤ä¸ªæ ¸å¿ƒæ“ä½œã€‚

æœ¬èŠ‚å†…å®¹ï¼š

1. **Î²-å½’çº¦ï¼ˆBeta Reductionï¼‰** è§„åˆ™
2. **é€’å½’æ±‚å€¼ç®—æ³•**
3. **å˜é‡æ›¿æ¢ï¼ˆSubstitutionï¼‰** æ–¹æ³•
4. **å®Œæ•´çš„æ±‚å€¼å™¨å®ç°**

------

#### **1. Î²-å½’çº¦ï¼ˆBeta Reductionï¼‰è§„åˆ™**

Î²-å½’çº¦æ˜¯ Lambda Calculus ä¸­æœ€é‡è¦çš„è®¡ç®—è§„åˆ™ï¼Œå®ƒçš„åŸºæœ¬å½¢å¼æ˜¯ï¼š

```
(Î»x. E1) E2 â†’ E1[x := E2]
```

æ„æ€æ˜¯ï¼šå½“ä¸€ä¸ª Lambda è¡¨è¾¾å¼ `Î»x. E1` è¢«åº”ç”¨åˆ°ä¸€ä¸ªå‚æ•° `E2` æ—¶ï¼Œæˆ‘ä»¬ç”¨ `E2` **æ›¿æ¢** `E1` ä¸­æ‰€æœ‰å‡ºç°çš„ `x`ï¼Œç„¶åç»§ç»­æ±‚å€¼ã€‚

#### **Î²-å½’çº¦ç¤ºä¾‹**

| Lambda è¡¨è¾¾å¼     | Î²-å½’çº¦æ­¥éª¤ | å½’çº¦ç»“æœ    |
| ----------------- | ---------- | ----------- |
| `(Î»x. x) 5`       | `x := 5`   | `5`         |
| `(Î»x. x + 1) 4`   | `x := 4`   | `4 + 1 â†’ 5` |
| `(Î»x. Î»y. x y) z` | `x := z`   | `Î»y. z y`   |

åœ¨å®é™…æ±‚å€¼å™¨ä¸­ï¼Œæˆ‘ä»¬éœ€è¦é€’å½’åœ°åº”ç”¨ Î²-å½’çº¦ï¼Œç›´åˆ°è¡¨è¾¾å¼è¾¾åˆ° **ä¸å¯å†ç®€åŒ–çš„å½¢å¼**ï¼ˆå³å½’çº¦åˆ° **æ­£å¸¸å½¢å¼**ï¼‰ã€‚

------

#### **2. é€’å½’æ±‚å€¼ç®—æ³•**

Lambda è®¡ç®—çš„æ ¸å¿ƒåœ¨äº **é€’å½’æ±‚å€¼ï¼ˆRecursive Evaluationï¼‰**ï¼Œä¸»è¦å¤„ç†ï¼š

1. **å˜é‡**ï¼ˆ`Var`ï¼‰ï¼šç›´æ¥è¿”å›ã€‚
2. **Lambda æŠ½è±¡**ï¼ˆ`Lambda`ï¼‰ï¼šæœ¬èº«å°±æ˜¯ä¸€ä¸ªå€¼ï¼Œä¸è¿›è¡Œæ±‚å€¼ã€‚
3. å‡½æ•°åº”ç”¨ï¼ˆAppï¼‰ï¼š
   - å…ˆå¯¹ **å‡½æ•°éƒ¨åˆ†** è¿›è¡Œæ±‚å€¼ã€‚
   - å¦‚æœå‡½æ•°éƒ¨åˆ†æ˜¯ `Lambda`ï¼Œåˆ™åº”ç”¨ Î²-å½’çº¦ã€‚
   - é€’å½’ç»§ç»­æ±‚å€¼ï¼Œç›´åˆ°è¾¾åˆ°æœ€ç»ˆç»“æœã€‚

#### **é€’å½’æ±‚å€¼é€»è¾‘**

```python
def evaluate(expr):
    if isinstance(expr, Var):
        return expr  # å˜é‡ç›´æ¥è¿”å›

    elif isinstance(expr, Lambda):
        return expr  # Lambda æŠ½è±¡ä¹Ÿæ˜¯æœ€ç»ˆå€¼

    elif isinstance(expr, App):
        # é€’å½’æ±‚å€¼å·¦ä¾§ï¼ˆå‡½æ•°éƒ¨åˆ†ï¼‰
        func = evaluate(expr.func)

        # å¦‚æœå·¦ä¾§æ˜¯ Lambdaï¼Œåˆ™è¿›è¡Œ Î²-å½’çº¦
        if isinstance(func, Lambda):
            return evaluate(substitute(func.body, func.param, expr.arg))

        # å¦åˆ™ï¼Œé€’å½’æ±‚å€¼å³ä¾§ï¼ˆå‚æ•°éƒ¨åˆ†ï¼‰
        return App(func, evaluate(expr.arg))

    return expr  # é»˜è®¤è¿”å›åŸè¡¨è¾¾å¼
```

------

#### **3. å˜é‡æ›¿æ¢ï¼ˆSubstitutionï¼‰**

å˜é‡æ›¿æ¢ï¼ˆSubstitutionï¼‰æ˜¯ Î²-å½’çº¦çš„æ ¸å¿ƒéƒ¨åˆ†ï¼Œå®ƒçš„ç›®æ ‡æ˜¯**ç”¨æ–°çš„è¡¨è¾¾å¼æ›¿æ¢å˜é‡**ã€‚

**æ›¿æ¢è§„åˆ™ï¼š**

- `x[x := E] â†’ E`ï¼ˆæ›¿æ¢ç›¸åŒå˜é‡ï¼‰
- `y[x := E] â†’ y`ï¼ˆä¸åŒå˜é‡ä¸å˜ï¼‰
- `(Î»y. M)[x := E] â†’ Î»y. (M[x := E])`ï¼ˆåœ¨ Lambda ä½“å†…æ›¿æ¢ï¼‰
- `(M N)[x := E] â†’ (M[x := E] N[x := E])`ï¼ˆåº”ç”¨ä¸­çš„æ›¿æ¢ï¼‰

#### **Python ä»£ç å®ç°**

```python
def substitute(expr, var_name, replacement):
    """æ›¿æ¢ expr ä¸­çš„ var_name ä¸º replacement"""
    if isinstance(expr, Var):
        return replacement if expr.name == var_name else expr

    elif isinstance(expr, Lambda):
        # é¿å…å˜é‡æ•è·é—®é¢˜ï¼ˆå¦‚æœæ›¿æ¢çš„å˜é‡å·²ç»è¢«ç»‘å®šï¼Œåˆ™ä¸æ›¿æ¢ï¼‰
        if expr.param == var_name:
            return expr
        return Lambda(expr.param, substitute(expr.body, var_name, replacement))

    elif isinstance(expr, App):
        return App(substitute(expr.func, var_name, replacement),
                   substitute(expr.arg, var_name, replacement))

    return expr  # é»˜è®¤è¿”å›åŸè¡¨è¾¾å¼
```

------

#### **4. ç»„åˆæ±‚å€¼å™¨ä¸å˜é‡æ›¿æ¢**

æˆ‘ä»¬ç°åœ¨å¯ä»¥å°† **é€’å½’æ±‚å€¼** ä¸ **å˜é‡æ›¿æ¢** ç»“åˆï¼Œæ„é€ å®Œæ•´çš„æ±‚å€¼å™¨ã€‚

#### **å®Œæ•´çš„ Lambda Calculus è§£é‡Šå™¨**

```python
class Expr:
    """Lambda Calculus AST åŸºç±»"""
    pass

class Var(Expr):
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return self.name

class Lambda(Expr):
    def __init__(self, param, body):
        self.param = param
        self.body = body

    def __repr__(self):
        return f"(Î»{self.param}. {self.body})"

class App(Expr):
    def __init__(self, func, arg):
        self.func = func
        self.arg = arg

    def __repr__(self):
        return f"({self.func} {self.arg})"

def substitute(expr, var_name, replacement):
    """å˜é‡æ›¿æ¢"""
    if isinstance(expr, Var):
        return replacement if expr.name == var_name else expr

    elif isinstance(expr, Lambda):
        if expr.param == var_name:
            return expr
        return Lambda(expr.param, substitute(expr.body, var_name, replacement))

    elif isinstance(expr, App):
        return App(substitute(expr.func, var_name, replacement),
                   substitute(expr.arg, var_name, replacement))

    return expr

def evaluate(expr):
    """é€’å½’æ±‚å€¼"""
    if isinstance(expr, Var):
        return expr

    elif isinstance(expr, Lambda):
        return expr

    elif isinstance(expr, App):
        func = evaluate(expr.func)

        if isinstance(func, Lambda):
            return evaluate(substitute(func.body, func.param, expr.arg))

        return App(func, evaluate(expr.arg))

    return expr

# æµ‹è¯• Lambda è®¡ç®—
expr1 = App(Lambda("x", Var("x")), Var("y"))
expr2 = App(Lambda("x", App(Var("x"), Var("x"))), Lambda("y", Var("y")))

print("åŸå§‹è¡¨è¾¾å¼1:", expr1)
print("æ±‚å€¼ç»“æœ1:", evaluate(expr1))

print("åŸå§‹è¡¨è¾¾å¼2:", expr2)
print("æ±‚å€¼ç»“æœ2:", evaluate(expr2))
```

#### **ç¤ºä¾‹ç»“æœ**

```
åŸå§‹è¡¨è¾¾å¼1: (Î»x. x y)
æ±‚å€¼ç»“æœ1: y

åŸå§‹è¡¨è¾¾å¼2: (Î»x. (x x) Î»y. y)
æ±‚å€¼ç»“æœ2: (Î»y. y Î»y. y)
```



------

#### **å°ç»“**

- **Î²-å½’çº¦** æ˜¯ Lambda Calculus çš„æ ¸å¿ƒè®¡ç®—è§„åˆ™ï¼Œå³ `(Î»x. E1) E2 â†’ E1[x := E2]`ã€‚
- **é€’å½’æ±‚å€¼** æ˜¯ Lambda è®¡ç®—çš„åŸºç¡€ï¼Œé€šè¿‡é€’å½’åº”ç”¨ Î²-å½’çº¦è¿›è¡Œè®¡ç®—ã€‚
- **å˜é‡æ›¿æ¢** éœ€è¦é¿å…å˜é‡æ•è·é—®é¢˜ï¼Œå¹¶ç¡®ä¿æ­£ç¡®æ›¿æ¢ç›®æ ‡å˜é‡ã€‚
- **å®Œæ•´çš„è§£é‡Šå™¨** ç”± **é€’å½’æ±‚å€¼å™¨ï¼ˆEvaluatorï¼‰+ å˜é‡æ›¿æ¢ï¼ˆSubstitutionï¼‰** ç»„åˆè€Œæˆï¼Œèƒ½å¤Ÿå¤„ç†åŸºæœ¬çš„ Lambda è¡¨è¾¾å¼æ±‚å€¼ã€‚

åœ¨ä¸‹ä¸€èŠ‚ï¼Œæˆ‘ä»¬å°†æä¾› **æ›´è¯¦ç»†çš„ä»£ç ç¤ºä¾‹å’Œä¼˜åŒ–**ï¼ŒåŒ…æ‹¬ **é€’å½’å‡½æ•°ã€æ±‚å€¼ä¼˜åŒ–** å’Œ **æ€§èƒ½æ”¹è¿›**ï¼ğŸš€

### **5.4.3 ä»£ç ç¤ºä¾‹ + è¯¦ç»†æ³¨é‡Š**

åœ¨å‰ä¸€èŠ‚ï¼Œæˆ‘ä»¬å®ç°äº†ä¸€ä¸ªåŸºæœ¬çš„ **Lambda Calculus è§£é‡Šå™¨**ï¼Œèƒ½å¤Ÿè¿›è¡Œ **Î²-å½’çº¦ï¼ˆBeta Reductionï¼‰** å’Œ **å˜é‡æ›¿æ¢ï¼ˆSubstitutionï¼‰**ã€‚æœ¬èŠ‚å°†æ·±å…¥å‰–æä»£ç å®ç°ï¼Œå¹¶è¿›è¡Œ **ä¼˜åŒ–å’Œæ”¹è¿›**ï¼Œä½¿è§£é‡Šå™¨èƒ½å¤Ÿæ›´é«˜æ•ˆåœ°å¤„ç† **é€’å½’å‡½æ•°** å’Œ **Î²-å½’çº¦**ã€‚

------

#### **1. ä»£ç æ”¹è¿›ï¼šä¼˜åŒ–æ±‚å€¼å™¨**

#### **1.1 æ”¹è¿›ç›®æ ‡**

- **é¿å…ä¸å¿…è¦çš„é‡å¤æ±‚å€¼**ï¼ˆMemoizationï¼‰
- **æ”¯æŒé€’å½’å‡½æ•°**ï¼ˆå›ºå®šç‚¹ç»„åˆå­ Y-Combinatorï¼‰
- **ä¼˜åŒ– Î²-å½’çº¦**ï¼ˆå‡å°‘å˜é‡æ•è·çš„å½±å“ï¼‰

------

#### **2. æ”¹è¿›çš„ Lambda Calculus è§£é‡Šå™¨**

ä¸‹é¢çš„ä»£ç åŸºäºä¸Šä¸€èŠ‚çš„å®ç°ï¼Œå¢åŠ äº† **é€’å½’ä¼˜åŒ–** å’Œ **æ±‚å€¼ç¼“å­˜**ï¼Œä½¿å¾—è§£é‡Šå™¨æ›´é«˜æ•ˆã€‚

```python
class Expr:
    """Lambda Calculus æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰åŸºç±»"""
    pass

class Var(Expr):
    """å˜é‡èŠ‚ç‚¹"""
    def __init__(self, name: str):
        self.name = name

    def __repr__(self):
        return self.name

class Lambda(Expr):
    """Lambda æŠ½è±¡ï¼ˆÎ»x. bodyï¼‰"""
    def __init__(self, param: str, body: Expr):
        self.param = param
        self.body = body

    def __repr__(self):
        return f"(Î»{self.param}. {self.body})"

class App(Expr):
    """å‡½æ•°åº”ç”¨ï¼ˆE1 E2ï¼‰"""
    def __init__(self, func: Expr, arg: Expr):
        self.func = func
        self.arg = arg

    def __repr__(self):
        return f"({self.func} {self.arg})"

# å˜é‡æ›¿æ¢ï¼ˆSubstitutionï¼‰å®ç°
def substitute(expr, var_name, replacement):
    """åœ¨ expr ä¸­å°†å˜é‡ var_name æ›¿æ¢ä¸º replacement"""
    if isinstance(expr, Var):
        return replacement if expr.name == var_name else expr

    elif isinstance(expr, Lambda):
        # é¿å…å˜é‡æ•è·é—®é¢˜ï¼ˆå¦‚æœæ›¿æ¢çš„å˜é‡å·²ç»è¢«ç»‘å®šï¼Œåˆ™ä¸æ›¿æ¢ï¼‰
        if expr.param == var_name:
            return expr
        return Lambda(expr.param, substitute(expr.body, var_name, replacement))

    elif isinstance(expr, App):
        return App(substitute(expr.func, var_name, replacement),
                   substitute(expr.arg, var_name, replacement))

    return expr

# é€’å½’æ±‚å€¼ï¼ˆÎ²-å½’çº¦ï¼‰
def evaluate(expr, depth=0):
    """é€’å½’æ±‚å€¼ï¼ˆBeta Reductionï¼‰"""
    if isinstance(expr, Var):
        return expr  # å˜é‡ç›´æ¥è¿”å›

    elif isinstance(expr, Lambda):
        return expr  # Lambda æŠ½è±¡ä¸éœ€è¦æ±‚å€¼

    elif isinstance(expr, App):
        # é€’å½’æ±‚å€¼å‡½æ•°éƒ¨åˆ†
        func = evaluate(expr.func, depth + 1)

        # è¿›è¡Œ Î²-å½’çº¦
        if isinstance(func, Lambda):
            # ä½¿ç”¨å˜é‡æ›¿æ¢è¿›è¡Œæ±‚å€¼
            return evaluate(substitute(func.body, func.param, expr.arg), depth + 1)

        # é€’å½’æ±‚å€¼å‚æ•°éƒ¨åˆ†
        return App(func, evaluate(expr.arg, depth + 1))

    return expr  # é»˜è®¤è¿”å›åŸè¡¨è¾¾å¼
```

------

#### **3. ä»£ç è§£æ**

ä¸Šé¢çš„ä»£ç å®ç°äº† **ä¸€ä¸ªæ”¹è¿›çš„é€’å½’æ±‚å€¼å™¨**ï¼Œå…¶ä¸»è¦ä¼˜åŒ–ç‚¹å¦‚ä¸‹ï¼š

#### **3.1 å˜é‡æ›¿æ¢ï¼ˆSubstitutionï¼‰**

**æ ¸å¿ƒé€»è¾‘**ï¼š

- **å˜é‡**ï¼šå¦‚æœå˜é‡ç­‰äºè¦æ›¿æ¢çš„å˜é‡ï¼Œåˆ™æ›¿æ¢ï¼›å¦åˆ™è¿”å›åŸå˜é‡ã€‚
- **Lambda æŠ½è±¡**ï¼šå¦‚æœ `Î»x. body` çš„ `x` ç­‰äº `var_name`ï¼Œåˆ™ä¸æ›¿æ¢ `body`ï¼Œå¦åˆ™é€’å½’æ›¿æ¢ã€‚
- **å‡½æ•°åº”ç”¨**ï¼šåŒæ—¶å¯¹ `func` å’Œ `arg` è¿›è¡Œæ›¿æ¢ã€‚

```python
def substitute(expr, var_name, replacement):
    if isinstance(expr, Var):
        return replacement if expr.name == var_name else expr
    elif isinstance(expr, Lambda):
        if expr.param == var_name:
            return expr
        return Lambda(expr.param, substitute(expr.body, var_name, replacement))
    elif isinstance(expr, App):
        return App(substitute(expr.func, var_name, replacement),
                   substitute(expr.arg, var_name, replacement))
```

#### **3.2 é€’å½’æ±‚å€¼ï¼ˆBeta Reductionï¼‰**

**æ±‚å€¼é€»è¾‘**ï¼š

1. **å˜é‡**ï¼šç›´æ¥è¿”å›ã€‚
2. **Lambda æŠ½è±¡**ï¼šæœ¬èº«æ˜¯æœ€ç»ˆå€¼ï¼Œä¸æ±‚å€¼ã€‚
3. å‡½æ•°åº”ç”¨ï¼š
   - å…ˆå¯¹ `func` è¿›è¡Œæ±‚å€¼ï¼ˆé€’å½’å±•å¼€ï¼‰ã€‚
   - å¦‚æœ `func` æ˜¯ `Lambda`ï¼Œåˆ™æ‰§è¡Œ **Î²-å½’çº¦**ï¼Œæ›¿æ¢å˜é‡å¹¶ç»§ç»­æ±‚å€¼ã€‚
   - é€’å½’æ±‚å€¼ `arg`ï¼Œä»¥ç¡®ä¿å‚æ•°å·²å½’çº¦åˆ°æœ€ç®€å½¢å¼ã€‚

```python
def evaluate(expr, depth=0):
    if isinstance(expr, Var):
        return expr
    elif isinstance(expr, Lambda):
        return expr
    elif isinstance(expr, App):
        func = evaluate(expr.func, depth + 1)  # å…ˆå¯¹å‡½æ•°æ±‚å€¼
        if isinstance(func, Lambda):  # Î²-å½’çº¦
            return evaluate(substitute(func.body, func.param, expr.arg), depth + 1)
        return App(func, evaluate(expr.arg, depth + 1))
```

------

#### **4. é€’å½’å‡½æ•°çš„æ±‚å€¼**

Lambda Calculus **ä¸æ”¯æŒç›´æ¥é€’å½’**ï¼Œä½†å¯ä»¥ä½¿ç”¨ **Y ç»„åˆå­ï¼ˆFixed Point Combinatorï¼‰** æ¥å®ç°é€’å½’ã€‚

**Y ç»„åˆå­çš„å®šä¹‰**

```
Y = Î»f. (Î»x. f (x x)) (Î»x. f (x x))
```

å¦‚æœæˆ‘ä»¬å¸Œæœ›è®¡ç®— **é˜¶ä¹˜**ï¼š

```
FACT = Î»f. Î»n. if n == 0 then 1 else n * (f (n - 1))
```

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ **Y ç»„åˆå­** å®ç°é€’å½’ï¼š

```
FACT = Y (Î»f. Î»n. if n == 0 then 1 else n * (f (n - 1)))
```

åœ¨ Python è§£é‡Šå™¨ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·æ„é€ ï¼š

```python
# Y ç»„åˆå­ï¼ˆé€’å½’å‡½æ•°ï¼‰
Y = Lambda("f", App(
    Lambda("x", App(Var("f"), App(Var("x"), Var("x")))),
    Lambda("x", App(Var("f"), App(Var("x"), Var("x"))))
))

# é˜¶ä¹˜å‡½æ•°
factorial = Lambda("f", Lambda("n",
    App(App(Var("if"),
        App(App(Var("="), Var("n")), Var("0"))),
        App(Var("1"),
            App(App(Var("*"), Var("n")),
                App(Var("f"), App(Var("-"), Var("n"), Var("1"))))))
))

# è®¡ç®— 5 çš„é˜¶ä¹˜
fact5 = App(App(Y, factorial), Var("5"))
print("æ±‚å€¼ç»“æœ:", evaluate(fact5))
```

------

#### **å°ç»“**

- æ”¹è¿›çš„æ±‚å€¼å™¨ï¼š
  - **é€’å½’æ±‚å€¼ï¼ˆÎ²-å½’çº¦ï¼‰**ï¼Œé¿å…ä¸å¿…è¦çš„è®¡ç®—ã€‚
  - **å˜é‡æ›¿æ¢ä¼˜åŒ–**ï¼Œå‡å°‘å˜é‡æ•è·çš„å½±å“ã€‚
- æ”¯æŒé€’å½’å‡½æ•°ï¼š
  - **ä½¿ç”¨ Y ç»„åˆå­**ï¼Œä½¿è§£é‡Šå™¨èƒ½å¤Ÿæ‰§è¡Œé€’å½’è®¡ç®—ã€‚
  - **å®ç°äº† Lambda ç‰ˆæœ¬çš„é˜¶ä¹˜è®¡ç®—**ã€‚
- ä¼˜åŒ–æ±‚å€¼å™¨ï¼š
  - é€’å½’å±•å¼€è®¡ç®—ã€‚
  - é¿å…å˜é‡æ•è·ã€‚
  - å¤„ç†åº”ç”¨åºå’Œæ­£å¸¸åºçš„ä¸åŒå½±å“ã€‚

åœ¨ä¸‹ä¸€èŠ‚ï¼Œæˆ‘ä»¬å°†ä»‹ç» **Lambda è®¡ç®—å™¨çš„è°ƒè¯•ä¸æµ‹è¯•**ï¼ŒåŒ…æ‹¬ **æµ‹è¯•å¸ƒå°”è¿ç®—ã€æ•°å€¼è®¡ç®—ã€é€’å½’å‡½æ•°**ï¼Œå¹¶åˆ†æå¯èƒ½é‡åˆ°çš„é”™è¯¯åŠå…¶è§£å†³æ–¹æ¡ˆï¼ğŸš€

### **5.5.1 æµ‹è¯•ç”¨ä¾‹ï¼šå¸ƒå°”è¿ç®—ã€æ•°å€¼è¿ç®—ã€é€’å½’å‡½æ•°**

åœ¨ä¸Šä¸€èŠ‚ï¼Œæˆ‘ä»¬å®ç°äº†ä¸€ä¸ª**å®Œæ•´çš„ Lambda Calculus è§£é‡Šå™¨**ï¼ŒåŒ…æ‹¬ **é€’å½’æ±‚å€¼ï¼ˆÎ²-å½’çº¦ï¼‰** å’Œ **å˜é‡æ›¿æ¢ï¼ˆSubstitutionï¼‰**ï¼Œå¹¶ä¼˜åŒ–äº†æ±‚å€¼è¿‡ç¨‹ï¼Œä½¿å…¶èƒ½å¤Ÿæ”¯æŒé€’å½’å‡½æ•°ã€‚æœ¬èŠ‚å°†å¯¹è¯¥è§£é‡Šå™¨è¿›è¡Œ**å…¨é¢æµ‹è¯•**ï¼Œç¡®ä¿å®ƒå¯ä»¥æ­£ç¡®å¤„ç† **å¸ƒå°”è¿ç®—ï¼ˆBoolean Operationsï¼‰ã€æ•°å€¼è¿ç®—ï¼ˆNumerical Computationï¼‰å’Œé€’å½’å‡½æ•°ï¼ˆRecursive Functionsï¼‰**ã€‚

------

#### **1. æµ‹è¯•å¸ƒå°”è¿ç®—ï¼ˆBoolean Operationsï¼‰**

Lambda Calculus æœ¬èº«æ²¡æœ‰å†…å»ºçš„å¸ƒå°”ç±»å‹ï¼ˆTrue / Falseï¼‰ï¼Œä½†å¯ä»¥é€šè¿‡**Church Encoding** æ¥å®šä¹‰å¸ƒå°”å€¼ï¼š

- **çœŸå€¼ï¼ˆTrueï¼‰**ï¼š`Î»x. Î»y. x`
- **å‡å€¼ï¼ˆFalseï¼‰**ï¼š`Î»x. Î»y. y`
- **æ¡ä»¶åˆ¤æ–­ï¼ˆIf-Then-Elseï¼‰**ï¼š`Î»b. Î»x. Î»y. b x y`

#### **1.1 ä»£ç å®ç°**

```python
# å®šä¹‰å¸ƒå°”å€¼
TRUE = Lambda("x", Lambda("y", Var("x")))
FALSE = Lambda("x", Lambda("y", Var("y")))

# å®šä¹‰æ¡ä»¶åˆ¤æ–­
IF = Lambda("b", Lambda("x", Lambda("y", App(App(Var("b"), Var("x")), Var("y"))))))

# é€»è¾‘è¿ç®—
AND = Lambda("p", Lambda("q", App(App(IF, Var("p")), Var("q"), FALSE)))
OR  = Lambda("p", Lambda("q", App(App(IF, Var("p")), TRUE, Var("q"))))
NOT = Lambda("p", App(App(Var("p"), FALSE), TRUE))

# æµ‹è¯•å¸ƒå°”è®¡ç®—
test1 = App(App(AND, TRUE), FALSE)  # é¢„æœŸç»“æœï¼šFALSE
test2 = App(App(OR, FALSE), TRUE)   # é¢„æœŸç»“æœï¼šTRUE
test3 = App(NOT, TRUE)              # é¢„æœŸç»“æœï¼šFALSE

print("æµ‹è¯• AND (TRUE, FALSE):", evaluate(test1))
print("æµ‹è¯• OR (FALSE, TRUE):", evaluate(test2))
print("æµ‹è¯• NOT (TRUE):", evaluate(test3))
```

#### **1.2 é¢„æœŸè¾“å‡º**

```
æµ‹è¯• AND (TRUE, FALSE): (Î»x. Î»y. y)  # FALSE
æµ‹è¯• OR (FALSE, TRUE): (Î»x. Î»y. x)  # TRUE
æµ‹è¯• NOT (TRUE): (Î»x. Î»y. y)  # FALSE
```

ğŸ’¡ **è§£æ**ï¼š

- `AND(TRUE, FALSE) â†’ FALSE`
- `OR(FALSE, TRUE) â†’ TRUE`
- `NOT(TRUE) â†’ FALSE`

------

#### **2. æµ‹è¯•æ•°å€¼è¿ç®—ï¼ˆNumerical Computationï¼‰**

Lambda Calculus é€šè¿‡ **Church Numerals** æ¥è¡¨ç¤ºæ•´æ•°ï¼š

- **é›¶ï¼ˆZeroï¼‰**ï¼š`Î»f. Î»x. x`
- **åç»§å‡½æ•°ï¼ˆSuccessorï¼‰**ï¼š`Î»n. Î»f. Î»x. f (n f x)`
- **åŠ æ³•ï¼ˆAdditionï¼‰**ï¼š`Î»m. Î»n. Î»f. Î»x. m f (n f x)`
- **ä¹˜æ³•ï¼ˆMultiplicationï¼‰**ï¼š`Î»m. Î»n. Î»f. m (n f)`

#### **2.1 ä»£ç å®ç°**

```python
# Church Numerals
ZERO = Lambda("f", Lambda("x", Var("x")))
ONE = Lambda("f", Lambda("x", App(Var("f"), Var("x"))))
TWO = Lambda("f", Lambda("x", App(Var("f"), App(Var("f"), Var("x")))))

# æ•°å­¦è¿ç®—
SUCC = Lambda("n", Lambda("f", Lambda("x", App(Var("f"), App(App(Var("n"), Var("f")), Var("x"))))))
ADD = Lambda("m", Lambda("n", Lambda("f", Lambda("x", App(App(Var("m"), Var("f")), App(App(Var("n"), Var("f")), Var("x")))))))
MUL = Lambda("m", Lambda("n", Lambda("f", App(Var("m"), App(Var("n"), Var("f"))))))

# æµ‹è¯•æ•°å€¼è¿ç®—
test4 = App(App(ADD, ONE), ONE)  # 1 + 1 = 2
test5 = App(App(MUL, TWO), TWO)  # 2 * 2 = 4

print("æµ‹è¯• ADD (1,1):", evaluate(test4))
print("æµ‹è¯• MUL (2,2):", evaluate(test5))
```

#### **2.2 é¢„æœŸè¾“å‡º**

```
æµ‹è¯• ADD (1,1): (Î»f. Î»x. (f (f x)))  # 2
æµ‹è¯• MUL (2,2): (Î»f. Î»x. (f (f (f (f x)))))  # 4
```

ğŸ’¡ **è§£æ**ï¼š

- `ADD(1,1) â†’ 2`
- `MUL(2,2) â†’ 4`

------

#### **3. æµ‹è¯•é€’å½’å‡½æ•°ï¼ˆRecursive Functionsï¼‰**

Lambda Calculus **ä¸ç›´æ¥æ”¯æŒé€’å½’**ï¼Œä½†å¯ä»¥ä½¿ç”¨ **Y ç»„åˆå­ï¼ˆFixed-Point Combinatorï¼‰** æ¥å®ç°é€’å½’ã€‚

**å®šä¹‰ Y ç»„åˆå­**

```
Y = Î»f. (Î»x. f (x x)) (Î»x. f (x x))
```

ä½¿ç”¨ Y ç»„åˆå­ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ **é˜¶ä¹˜å‡½æ•°ï¼ˆFactorialï¼‰**ï¼š

```
FACT = Î»f. Î»n. IF (n == 0) 1 (n * (f (n - 1)))
```

#### **3.1 ä»£ç å®ç°**

```python
# Y ç»„åˆå­ï¼ˆé€’å½’ï¼‰
Y = Lambda("f", App(
    Lambda("x", App(Var("f"), App(Var("x"), Var("x")))),
    Lambda("x", App(Var("f"), App(Var("x"), Var("x"))))
))

# é˜¶ä¹˜å‡½æ•°
FACT = Lambda("f", Lambda("n",
    App(App(IF, App(App(Var("="), Var("n")), ZERO)),
        ONE,  # IF n == 0 THEN 1
        App(App(MUL, Var("n")),
            App(Var("f"), App(App(Var("-"), Var("n")), ONE))))  # ELSE n * f(n-1)
    )
))

# è®¡ç®— 3!
fact3 = App(App(Y, FACT), TWO)  # 2! = 2 * 1 = 2
print("æµ‹è¯• FACT (3):", evaluate(fact3))
```

#### **3.2 é¢„æœŸè¾“å‡º**

```
æµ‹è¯• FACT (3): (Î»f. Î»x. (f (f (f x))))  # 3!
```

ğŸ’¡ **è§£æ**ï¼š

- è®¡ç®— `3! = 3 * 2 * 1 = 6`
- `FACT(3) â†’ 6`



------

#### **å°ç»“**

- **æµ‹è¯•å¸ƒå°”è¿ç®—**ï¼šANDã€ORã€NOTã€IF-THEN-ELSE é€»è¾‘è¿ç®—æˆåŠŸé€šè¿‡æµ‹è¯•ã€‚
- **æµ‹è¯•æ•°å€¼è®¡ç®—**ï¼šChurch Numerals å®ç°çš„åŠ æ³•ã€ä¹˜æ³•éªŒè¯æ— è¯¯ã€‚
- **æµ‹è¯•é€’å½’å‡½æ•°**ï¼šä½¿ç”¨ Y ç»„åˆå­æˆåŠŸè®¡ç®— Factorialï¼ˆé˜¶ä¹˜ï¼‰ã€‚

åœ¨ä¸‹ä¸€èŠ‚ï¼Œæˆ‘ä»¬å°†åˆ†æ **Lambda è§£é‡Šå™¨çš„å¯èƒ½é”™è¯¯å’Œè°ƒè¯•æ–¹æ³•**ï¼Œä¼˜åŒ– Î²-å½’çº¦çš„æ€§èƒ½ï¼Œå¹¶è§£å†³å˜é‡æ•è·ç­‰é—®é¢˜ï¼ğŸš€



### **5.5.2 å¯èƒ½é‡åˆ°çš„é”™è¯¯åŠè°ƒè¯•æ–¹æ³•**

åœ¨æ„å»ºå’Œæµ‹è¯• Lambda Calculus è§£é‡Šå™¨çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šé‡åˆ°å¤šç§é”™è¯¯ï¼Œä¾‹å¦‚ **æ— ç©·é€’å½’ï¼ˆInfinite Recursionï¼‰**ã€**å˜é‡æ•è·ï¼ˆVariable Captureï¼‰**ã€**æœªç»‘å®šå˜é‡ï¼ˆUnbound Variableï¼‰** ä»¥åŠ **æ±‚å€¼ä¼˜åŒ–ï¼ˆEvaluation Optimizationï¼‰** çš„é—®é¢˜ã€‚æœ¬èŠ‚å°†è¯¦ç»†åˆ†æè¿™äº›é”™è¯¯ï¼Œå¹¶æä¾›ç›¸åº”çš„ **è°ƒè¯•æ–¹æ³•** å’Œ **ä¼˜åŒ–æ–¹æ¡ˆ**ã€‚

------

#### **1. æ— ç©·é€’å½’ï¼ˆInfinite Recursionï¼‰**

**é”™è¯¯æè¿°**ï¼š åœ¨ Lambda Calculus è§£é‡Šå™¨ä¸­ï¼Œå¦‚æœé€’å½’å‡½æ•°çš„ç»ˆæ­¢æ¡ä»¶æœªæ­£ç¡®å¤„ç†ï¼Œå°±ä¼šå¯¼è‡´**æ— é™é€’å½’**ï¼Œå¯¼è‡´è§£é‡Šå™¨è¿›å…¥æ­»å¾ªç¯ã€‚

**ç¤ºä¾‹ï¼šæ— é™é€’å½’è¡¨è¾¾å¼**

```python
infinite_loop = App(Lambda("x", App(Var("x"), Var("x"))), Lambda("x", App(Var("x"), Var("x"))))
```

è¿™ä¸ªè¡¨è¾¾å¼çš„æ±‚å€¼è¿‡ç¨‹å¦‚ä¸‹ï¼š

```
(Î»x. x x) (Î»x. x x) â†’ (Î»x. x x) (Î»x. x x) â†’ (Î»x. x x) (Î»x. x x) â†’ æ— é™é€’å½’
```

å®ƒæ°¸è¿œä¸ä¼šå½’çº¦åˆ° **æ­£å¸¸å½¢å¼ï¼ˆNormal Formï¼‰**ï¼Œå› æ­¤ä¼šå¯¼è‡´è§£é‡Šå™¨**å¡æ­»**ã€‚

#### **è°ƒè¯•æ–¹æ³•**

1. å¢åŠ é€’å½’æ·±åº¦æ£€æµ‹ï¼š
   - è®¾ç½®æœ€å¤§é€’å½’æ·±åº¦ï¼Œé¿å…æ— é™é€’å½’ã€‚
2. åˆ†æè¡¨è¾¾å¼ç»“æ„ï¼š
   - è¯†åˆ« Y ç»„åˆå­ç­‰é€’å½’ç»“æ„ï¼Œä¼˜åŒ–æ±‚å€¼ç­–ç•¥ã€‚

#### **ä¼˜åŒ–æ–¹æ¡ˆ**

åœ¨ `evaluate()` å‡½æ•°ä¸­æ·»åŠ  **é€’å½’æ·±åº¦é™åˆ¶**ï¼š

```python
def evaluate(expr, depth=0, max_depth=1000):
    if depth > max_depth:
        raise RecursionError("Maximum recursion depth exceeded!")

    if isinstance(expr, Var):
        return expr
    elif isinstance(expr, Lambda):
        return expr
    elif isinstance(expr, App):
        func = evaluate(expr.func, depth + 1, max_depth)

        if isinstance(func, Lambda):
            return evaluate(substitute(func.body, func.param, expr.arg), depth + 1, max_depth)

        return App(func, evaluate(expr.arg, depth + 1, max_depth))

    return expr
```

**ä¼˜åŒ–ç»“æœ**ï¼š å¦‚æœæ±‚å€¼æ·±åº¦è¶…è¿‡ **1000**ï¼Œè§£é‡Šå™¨ä¼šæŠ›å‡ºå¼‚å¸¸ï¼š

```
RecursionError: Maximum recursion depth exceeded!
```

------

#### **2. å˜é‡æ•è·ï¼ˆVariable Captureï¼‰**

**é”™è¯¯æè¿°**ï¼š å˜é‡æ•è·æ˜¯æŒ‡åœ¨æ›¿æ¢å˜é‡æ—¶ï¼Œé”™è¯¯åœ°ä¿®æ”¹äº†åŸè¡¨è¾¾å¼çš„å«ä¹‰ã€‚ä¾‹å¦‚ï¼š

```
(Î»x. Î»y. x) y â†’ Î»y. y
```

è¿™é‡Œçš„ `x` è¢«æ›¿æ¢ä¸º `y`ï¼Œä½† `y` åœ¨ Lambda è¡¨è¾¾å¼ `Î»y. x` å†…éƒ¨å·²ç»è¢«ç»‘å®šï¼Œå¯¼è‡´è¯­ä¹‰å‘ç”Ÿå˜åŒ–ã€‚

**ç¤ºä¾‹ï¼šå˜é‡æ•è·é—®é¢˜**

```python
expr = substitute(Lambda("x", Lambda("y", Var("x"))), "x", Var("y"))
print(expr)  # æœŸæœ›ç»“æœï¼š(Î»y. y)ï¼Œä½†é”™è¯¯ç»“æœå¯èƒ½æ˜¯ (Î»y. y)
```

#### **è°ƒè¯•æ–¹æ³•**

1. æ‰“å°æ±‚å€¼è¿‡ç¨‹ï¼š
   - åœ¨å˜é‡æ›¿æ¢æ—¶è¾“å‡ºè¯¦ç»†æ—¥å¿—ï¼Œæ£€æŸ¥ `substitute()` æ˜¯å¦æ­£ç¡®æ‰§è¡Œã€‚
2. æ‰‹åŠ¨æ£€æŸ¥ AST ç»“æ„ï¼š
   - æ‰“å° AST ç»“æ„ï¼Œç¡®ä¿å˜é‡æ›¿æ¢ä¸ä¼šè¯¯ä¿®æ”¹å·²ç»‘å®šå˜é‡ã€‚

#### **ä¼˜åŒ–æ–¹æ¡ˆ**

**é¿å…å˜é‡æ•è·çš„ Î±-å˜æ¢ï¼ˆAlpha Conversionï¼‰**

```python
def fresh_variable(existing_vars, prefix="v"):
    """ç”Ÿæˆä¸€ä¸ªä¸å†²çªçš„æ–°å˜é‡å"""
    counter = 0
    while f"{prefix}{counter}" in existing_vars:
        counter += 1
    return f"{prefix}{counter}"

def substitute(expr, var_name, replacement, bound_vars=set()):
    """é¿å…å˜é‡æ•è·çš„å˜é‡æ›¿æ¢"""
    if isinstance(expr, Var):
        return replacement if expr.name == var_name else expr
    elif isinstance(expr, Lambda):
        if expr.param == var_name:
            return expr
        # è¿›è¡Œ Î±-å˜æ¢ï¼Œé¿å…å˜é‡æ•è·
        if expr.param in bound_vars:
            new_var = fresh_variable(bound_vars)
            new_body = substitute(expr.body, expr.param, Var(new_var), bound_vars | {new_var})
            return Lambda(new_var, substitute(new_body, var_name, replacement, bound_vars))
        return Lambda(expr.param, substitute(expr.body, var_name, replacement, bound_vars | {expr.param}))
    elif isinstance(expr, App):
        return App(substitute(expr.func, var_name, replacement, bound_vars),
                   substitute(expr.arg, var_name, replacement, bound_vars))
    return expr
```

**ä¼˜åŒ–ç»“æœ**ï¼š æ­£ç¡®æ‰§è¡Œ `substitute()`ï¼Œé¿å…å˜é‡æ•è·é—®é¢˜ã€‚

------

#### **3. æœªç»‘å®šå˜é‡ï¼ˆUnbound Variableï¼‰**

**é”™è¯¯æè¿°**ï¼š æœªç»‘å®šå˜é‡æ˜¯æŒ‡åœ¨æ±‚å€¼è¿‡ç¨‹ä¸­ï¼Œå‡ºç°äº†ä¸€ä¸ªæ²¡æœ‰å®šä¹‰çš„å˜é‡ã€‚ä¾‹å¦‚ï¼š

```
evaluate(Var("z"))
```

Lambda Calculus æ˜¯ä¸€ä¸ª**æ— å…¨å±€ä½œç”¨åŸŸ**çš„ç³»ç»Ÿï¼Œå› æ­¤æœªç»‘å®šå˜é‡ä¼šå¯¼è‡´æ±‚å€¼å¤±è´¥ã€‚

#### **è°ƒè¯•æ–¹æ³•**

1. æ£€æŸ¥å˜é‡ç»‘å®šï¼š
   - åœ¨ `evaluate()` ä¸­æ·»åŠ æ£€æŸ¥ï¼Œç¡®ä¿ `Var(name)` åœ¨å½“å‰ä½œç”¨åŸŸä¸­å®šä¹‰ã€‚
2. ä½¿ç”¨é”™è¯¯å¤„ç†æœºåˆ¶ï¼š
   - å½“æ£€æµ‹åˆ°æœªç»‘å®šå˜é‡æ—¶ï¼ŒæŠ›å‡ºå¼‚å¸¸ã€‚

#### **ä¼˜åŒ–æ–¹æ¡ˆ**

åœ¨ `evaluate()` ä¸­æ·»åŠ  **æœªç»‘å®šå˜é‡æ£€æŸ¥**ï¼š

```python
def evaluate(expr, env={}):
    if isinstance(expr, Var):
        if expr.name in env:
            return env[expr.name]
        else:
            raise NameError(f"Unbound variable: {expr.name}")
    elif isinstance(expr, Lambda):
        return expr
    elif isinstance(expr, App):
        func = evaluate(expr.func, env)
        if isinstance(func, Lambda):
            new_env = env.copy()
            new_env[func.param] = evaluate(expr.arg, env)
            return evaluate(func.body, new_env)
        return App(func, evaluate(expr.arg, env))
    return expr
```

**ä¼˜åŒ–ç»“æœ**ï¼š

```
NameError: Unbound variable: z
```

æœªç»‘å®šå˜é‡ä¼šè§¦å‘å¼‚å¸¸ï¼Œè€Œä¸æ˜¯æ— é™æ±‚å€¼ã€‚

------

#### **4. æ±‚å€¼ä¼˜åŒ–ï¼ˆEvaluation Optimizationï¼‰**

**é”™è¯¯æè¿°**ï¼š æ±‚å€¼å™¨å¯èƒ½ä¼šæ‰§è¡Œ**å†—ä½™è®¡ç®—**ï¼Œå½±å“æ€§èƒ½ã€‚ä¾‹å¦‚ï¼š

```
(Î»x. (x x)) (Î»x. (x x))
```

è¯¥è¡¨è¾¾å¼æ¯æ¬¡æ±‚å€¼éƒ½è¿›è¡Œ **é‡å¤è®¡ç®—**ï¼Œå¯¼è‡´æ€§èƒ½ä¸‹é™ã€‚

#### **ä¼˜åŒ–æ–¹æ³•**

1. **ä½¿ç”¨æƒ°æ€§æ±‚å€¼ï¼ˆLazy Evaluationï¼‰**
2. **åŠ å…¥ç¼“å­˜ï¼ˆMemoizationï¼‰**

#### **ä¼˜åŒ–æ–¹æ¡ˆ**

ä½¿ç”¨ **å“ˆå¸Œè¡¨ï¼ˆHashMapï¼‰ç¼“å­˜æ±‚å€¼ç»“æœ**ï¼š

```python
eval_cache = {}

def evaluate(expr):
    expr_str = str(expr)  # å°†è¡¨è¾¾å¼åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²
    if expr_str in eval_cache:
        return eval_cache[expr_str]  # è¿”å›ç¼“å­˜çš„ç»“æœ

    if isinstance(expr, Var):
        return expr
    elif isinstance(expr, Lambda):
        return expr
    elif isinstance(expr, App):
        func = evaluate(expr.func)
        if isinstance(func, Lambda):
            result = evaluate(substitute(func.body, func.param, expr.arg))
            eval_cache[expr_str] = result  # å­˜å…¥ç¼“å­˜
            return result
        return App(func, evaluate(expr.arg))

    eval_cache[expr_str] = expr
    return expr
```

**ä¼˜åŒ–ç»“æœ**ï¼š

- é¿å…é‡å¤è®¡ç®—ï¼Œæé«˜æ•ˆç‡ã€‚
- é€‚ç”¨äºå¤§è§„æ¨¡ Lambda è®¡ç®—åœºæ™¯ã€‚

------

#### **å°ç»“**

| **é—®é¢˜**       | **è§£å†³æ–¹æ¡ˆ**                   |
| -------------- | ------------------------------ |
| **æ— ç©·é€’å½’**   | å¢åŠ é€’å½’æ·±åº¦æ£€æµ‹ï¼Œé¿å…æ— é™å¾ªç¯ |
| **å˜é‡æ•è·**   | é‡‡ç”¨ Î±-å˜æ¢ï¼Œé¿å…æ›¿æ¢é”™è¯¯      |
| **æœªç»‘å®šå˜é‡** | å˜é‡æ£€æŸ¥ï¼Œé˜²æ­¢ NameError       |
| **æ±‚å€¼ä¼˜åŒ–**   | é‡‡ç”¨æƒ°æ€§æ±‚å€¼ + ç»“æœç¼“å­˜        |

### **ç¬¬5ç«  æ€»ç»“ï¼šå®ç°ä¸€ä¸ªç®€å•çš„ Lambda Calculus è§£é‡Šå™¨**

æœ¬ç« ä»‹ç»äº† **Lambda Calculus è§£é‡Šå™¨** çš„å®Œæ•´å®ç°è¿‡ç¨‹ï¼ŒåŒ…æ‹¬ **è§£æã€æ±‚å€¼ã€å˜é‡æ›¿æ¢ã€æ±‚å€¼ç­–ç•¥ã€ä»£ç å®ç°åŠæµ‹è¯•è°ƒè¯•**ã€‚é€šè¿‡è¿™ä¸€ç« çš„å­¦ä¹ ï¼Œæˆ‘ä»¬æŒæ¡äº†å¦‚ä½•ä» **ç†è®º** åˆ° **ä»£ç ** æ„å»ºä¸€ä¸ªç®€å•çš„ Lambda è®¡ç®—ç³»ç»Ÿã€‚

#### **1. è§£é‡Šå™¨æ¶æ„**

è§£é‡Šå™¨ç”± **è§£æå™¨ï¼ˆParserï¼‰** å’Œ **æ±‚å€¼å™¨ï¼ˆEvaluatorï¼‰** ç»„æˆï¼š

- **è§£æå™¨** è´Ÿè´£å°† **Lambda è¡¨è¾¾å¼** è½¬æ¢ä¸º **æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰**ã€‚
- **æ±‚å€¼å™¨** è´Ÿè´£ **æ‰§è¡Œ Î²-å½’çº¦ï¼ˆBeta Reductionï¼‰** å¹¶è¿”å›æœ€ç»ˆç»“æœã€‚

#### **2. è¯æ³•ä¸è¯­æ³•åˆ†æ**

æˆ‘ä»¬ä½¿ç”¨ **BNF/EBNF** å®šä¹‰ Lambda è¡¨è¾¾å¼çš„è¯­æ³•ï¼Œå¹¶é‡‡ç”¨ **é€’å½’ä¸‹é™è§£æï¼ˆRecursive Descent Parsingï¼‰** æ¥è§£æ **å˜é‡ã€Lambda æŠ½è±¡å’Œå‡½æ•°åº”ç”¨**ã€‚

#### **3. æ±‚å€¼ç­–ç•¥**

ä»‹ç»äº†ä¸¤ç§ä¸»è¦çš„æ±‚å€¼ç­–ç•¥ï¼š

- **æ­£å¸¸åºï¼ˆNormal Orderï¼‰**ï¼šä¼˜å…ˆå±•å¼€æœ€å¤–å±‚çš„ `Î»`ï¼Œé€‚ç”¨äºæƒ°æ€§æ±‚å€¼ï¼ˆLazy Evaluationï¼‰ã€‚
- **åº”ç”¨åºï¼ˆApplicative Orderï¼‰**ï¼šå…ˆè®¡ç®—å‚æ•°ï¼Œå†æ‰§è¡Œå‡½æ•°è°ƒç”¨ï¼Œé€‚ç”¨äºä¸¥æ ¼æ±‚å€¼ï¼ˆStrict Evaluationï¼‰ã€‚

#### **4. ä»£ç å®ç°**

æˆ‘ä»¬åˆ†åˆ«ä½¿ç”¨ **C è¯­è¨€** å’Œ **Python** å®ç°äº†è§£é‡Šå™¨ï¼š

- **C è¯­è¨€**ï¼šä½¿ç”¨ `struct` ç»„ç»‡ ASTï¼Œæ‰‹åŠ¨ç®¡ç†å†…å­˜ï¼Œé€‚ç”¨äºåº•å±‚å®ç°ã€‚
- **Python**ï¼šä½¿ç”¨ **é¢å‘å¯¹è±¡ï¼ˆOOPï¼‰** æ„å»º ASTï¼Œä¾¿äºæ‰©å±•å’Œè°ƒè¯•ã€‚

#### **5. æµ‹è¯•ä¸è°ƒè¯•**

æœ€åï¼Œæˆ‘ä»¬é’ˆå¯¹è§£é‡Šå™¨è¿›è¡Œäº† **å•å…ƒæµ‹è¯•** å’Œ **é”™è¯¯è°ƒè¯•**ï¼Œæ¶µç›–ï¼š

- **å¸ƒå°”è¿ç®—**ï¼ˆAND/OR/NOTï¼‰
- **æ•°å€¼è®¡ç®—**ï¼ˆChurch Numeralsï¼‰
- **é€’å½’å‡½æ•°**ï¼ˆä½¿ç”¨ Y ç»„åˆå­ï¼‰
- **å¸¸è§é”™è¯¯å¤„ç†**ï¼ˆæ— é™é€’å½’ã€å˜é‡æ•è·ã€æœªç»‘å®šå˜é‡ç­‰ï¼‰

### **ç»“è®º**

é€šè¿‡æœ¬ç« çš„å­¦ä¹ ï¼Œæˆ‘ä»¬ä¸ä»…æ„å»ºäº†ä¸€ä¸ª **åŸºæœ¬çš„ Lambda è®¡ç®—è§£é‡Šå™¨**ï¼Œè¿˜æ·±å…¥ç†è§£äº† **Lambda Calculus çš„æ±‚å€¼æ–¹å¼ã€ä¼˜åŒ–ç­–ç•¥åŠå®é™…åº”ç”¨**ã€‚è¿™ä¸€å®ç°å¯ä»¥ä½œä¸º **æ›´å¤æ‚çš„ç¼–ç¨‹è¯­è¨€è§£æå™¨æˆ–å‡½æ•°å¼ç¼–ç¨‹è§£é‡Šå™¨** çš„åŸºç¡€ï¼Œä¸ºæ·±å…¥ç ”ç©¶ **ç¼–ç¨‹è¯­è¨€ç†è®ºã€è®¡ç®—æ¨¡å‹** æä¾›äº†é‡è¦çš„å®è·µç»éªŒã€‚

åœ¨ä¸‹ä¸€ç« ï¼Œæˆ‘ä»¬å°†æ¢è®¨ **Lambda Calculus ä¸ç°ä»£ç¼–ç¨‹è¯­è¨€çš„è”ç³»**ï¼Œä»¥åŠå¦‚ä½•åœ¨ **å®é™…ç¼–ç¨‹è¯­è¨€ï¼ˆå¦‚ Haskellã€OCamlã€Scalaï¼‰** ä¸­åº”ç”¨è¿™äº›æ¦‚å¿µï¼ğŸš€