### Chapter 7: **Lambda Calculus and Functional Programming**

1. Impact on Functional Languages
   - How Lambda Calculus shaped Lisp, Scheme, Haskell, ML, etc.
   - Treating functions as first-class citizens
2. Lambda Expressions in Haskell
   - Defining functions and anonymous functions
   - Type inference in practice
   - High-order functions and currying
3. Comparison with Imperative Languages
   - The absence (or simulation) of mutable state
   - Benefits of pure functional programming for concurrency and parallelism
4. Hands-On: Implementing Numerals, Recursion, and Data Structures in Haskell
   - Defining Church numerals, boolean operations, and more
   - Mapping each construction to its pure lambda equivalent
5. Performance and Optimization
   - How lazy evaluation affects performance
   - A brief overview of GHC optimizations

### ç¬¬7ç« ã€€**Lambda Calculusä¸å‡½æ•°å¼ç¼–ç¨‹**

1. Lambda Calculuså¦‚ä½•å½±å“å‡½æ•°å¼è¯­è¨€
   - Lispã€Schemeã€Haskellã€MLç­‰è¯­è¨€çš„è®¾è®¡æ€æƒ³
   - å‡½æ•°æ˜¯ä¸€ç­‰å…¬æ°‘çš„æ¦‚å¿µ
2. Haskellä¸­çš„Lambdaè¡¨è¾¾å¼
   - å‡½æ•°å®šä¹‰ä¸åŒ¿åå‡½æ•°
   - ç±»å‹æ¨æ–­
   - é«˜é˜¶å‡½æ•°ä¸æŸ¯é‡ŒåŒ–ï¼ˆCurryingï¼‰
3. ä¸å‘½ä»¤å¼è¯­è¨€çš„æ¯”è¾ƒ
   - çŠ¶æ€ä¸å¯å˜å˜é‡çš„ç¼ºå¤±ï¼ˆæˆ–æ¨¡æ‹Ÿï¼‰
   - çº¯å‡½æ•°å¼ç¼–ç¨‹å¯¹å¹¶å‘ä¸å¹¶è¡Œçš„ä¼˜åŠ¿
4. å®æˆ˜ï¼šåœ¨Haskellä¸­å®ç°æ•°å€¼ã€é€’å½’ã€æ•°æ®ç»“æ„
   - ç”¨Haskellå®šä¹‰Churchæ•°ã€å¸ƒå°”æ“ä½œ
   - å±•ç¤ºä¸çº¯Lambdaæ¼”ç®—çš„å¯¹åº”å…³ç³»
5. æ€§èƒ½ä¸ä¼˜åŒ–
   - æƒ°æ€§æ±‚å€¼ç­–ç•¥å¯¹æ€§èƒ½çš„å½±å“
   - Haskellç¼–è¯‘å™¨ï¼ˆGHCï¼‰çš„ä¼˜åŒ–è¿‡ç¨‹æ¦‚è¿°

### **7.1.1 Lispã€Schemeã€Haskellã€ML ç­‰è¯­è¨€çš„è®¾è®¡æ€æƒ³**

Lambda Calculus ä½œä¸ºè®¡ç®—ç†è®ºçš„åŸºç¡€ï¼Œæ·±åˆ»å½±å“äº†ç°ä»£ç¼–ç¨‹è¯­è¨€çš„å‘å±•ï¼Œç‰¹åˆ«æ˜¯ **å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ï¼ˆFunctional Programming Languagesï¼‰**ã€‚åœ¨ Lispã€Schemeã€Haskellã€ML è¿™äº›è¯­è¨€ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ° **Lambda Calculus çš„æ ¸å¿ƒæ€æƒ³**ï¼Œå®ƒä»¬çš„è®¾è®¡éƒ½å—åˆ° **é«˜é˜¶å‡½æ•°ã€æ— çŠ¶æ€è®¡ç®—ã€é€’å½’å’Œæƒ°æ€§æ±‚å€¼** ç­‰åŸåˆ™çš„å¯å‘ã€‚

æœ¬èŠ‚å°†æ¢è®¨ï¼š

1. **Lambda Calculus å¦‚ä½•å½±å“å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€**
2. **Lispï¼šæœ€æ—©çš„ Lambda è¯­è¨€**
3. **Schemeï¼šæ‰©å±•çš„ Lambda è®¡ç®—**
4. **MLï¼šå¼ºç±»å‹ä¸æ¨¡å¼åŒ¹é…**
5. **Haskellï¼šçº¯å‡½æ•°å¼è¯­è¨€çš„å…¸èŒƒ**

------

#### **1. Lambda Calculus å¦‚ä½•å½±å“å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€**

Lambda Calculus å½±å“ç¼–ç¨‹è¯­è¨€çš„æ ¸å¿ƒæ¦‚å¿µåŒ…æ‹¬ï¼š

- **åŒ¿åå‡½æ•°ï¼ˆAnonymous Functionsï¼‰**ï¼šæ‰€æœ‰å‡½æ•°éƒ½å¯ä»¥è§†ä¸º Lambda è¡¨è¾¾å¼
- **é«˜é˜¶å‡½æ•°ï¼ˆHigher-Order Functionsï¼‰**ï¼šå‡½æ•°å¯ä»¥ä½œä¸ºå‚æ•°å’Œè¿”å›å€¼
- **å‡½æ•°å¼æ— çŠ¶æ€è®¡ç®—ï¼ˆStateless Computationï¼‰**ï¼šé¿å…å¯å˜å˜é‡ï¼Œæé«˜ç¨‹åºçš„å¯é¢„æµ‹æ€§
- **é€’å½’ä¸è‡ªå¼•ç”¨ï¼ˆRecursion & Fixed Point Combinatorsï¼‰**ï¼šä½¿ç”¨ `Y ç»„åˆå­` å®ç°é€’å½’
- **ç±»å‹æ¨å¯¼ä¸æŸ¯é‡ŒåŒ–ï¼ˆType Inference & Curryingï¼‰**ï¼šå‡½æ•°å¯ä»¥è¢«è‡ªåŠ¨æ¨å¯¼ç±»å‹ï¼Œå¹¶è¿›è¡Œéƒ¨åˆ†åº”ç”¨

è¿™äº›æ€æƒ³è¢«ä¸åŒçš„å‡½æ•°å¼è¯­è¨€ç»§æ‰¿ï¼Œå¹¶å‘å±•å‡ºäº†è‡ªå·±çš„é£æ ¼ã€‚

------

#### **2. Lispï¼šæœ€æ—©çš„ Lambda è¯­è¨€**

#### **2.1 Lisp è¯­è¨€æ¦‚è¿°**

Lispï¼ˆList Processingï¼‰æ˜¯ **1958 å¹´** ç”± John McCarthy å‘æ˜çš„ **ç¬¬ä¸€ç§å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€**ã€‚å®ƒçš„æ ¸å¿ƒè®¾è®¡å—åˆ° **Lambda Calculus** çš„ç›´æ¥å½±å“ã€‚

Lisp çš„åŸºæœ¬ç‰¹ç‚¹ï¼š

- **ä¸€åˆ‡çš†è¡¨è¾¾å¼**ï¼ˆEverything is an expressionï¼‰
- **åŒ¿åå‡½æ•°ï¼ˆLambda Functionsï¼‰æ˜¯æ ¸å¿ƒ**ï¼Œå¯ä½œä¸ºå˜é‡å’Œå‚æ•°
- **åŠ¨æ€ç±»å‹**ï¼Œæ”¯æŒç¬¦å·è®¡ç®—
- **æ”¯æŒé€’å½’ï¼Œå…è®¸å®šä¹‰ Y ç»„åˆå­**
- **ä½¿ç”¨ S-è¡¨è¾¾å¼ï¼ˆS-Expressionsï¼‰è¡¨ç¤ºä»£ç å’Œæ•°æ®**

#### **2.2 Lisp çš„ Lambda è®¡ç®—ç¤ºä¾‹**

Lisp ä»£ç ï¼š

```lisp
(defun square (x) (* x x))

((lambda (x) (* x x)) 5)  ; åŒ¿åå‡½æ•°ï¼ˆç­‰ä»·äº Î»x. x * xï¼‰
```

Lisp ä¸­çš„åŒ¿åå‡½æ•° `(lambda (x) (* x x))` ç›´æ¥å¯¹åº” Lambda Calculus ä¸­çš„ï¼š

```
Î»x. x * x
```

ğŸ’¡ **Lisp çš„ Lambda æœºåˆ¶ç›´æ¥ç»§æ‰¿äº† Lambda Calculus çš„è¡¨è¾¾æ–¹å¼ï¼**

------

#### **3. Schemeï¼šæ‰©å±•çš„ Lambda è®¡ç®—**

#### **3.1 Scheme è¯­è¨€æ¦‚è¿°**

Scheme è¯ç”Ÿäº **1975 å¹´**ï¼Œæ˜¯ Lisp çš„ä¸€ä¸ªç®€åŒ–ç‰ˆæœ¬ï¼ŒåŒæ—¶æ‰©å±•äº† Lambda Calculus ç›¸å…³çš„æ¦‚å¿µã€‚å®ƒçš„ç‰¹ç‚¹åŒ…æ‹¬ï¼š

- **æ›´çº¯ç²¹çš„ Lambda è®¡ç®—**ï¼ˆæ²¡æœ‰ Lisp å¤æ‚çš„å®ç³»ç»Ÿï¼‰
- **å°¾é€’å½’ä¼˜åŒ–ï¼ˆTail Call Optimization, TCOï¼‰**
- **`call/cc`ï¼ˆContinuation Passing Style, CPSï¼‰**
- **åŸºäº Lambda ç»„åˆå­çš„æ§åˆ¶æµ**

#### **3.2 Scheme çš„ Lambda è®¡ç®—**

Scheme ä»£ç ï¼š

```scheme
(define (factorial n)
  (if (= n 0) 1 (* n (factorial (- n 1)))))

(define factorial-lambda
  (lambda (n) (if (= n 0) 1 (* n (factorial-lambda (- n 1))))))
```

ğŸ’¡ **Scheme ç»§æ‰¿äº† Lisp çš„ Lambda è¯­æ³•ï¼Œå¹¶è¿›ä¸€æ­¥å¼ºåŒ–äº†é€’å½’è®¡ç®—å’Œå°¾é€’å½’ä¼˜åŒ–ï¼Œä½¿å…¶æˆä¸ºæ›´æ¥è¿‘ Lambda Calculus çš„è¯­è¨€ã€‚**

------

#### **4. MLï¼šå¼ºç±»å‹ä¸æ¨¡å¼åŒ¹é…**

#### **4.1 ML è¯­è¨€æ¦‚è¿°**

MLï¼ˆMetaLanguageï¼‰è¯ç”Ÿäº **1973 å¹´**ï¼Œä¸»è¦ç”¨äº**è‡ªåŠ¨å®šç†è¯æ˜**ï¼Œæ˜¯æœ€æ—©æ”¯æŒ **é™æ€ç±»å‹æ¨å¯¼ï¼ˆType Inferenceï¼‰** çš„å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ã€‚
 ML çš„ç‰¹ç‚¹ï¼š

- **åŸºäº Lambda Calculus è®¾è®¡**
- **é™æ€ç±»å‹æ¨å¯¼ï¼ˆHindley-Milner Type Inferenceï¼‰**
- **æ¨¡å¼åŒ¹é…ï¼ˆPattern Matchingï¼‰**
- **æ¨¡å—ç³»ç»Ÿï¼ˆModule Systemï¼‰**
- **æ”¯æŒæŸ¯é‡ŒåŒ–ï¼ˆCurryingï¼‰**

#### **4.2 ML çš„ Lambda è®¡ç®—**

ML ä»£ç ï¼š

```ml
fun square x = x * x;

val lambda_square = fn x => x * x;
```

ğŸ’¡ **ML å…è®¸ç›´æ¥ä½¿ç”¨ `fn x => x \* x` è¡¨ç¤º Lambda è¡¨è¾¾å¼ï¼Œç›¸å½“äº Lambda Calculus ä¸­çš„ `Î»x. x \* x`ã€‚**

#### **4.3 ML çš„ç±»å‹æ¨å¯¼**

ML å¯ä»¥è‡ªåŠ¨æ¨å¯¼ `square` çš„ç±»å‹ï¼š

```ml
val square : int -> int
```

ğŸ’¡ **ML çš„ç±»å‹æ¨å¯¼æœºåˆ¶ç›´æ¥åŸºäº Lambda Calculus çš„ç±»å‹ç³»ç»Ÿï¼ˆSimply Typed Lambda Calculus, STLCï¼‰ã€‚**

------

#### **5. Haskellï¼šçº¯å‡½æ•°å¼è¯­è¨€çš„å…¸èŒƒ**

#### **5.1 Haskell è¯­è¨€æ¦‚è¿°**

Haskell æ˜¯ **1990 å¹´** è®¾è®¡çš„ **çº¯å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€**ï¼Œå®ƒçš„æ ¸å¿ƒç‰¹ç‚¹ï¼š

- **ä¸€åˆ‡éƒ½æ˜¯ Lambda è¡¨è¾¾å¼**
- **å®Œå…¨åŸºäºæƒ°æ€§æ±‚å€¼ï¼ˆLazy Evaluationï¼‰**
- **å¼ºç±»å‹ç³»ç»Ÿï¼ˆStatic Type Systemï¼‰**
- **æ”¯æŒé«˜é˜¶å‡½æ•°ã€æŸ¯é‡ŒåŒ–**
- **Monad ç”¨äºå‰¯ä½œç”¨ç®¡ç†**

#### **5.2 Haskell çš„ Lambda è®¡ç®—**

Haskell ä»£ç ï¼š

```haskell
square :: Int -> Int
square x = x * x

lambda_square = \x -> x * x
```

ğŸ’¡ **Haskell ä¸­çš„ `\x -> x \* x` å°±æ˜¯ Lambda Calculus ç›´æ¥çš„è¯­æ³•å®ç°ã€‚**

#### **5.3 Haskell çš„é«˜é˜¶å‡½æ•°**

Haskell æ”¯æŒ **é«˜é˜¶å‡½æ•°** å’Œ **æŸ¯é‡ŒåŒ–**ï¼Œä¾‹å¦‚ï¼š

```haskell
add :: Int -> Int -> Int
add x y = x + y

addCurried = \x -> (\y -> x + y)
```

ğŸ’¡ **Haskell çš„æŸ¯é‡ŒåŒ–å‡½æ•°ç›´æ¥å¯¹åº” Lambda Calculus ä¸­çš„åµŒå¥— Lambda è¡¨è¾¾å¼ã€‚**

------

#### **6. è¯­è¨€è®¾è®¡çš„æ¯”è¾ƒ**

| **è¯­è¨€**    | **Lambda Calculus å½±å“** | **ä¸»è¦ç‰¹ç‚¹**               |
| ----------- | ------------------------ | -------------------------- |
| **Lisp**    | ç›´æ¥åŸºäº Lambda Calculus | çº¯ç¬¦å·è®¡ç®—ã€åŠ¨æ€ç±»å‹       |
| **Scheme**  | å¼ºåŒ– Lambda è®¡ç®—         | æ”¯æŒå°¾é€’å½’ã€CPS            |
| **ML**      | å¼ºç±»å‹ Lambda è®¡ç®—       | ç±»å‹æ¨å¯¼ã€æ¨¡å¼åŒ¹é…         |
| **Haskell** | çº¯å‡½æ•°å¼ Lambda è®¡ç®—     | æƒ°æ€§æ±‚å€¼ã€Monad å¤„ç†å‰¯ä½œç”¨ |

ğŸ’¡ **Haskell æ˜¯æœ€çº¯ç²¹çš„ Lambda è¯­è¨€ï¼Œè€Œ Lisp æ˜¯æœ€æ—©çš„ Lambda è¯­è¨€ã€‚**

------

#### **æ€»ç»“**

- **Lambda Calculus æ·±åˆ»å½±å“äº†å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€**
- **Lisp æ˜¯ç¬¬ä¸€ä¸ªæ”¯æŒ Lambda è®¡ç®—çš„ç¼–ç¨‹è¯­è¨€**
- **Scheme è¿›ä¸€æ­¥å¼ºåŒ–äº†é€’å½’å’Œå°¾é€’å½’ä¼˜åŒ–**
- **ML ç»“åˆ Lambda Calculus å’Œå¼ºç±»å‹æ¨å¯¼**
- **Haskell é‡‡ç”¨æœ€çº¯ç²¹çš„å‡½æ•°å¼è®¡ç®—æ¨¡å‹**

### **7.1.2 å‡½æ•°æ˜¯ä¸€ç­‰å…¬æ°‘çš„æ¦‚å¿µ**

åœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­ï¼Œ**å‡½æ•°æ˜¯ä¸€ç­‰å…¬æ°‘ï¼ˆFirst-Class Citizenï¼‰**ï¼Œè¿™æ„å‘³ç€ï¼š

- **å‡½æ•°å¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’**
- **å‡½æ•°å¯ä»¥ä½œä¸ºè¿”å›å€¼**
- **å¯ä»¥åœ¨è¿è¡Œæ—¶åˆ›å»ºå’Œæ“ä½œå‡½æ•°**
- **å¯ä»¥å°†å‡½æ•°å­˜å‚¨åœ¨å˜é‡ä¸­**
- **å¯ä»¥å°†å‡½æ•°å­˜å‚¨åœ¨æ•°æ®ç»“æ„ï¼ˆå¦‚åˆ—è¡¨ã€å…ƒç»„ï¼‰ä¸­**

è¿™ä¸€æ¦‚å¿µç›´æ¥æ¥æºäº **Lambda Calculus**ï¼Œå¹¶åœ¨ **Lispã€Schemeã€Haskellã€ML** ç­‰å‡½æ•°å¼è¯­è¨€ä¸­å¾—åˆ°äº†å¹¿æ³›åº”ç”¨ã€‚ç›¸è¾ƒäºå‘½ä»¤å¼ç¼–ç¨‹ï¼ˆImperative Programmingï¼‰ï¼Œè¿™ç§ç‰¹æ€§ä½¿å¾—**é«˜é˜¶å‡½æ•°ï¼ˆHigher-Order Functionsï¼‰**ã€**æŸ¯é‡ŒåŒ–ï¼ˆCurryingï¼‰**ã€**å‡½æ•°ç»„åˆï¼ˆFunction Compositionï¼‰** ç­‰æŠ€æœ¯æˆä¸ºå¯èƒ½ã€‚

æœ¬èŠ‚å°†æ¢è®¨ï¼š

1. **ä¸ºä»€ä¹ˆå‡½æ•°æ˜¯ä¸€ç­‰å…¬æ°‘**
2. **ä¸€ç­‰å…¬æ°‘ vs. é«˜é˜¶å‡½æ•°**
3. **åœ¨ä¸åŒç¼–ç¨‹è¯­è¨€ä¸­çš„ä½“ç°**
4. **å‡½æ•°å¼ç¼–ç¨‹çš„ä¼˜åŠ¿**
5. **ä»£ç ç¤ºä¾‹ï¼šä½¿ç”¨ Haskell å’Œ Python è¿›è¡Œå‡½æ•°æ“ä½œ**

------

#### **1. ä¸ºä»€ä¹ˆå‡½æ•°æ˜¯ä¸€ç­‰å…¬æ°‘ï¼Ÿ**

åœ¨å¤§å¤šæ•°å‘½ä»¤å¼è¯­è¨€ï¼ˆå¦‚ Cã€Javaï¼‰ä¸­ï¼Œ**å‡½æ•°ä¸æ˜¯ä¸€ç­‰å…¬æ°‘**ï¼Œå®ƒä»¬é€šå¸¸ï¼š

- **ä¸èƒ½ä½œä¸ºå‚æ•°ä¼ é€’**
- **ä¸èƒ½ç›´æ¥èµ‹å€¼ç»™å˜é‡**
- **ä¸èƒ½åœ¨è¿è¡Œæ—¶åŠ¨æ€åˆ›å»º**

ä½†åœ¨ **Lambda Calculus** å’Œ **å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€** ä¸­ï¼Œå‡½æ•°è¢«èµ‹äºˆäº† **å®Œå…¨çš„æ“ä½œè‡ªç”±**ï¼Œå¯ä»¥åƒå˜é‡ä¸€æ ·ä½¿ç”¨ã€‚

ğŸ’¡ **å‡½æ•°ä½œä¸ºä¸€ç­‰å…¬æ°‘ï¼Œä½¿å¾—å‡½æ•°å¼ç¼–ç¨‹æ›´åŠ çµæ´»ã€å¯ç»„åˆã€å¯é‡ç”¨ã€‚**

------

#### **2. ä¸€ç­‰å…¬æ°‘ vs. é«˜é˜¶å‡½æ•°**

**ä¸€ç­‰å…¬æ°‘** æŒ‡çš„æ˜¯ **å‡½æ•°æœ¬èº«å¯ä»¥åƒæ•°æ®ä¸€æ ·è¢«æ“ä½œ**ï¼Œè€Œ **é«˜é˜¶å‡½æ•°ï¼ˆHigher-Order Functionï¼‰** æ˜¯æŒ‡ **æ¥å—å‡½æ•°ä½œä¸ºå‚æ•°ï¼Œæˆ–è¿”å›å‡½æ•°çš„å‡½æ•°**ã€‚

| **æ¦‚å¿µ**     | **å®šä¹‰**                           |
| ------------ | ---------------------------------- |
| **ä¸€ç­‰å…¬æ°‘** | å‡½æ•°å¯ä»¥åƒå˜é‡ä¸€æ ·å­˜å‚¨ã€ä¼ é€’ã€è¿”å› |
| **é«˜é˜¶å‡½æ•°** | æ¥å—å‡½æ•°ä½œä¸ºå‚æ•°æˆ–è¿”å›å‡½æ•°çš„å‡½æ•°   |

#### **ç¤ºä¾‹ï¼šä¸€ç­‰å…¬æ°‘**

```haskell
-- Haskell: å‡½æ•°èµ‹å€¼ç»™å˜é‡
square :: Int -> Int
square x = x * x

f = square   -- å‡½æ•°å¯ä»¥èµ‹å€¼ç»™å˜é‡
print (f 5)  -- è¾“å‡º 25
```

#### **ç¤ºä¾‹ï¼šé«˜é˜¶å‡½æ•°**

```haskell
-- Haskell: é«˜é˜¶å‡½æ•°
applyTwice :: (a -> a) -> a -> a
applyTwice f x = f (f x)

double x = x * 2

print (applyTwice double 3)  -- 12
```

ğŸ’¡ **æ‰€æœ‰é«˜é˜¶å‡½æ•°éƒ½éœ€è¦å‡½æ•°æ˜¯ä¸€ç­‰å…¬æ°‘ï¼Œä½†ä¸€ç­‰å…¬æ°‘çš„å‡½æ•°ä¸ä¸€å®šæ˜¯é«˜é˜¶å‡½æ•°ï¼**

------

#### **3. åœ¨ä¸åŒç¼–ç¨‹è¯­è¨€ä¸­çš„ä½“ç°**

#### **3.1 Lispï¼šæœ€æ—©æ”¯æŒä¸€ç­‰å…¬æ°‘å‡½æ•°çš„è¯­è¨€**

Lisp æ˜¯æœ€æ—©æ”¯æŒ **Lambda è¡¨è¾¾å¼** å’Œ **å‡½æ•°å¼è®¡ç®—** çš„è¯­è¨€ï¼Œå®ƒå…è®¸ï¼š

- **å‡½æ•°èµ‹å€¼ç»™å˜é‡**
- **å‡½æ•°ä½œä¸ºå‚æ•°ä¼ é€’**
- **è¿”å›åŒ¿åå‡½æ•°**

#### **Lisp ä»£ç ç¤ºä¾‹**

```lisp
(defun square (x) (* x x))

(setq f square)  ;; èµ‹å€¼å‡½æ•°
(print (funcall f 5))  ;; è¾“å‡º 25
```

ğŸ’¡ **Lisp æ˜¯æœ€æ—©å®Œå…¨å®ç°å‡½æ•°ä½œä¸ºä¸€ç­‰å…¬æ°‘çš„è¯­è¨€ï¼**

------

#### **3.2 Schemeï¼šè¿›ä¸€æ­¥å¼ºåŒ–é«˜é˜¶å‡½æ•°**

Scheme è¿›ä¸€æ­¥æ‰©å±•äº† **å‡½æ•°æ˜¯ä¸€ç­‰å…¬æ°‘** çš„èƒ½åŠ›ï¼Œä½¿å¾—é«˜é˜¶å‡½æ•°æˆä¸ºæ ¸å¿ƒç‰¹æ€§ã€‚

#### **Scheme ä»£ç ç¤ºä¾‹**

```scheme
(define (apply-twice f x)
  (f (f x)))

(define (double x) (* x 2))

(display (apply-twice double 3))  ;; è¾“å‡º 12
```

ğŸ’¡ **Scheme é€šè¿‡ `apply-twice` æ¼”ç¤ºäº†é«˜é˜¶å‡½æ•°çš„å¼ºå¤§èƒ½åŠ›ã€‚**

------

#### **3.3 Haskellï¼šçº¯å‡½æ•°å¼ç¼–ç¨‹çš„æœ€ä½³å®ç°**

Haskell å…è®¸ **åŒ¿åå‡½æ•°ã€å‡½æ•°ä½œä¸ºå‚æ•°å’Œè¿”å›å€¼ã€æŸ¯é‡ŒåŒ–**ï¼Œè¿›ä¸€æ­¥å¼ºåŒ–äº† **å‡½æ•°ä½œä¸ºä¸€ç­‰å…¬æ°‘** çš„èƒ½åŠ›ã€‚

#### **Haskell ä»£ç ç¤ºä¾‹**

```haskell
-- Haskell é«˜é˜¶å‡½æ•°ç¤ºä¾‹
twice :: (a -> a) -> a -> a
twice f x = f (f x)

double x = x * 2
print (twice double 3)  -- 12
```

ğŸ’¡ **Haskell é€šè¿‡æŸ¯é‡ŒåŒ–å’Œé«˜é˜¶å‡½æ•°ï¼Œæœ€å¤§åŒ–äº†å‡½æ•°çš„å¯ç»„åˆæ€§ã€‚**

------

#### **3.4 Pythonï¼šåœ¨å‘½ä»¤å¼è¯­è¨€ä¸­æ”¯æŒä¸€ç­‰å…¬æ°‘å‡½æ•°**

Python å¹¶ä¸æ˜¯ **çº¯å‡½æ•°å¼è¯­è¨€**ï¼Œä½†å®ƒæ”¯æŒ **å‡½æ•°ä½œä¸ºä¸€ç­‰å…¬æ°‘**ï¼Œå…è®¸ä¼ é€’å’Œè¿”å›å‡½æ•°ã€‚

#### **Python ä»£ç ç¤ºä¾‹**

```python
def square(x):
    return x * x

f = square  # èµ‹å€¼å‡½æ•°
print(f(5))  # è¾“å‡º 25

def apply_twice(f, x):
    return f(f(x))

print(apply_twice(lambda x: x * 2, 3))  # 12
```

ğŸ’¡ **å³ä½¿æ˜¯ Python è¿™æ ·çš„å‘½ä»¤å¼è¯­è¨€ï¼Œä¹Ÿæ”¯æŒ Lambda è®¡ç®—å’Œé«˜é˜¶å‡½æ•°ã€‚**

------

#### **4. å‡½æ•°å¼ç¼–ç¨‹çš„ä¼˜åŠ¿**

å‡½æ•°ä½œä¸ºä¸€ç­‰å…¬æ°‘å¸¦æ¥äº†å¤šä¸ªä¼˜åŠ¿ï¼š

- **ä»£ç æ›´å…·å¯ç»„åˆæ€§**ï¼ˆComposabilityï¼‰ï¼šå¯ä»¥è‡ªç”±ç»„åˆå‡½æ•°ï¼Œé¿å…é‡å¤ä»£ç 
- **æé«˜å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§**ï¼ˆReadability & Maintainabilityï¼‰ï¼šå‡½æ•°æ“ä½œæ›´ç›´è§‚
- **æ”¯æŒæƒ°æ€§æ±‚å€¼**ï¼ˆLazy Evaluationï¼‰ï¼šå¦‚ Haskell åªåœ¨å¿…è¦æ—¶æ‰§è¡Œè®¡ç®—
- **é¿å…å‰¯ä½œç”¨**ï¼ˆNo Side Effectsï¼‰ï¼šå‡½æ•°ä¸ä¼šä¿®æ”¹å¤–éƒ¨çŠ¶æ€ï¼Œæé«˜å¹¶è¡Œè®¡ç®—èƒ½åŠ›

ğŸ’¡ **è¿™ä½¿å¾—å‡½æ•°å¼ç¼–ç¨‹åœ¨å¹¶è¡Œè®¡ç®—ã€åˆ†å¸ƒå¼è®¡ç®—ã€æ•°å­¦å»ºæ¨¡ã€ç¼–è¯‘å™¨ä¼˜åŒ–ç­‰é¢†åŸŸæœ‰å¹¿æ³›åº”ç”¨ã€‚**

------

#### **5. ä»£ç ç¤ºä¾‹ï¼šHaskell vs Python**

è®©æˆ‘ä»¬çœ‹ä¸€ä¸ª **Haskell å’Œ Python** çš„å¯¹æ¯”ç¤ºä¾‹ï¼Œæ¼”ç¤º **å‡½æ•°ä½œä¸ºä¸€ç­‰å…¬æ°‘**ã€‚

#### **Haskell**

```haskell
applyTwice :: (a -> a) -> a -> a
applyTwice f x = f (f x)

double x = x * 2
print (applyTwice double 3)  -- 12
```

#### **Python**

```python
def apply_twice(f, x):
    return f(f(x))

def double(x):
    return x * 2

print(apply_twice(double, 3))  # 12
```

ğŸ’¡ **ä¸¤ç§è¯­è¨€éƒ½å¯ä»¥çµæ´»åœ°æ“ä½œå‡½æ•°ï¼Œå¹¶å°†å‡½æ•°ä½œä¸ºå‚æ•°ä¼ é€’ã€‚**

------

#### **æ€»ç»“**

| **ç‰¹æ€§**           | **Lisp** | **Scheme** | **Haskell** | **Python** |
| ------------------ | -------- | ---------- | ----------- | ---------- |
| **åŒ¿åå‡½æ•°**       | âœ…        | âœ…          | âœ…           | âœ…          |
| **å‡½æ•°ä½œä¸ºå‚æ•°**   | âœ…        | âœ…          | âœ…           | âœ…          |
| **å‡½æ•°ä½œä¸ºè¿”å›å€¼** | âœ…        | âœ…          | âœ…           | âœ…          |
| **é«˜é˜¶å‡½æ•°**       | âœ…        | âœ…          | âœ…           | âœ…          |
| **æŸ¯é‡ŒåŒ–**         | âŒ        | âœ…          | âœ…           | âŒ          |
| **æƒ°æ€§æ±‚å€¼**       | âŒ        | âŒ          | âœ…           | âŒ          |

- **Lambda Calculus èµ‹äºˆäº†å‡½æ•°â€œä¸€ç­‰å…¬æ°‘â€çš„æ¦‚å¿µ**
- **Haskell æœ€å®Œç¾åœ°å®ç°äº†è¿™ä¸€æ¦‚å¿µ**
- **Python ç­‰å‘½ä»¤å¼è¯­è¨€ä¹Ÿé€æ¸æ”¯æŒå‡½æ•°å¼ç‰¹æ€§**
- **é«˜é˜¶å‡½æ•°å’ŒæŸ¯é‡ŒåŒ–æ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„æ ¸å¿ƒ**

### **7.2.1 å‡½æ•°å®šä¹‰ä¸åŒ¿åå‡½æ•°**

åœ¨ **Haskell**ï¼ˆä»¥åŠå…¶ä»–å— Lambda Calculus å½±å“çš„å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ï¼‰ä¸­ï¼Œ**å‡½æ•°çš„å®šä¹‰** æ˜¯ç¼–ç¨‹çš„æ ¸å¿ƒï¼Œè€Œ **åŒ¿åå‡½æ•°ï¼ˆLambda å‡½æ•°ï¼‰** æä¾›äº†ä¸€ç§çµæ´»çš„æ–¹å¼æ¥å®šä¹‰ **ä¸´æ—¶å‡½æ•°**ï¼Œé¿å…å‘½åå†²çªï¼Œå¹¶å¢å¼ºä»£ç çš„è¡¨è¾¾èƒ½åŠ›ã€‚

åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ¢è®¨ï¼š

1. **Haskell ä¸­çš„åŸºæœ¬å‡½æ•°å®šä¹‰**
2. **åŒ¿åå‡½æ•°ï¼ˆLambda è¡¨è¾¾å¼ï¼‰çš„è¯­æ³•**
3. **åŒ¿åå‡½æ•°çš„åº”ç”¨**
4. **åŒ¿åå‡½æ•° vs. å‘½åå‡½æ•°**
5. **ä»£ç ç¤ºä¾‹ï¼šé«˜é˜¶å‡½æ•°ä¸­çš„ Lambda è¡¨è¾¾å¼**
6. **åŒ¿åå‡½æ•°çš„ä¼˜åŒ–ç­–ç•¥**

------

#### **1. Haskell ä¸­çš„åŸºæœ¬å‡½æ•°å®šä¹‰**

åœ¨ Haskell ä¸­ï¼Œ**å‡½æ•°å®šä¹‰** æ˜¯åŸºäº **æ¨¡å¼åŒ¹é…** å’Œ **è¡¨è¾¾å¼** çš„ï¼Œä¾‹å¦‚ï¼š

```haskell
square :: Int -> Int
square x = x * x
```

#### **1.1 è§£æ**

- **`square :: Int -> Int`**ï¼šå£°æ˜ `square` æ˜¯ä¸€ä¸ª **æ¥å— `Int` å¹¶è¿”å› `Int`** çš„å‡½æ•°
- **`square x = x \* x`**ï¼šå®šä¹‰ `square` è®¡ç®— `x * x`

ğŸ’¡ **Haskell çš„å‡½æ•°å®šä¹‰éµå¾ª Lambda Calculus çš„æ€æƒ³ï¼Œæ‰€æœ‰å‡½æ•°éƒ½æ˜¯ Lambda è¡¨è¾¾å¼çš„ç®€å†™ï¼**

å®é™…ä¸Šï¼Œä¸Šè¿°å®šä¹‰å¯ä»¥ç›´æ¥å†™æˆï¼š

```haskell
square = \x -> x * x
```

è¿™å°±æ˜¯ **åŒ¿åå‡½æ•°ï¼ˆLambda è¡¨è¾¾å¼ï¼‰**ï¼

------

#### **2. åŒ¿åå‡½æ•°ï¼ˆLambda è¡¨è¾¾å¼ï¼‰çš„è¯­æ³•**

åœ¨ Haskell ä¸­ï¼Œ**åŒ¿åå‡½æ•°**ï¼ˆAnonymous Functionsï¼‰ä¹Ÿè¢«ç§°ä¸º **Lambda è¡¨è¾¾å¼ï¼ˆLambda Expressionsï¼‰**ï¼Œä½¿ç”¨ **`\`ï¼ˆåæ–œæ ï¼‰** ä½œä¸º Lambda å…³é”®å­—ï¼š

```haskell
\x -> x * x
```

#### **2.1 è¯­æ³•è§£æ**

- **`\x`** ä»£è¡¨ **Lambda å˜é‡** `x`
- **`->`** ä»£è¡¨ **Lambda ä½“ï¼ˆBodyï¼‰**
- **`x \* x`** ä»£è¡¨ **è®¡ç®—è¡¨è¾¾å¼**

#### **ç¤ºä¾‹ï¼šä½¿ç”¨åŒ¿åå‡½æ•°è®¡ç®—å¹³æ–¹**

```haskell
(\x -> x * x) 5  -- è¾“å‡º 25
```

ğŸ’¡ **åŒ¿åå‡½æ•°å¯ä»¥åœ¨ä¸å‘½åçš„æƒ…å†µä¸‹ç›´æ¥ä½¿ç”¨ï¼Œé€‚ç”¨äºä¸´æ—¶è®¡ç®—ã€‚**

------

#### **3. åŒ¿åå‡½æ•°çš„åº”ç”¨**

åŒ¿åå‡½æ•°åœ¨ **å‡½æ•°å¼ç¼–ç¨‹** ä¸­è¢«å¹¿æ³›ç”¨äºï¼š

- **ä¼ é€’ç»™é«˜é˜¶å‡½æ•°**
- **é¿å…æ˜¾å¼å‘½å**
- **å‡å°‘å˜é‡ä½œç”¨åŸŸæ±¡æŸ“**
- **ç®€åŒ–ä¸€æ¬¡æ€§ä½¿ç”¨çš„å‡½æ•°**

#### **3.1 ä¼ é€’åŒ¿åå‡½æ•°ä½œä¸ºå‚æ•°**

```haskell
map (\x -> x * 2) [1,2,3,4]  -- è¾“å‡º [2,4,6,8]
```

ğŸ’¡ **Lambda ç›´æ¥ç”¨äº `map` å‡½æ•°ï¼Œæ— éœ€æ˜¾å¼å‘½åå‡½æ•°ï¼**

#### **3.2 ä½œä¸ºè¿”å›å€¼**

```haskell
generateMultiplier :: Int -> (Int -> Int)
generateMultiplier n = \x -> x * n

double = generateMultiplier 2
print (double 10)  -- è¾“å‡º 20
```

ğŸ’¡ **è¿”å›ä¸€ä¸ªåŒ¿åå‡½æ•°ï¼Œå®ç°â€œéƒ¨åˆ†åº”ç”¨â€çš„æ•ˆæœã€‚**

------

#### **4. åŒ¿åå‡½æ•° vs. å‘½åå‡½æ•°**

| **ç‰¹æ€§**           | **å‘½åå‡½æ•°** | **åŒ¿åå‡½æ•°ï¼ˆLambdaï¼‰** |
| ------------------ | ------------ | ---------------------- |
| **æ˜¯å¦éœ€è¦åç§°**   | éœ€è¦         | ä¸éœ€è¦                 |
| **é€‚ç”¨åœºæ™¯**       | éœ€è¦å¤šæ¬¡å¤ç”¨ | åªä½¿ç”¨ä¸€æ¬¡             |
| **å¯è¯»æ€§**         | é«˜           | é€‚ä¸­                   |
| **é€‚ç”¨äºé«˜é˜¶å‡½æ•°** | âœ…            | âœ…                      |
| **é€‚ç”¨äºé€’å½’**     | âœ…            | âŒï¼ˆé€šå¸¸ï¼‰              |

#### **ç¤ºä¾‹ï¼šåŒ¿åå‡½æ•° vs. å‘½åå‡½æ•°**

```haskell
-- å‘½åå‡½æ•°
square x = x * x
map square [1,2,3,4]

-- åŒ¿åå‡½æ•°
map (\x -> x * x) [1,2,3,4]
```

ğŸ’¡ **å½“å‡½æ•°åªä½¿ç”¨ä¸€æ¬¡æ—¶ï¼ŒåŒ¿åå‡½æ•°æ›´ç®€æ´ï¼›å½“å‡½æ•°éœ€è¦å¤ç”¨æ—¶ï¼Œå‘½åå‡½æ•°æ›´åˆé€‚ã€‚**

------

#### **5. ä»£ç ç¤ºä¾‹ï¼šé«˜é˜¶å‡½æ•°ä¸­çš„ Lambda è¡¨è¾¾å¼**

åŒ¿åå‡½æ•°æœ€å¸¸è§çš„åº”ç”¨æ˜¯åœ¨ **é«˜é˜¶å‡½æ•°**ï¼ˆHigher-Order Functionsï¼‰ä¸­ã€‚

#### **5.1 ä¾‹å­ï¼šä½¿ç”¨ Lambda è¿‡æ»¤åˆ—è¡¨**

```haskell
filter (\x -> x `mod` 2 == 0) [1,2,3,4,5,6]  -- è¾“å‡º [2,4,6]
```

ğŸ’¡ **`filter` ç»“åˆ Lambda ä½¿ä»£ç æ›´æ¸…æ™°ï¼Œæ— éœ€å®šä¹‰é¢å¤–çš„ `isEven` å‡½æ•°ã€‚**

#### **5.2 ä¾‹å­ï¼šLambda ä½œä¸º `foldl` çš„ç´¯åŠ å‡½æ•°**

```haskell
foldl (\acc x -> acc + x) 0 [1,2,3,4,5]  -- è¾“å‡º 15
```

ğŸ’¡ **Lambda è¡¨è¾¾å¼ä½œä¸º `foldl` çš„ç´¯åŠ å™¨ï¼Œé¿å…é¢å¤–å‡½æ•°å®šä¹‰ã€‚**

------

#### **6. åŒ¿åå‡½æ•°çš„ä¼˜åŒ–ç­–ç•¥**

å°½ç®¡åŒ¿åå‡½æ•°æä¾›äº†å¼ºå¤§çš„è¡¨è¾¾èƒ½åŠ›ï¼Œä½†åœ¨æŸäº›æƒ…å†µä¸‹ï¼ŒåŒ¿åå‡½æ•°å¯èƒ½ä¼šå½±å“æ€§èƒ½æˆ–å¯è¯»æ€§ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ **ä¼˜åŒ–ç­–ç•¥** æ¥æå‡æ•ˆç‡ã€‚

#### **6.1 å†…è”å±•å¼€ï¼ˆInliningï¼‰**

å¦‚æœåŒ¿åå‡½æ•°å¾ˆçŸ­ï¼Œå¯ä»¥ç›´æ¥**å†…è”å±•å¼€**ï¼Œé¿å…å‡½æ•°è°ƒç”¨çš„é¢å¤–å¼€é”€ã€‚

```haskell
map (\x -> x + 1) [1,2,3]  
```

å¯ç›´æ¥ä¼˜åŒ–ä¸ºï¼š

```haskell
map (+1) [1,2,3]  
```

ğŸ’¡ **`(+1)` æœ¬èº«å°±æ˜¯ä¸€ä¸ªéƒ¨åˆ†åº”ç”¨å‡½æ•°ï¼Œç­‰ä»·äº `\x -> x + 1`ï¼Œå¯ä»¥ç›´æ¥æ›¿æ¢ï¼**

------

#### **6.2 é¿å…ä¸å¿…è¦çš„ Lambda æ•è·**

å¦‚æœ Lambda è¡¨è¾¾å¼**ä¸éœ€è¦é—­åŒ…å˜é‡**ï¼Œå¯ä»¥é¿å…ä¸å¿…è¦çš„è®¡ç®—å¼€é”€ï¼š

```haskell
-- ä½æ•ˆï¼šLambda æ•è·å¤–éƒ¨å˜é‡ n
let n = 2 in map (\x -> x * n) [1,2,3,4]
```

ä¼˜åŒ–ä¸ºï¼š

```haskell
let double = (*2) in map double [1,2,3,4]
```

ğŸ’¡ **é¿å…é—­åŒ…æ•è·ï¼Œæé«˜æ±‚å€¼æ•ˆç‡ã€‚**

------

#### **6.3 é€‚å½“ä½¿ç”¨å‘½åå‡½æ•°**

å¦‚æœ Lambda è¡¨è¾¾å¼å¤ªé•¿ï¼Œå»ºè®®**æå–ä¸ºå‘½åå‡½æ•°**ï¼Œæé«˜ä»£ç å¯è¯»æ€§ï¼š

```haskell
-- ä½å¯è¯»æ€§ï¼š
map (\x -> if x `mod` 2 == 0 then x * 2 else x) [1,2,3,4,5]

-- ä¼˜åŒ–ï¼š
doubleEven x = if x `mod` 2 == 0 then x * 2 else x
map doubleEven [1,2,3,4,5]
```

ğŸ’¡ **é¿å…å¤æ‚ Lambda è¡¨è¾¾å¼ï¼Œæé«˜å¯è¯»æ€§ã€‚**

------

#### **æ€»ç»“**

| **æ¦‚å¿µ**                | **ç¤ºä¾‹**                             | **ä½œç”¨**     |
| ----------------------- | ------------------------------------ | ------------ |
| **åŒ¿åå‡½æ•°ï¼ˆLambdaï¼‰**  | `\x -> x * x`                        | å®šä¹‰ä¸´æ—¶å‡½æ•° |
| **Lambda ä¼ é€’ç»™ `map`** | `map (\x -> x * 2) [1,2,3]`          | é¿å…æ˜¾å¼å‘½å |
| **Lambda ä½œä¸ºè¿”å›å€¼**   | `generateMultiplier n = \x -> x * n` | ç”ŸæˆåŠ¨æ€å‡½æ•° |
| **Lambda ä¸ `filter`**  | `filter (\x -> x `mod` 2 == 0) list` | è¿‡æ»¤åˆ—è¡¨     |
| **Lambda ä¸ `foldl`**   | `foldl (\acc x -> acc + x) 0 list`   | ç´¯åŠ è®¡ç®—     |
| **Lambda ä¼˜åŒ–**         | `map (+1) list`                      | é¿å…å†—ä½™é—­åŒ… |

- **Lambda è¡¨è¾¾å¼æ˜¯ Haskell å’Œå‡½æ•°å¼ç¼–ç¨‹çš„æ ¸å¿ƒ**
- **åŒ¿åå‡½æ•°æé«˜ä»£ç çµæ´»æ€§ï¼Œä½†å¯èƒ½å½±å“å¯è¯»æ€§**
- **ä¼˜åŒ–ç­–ç•¥åŒ…æ‹¬å†…è”å±•å¼€ã€é¿å…é—­åŒ…æ•è·ã€é€‚å½“ä½¿ç”¨å‘½åå‡½æ•°**
- **é«˜é˜¶å‡½æ•°ï¼ˆmap, filter, foldï¼‰æ˜¯ Lambda è¡¨è¾¾å¼çš„æœ€ä½³åº”ç”¨åœºæ™¯**

åœ¨ä¸‹ä¸€èŠ‚ï¼Œæˆ‘ä»¬å°†æ¢è®¨ **Haskell ä¸­çš„ç±»å‹æ¨æ–­ï¼ˆType Inferenceï¼‰**ï¼Œä»¥åŠ **å¦‚ä½•è‡ªåŠ¨æ¨å¯¼ Lambda è¡¨è¾¾å¼çš„ç±»å‹**ï¼ğŸš€

### **7.2.2 ç±»å‹æ¨æ–­ï¼ˆType Inferenceï¼‰**

Haskell é‡‡ç”¨ **é™æ€ç±»å‹ç³»ç»Ÿ**ï¼Œä½†ä¸åŒäº Cã€Java ç­‰è¯­è¨€éœ€è¦æ˜¾å¼å£°æ˜ç±»å‹ï¼ŒHaskell **èƒ½å¤Ÿè‡ªåŠ¨æ¨å¯¼å‡½æ•°å’Œè¡¨è¾¾å¼çš„ç±»å‹**ï¼Œè¿™è¢«ç§°ä¸º **ç±»å‹æ¨æ–­ï¼ˆType Inferenceï¼‰**ã€‚Haskell çš„ç±»å‹æ¨å¯¼ç³»ç»ŸåŸºäº **Hindley-Milnerï¼ˆHMï¼‰ç±»å‹æ¨å¯¼ç®—æ³•**ï¼Œä½¿å¾—ç¨‹åºå‘˜åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ä¸å¿…æ‰‹åŠ¨æŒ‡å®šç±»å‹ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨æ¨æ–­åˆé€‚çš„ç±»å‹ã€‚

æœ¬èŠ‚å°†æ¢è®¨ï¼š

1. **ä»€ä¹ˆæ˜¯ç±»å‹æ¨æ–­ï¼Ÿ**
2. **Haskell çš„ç±»å‹æ¨æ–­è¿‡ç¨‹**
3. **å¤šæ€ç±»å‹ä¸æ³›å‹**
4. **ç±»å‹æ¨æ–­çš„é™åˆ¶**
5. **ä»£ç ç¤ºä¾‹ï¼šHaskell å¦‚ä½•æ¨å¯¼ Lambda è¡¨è¾¾å¼çš„ç±»å‹**
6. **ä¼˜åŒ–ä¸æœ€ä½³å®è·µ**

------

#### **1. ä»€ä¹ˆæ˜¯ç±»å‹æ¨æ–­ï¼Ÿ**

ç±»å‹æ¨æ–­ï¼ˆType Inferenceï¼‰æ˜¯ä¸€ç§ç¼–è¯‘å™¨æŠ€æœ¯ï¼Œå®ƒå…è®¸ **ç¼–è¯‘å™¨è‡ªåŠ¨æ¨å¯¼è¡¨è¾¾å¼çš„ç±»å‹**ï¼Œè€Œä¸éœ€è¦ç¨‹åºå‘˜æ˜¾å¼å£°æ˜ç±»å‹ã€‚

**Haskell ç±»å‹æ¨æ–­çš„ç‰¹ç‚¹**ï¼š

- **é™æ€ç±»å‹**ï¼ˆStatic Typingï¼‰ï¼šæ‰€æœ‰å˜é‡åœ¨ç¼–è¯‘æ—¶ç¡®å®šç±»å‹
- **ç±»å‹å®‰å…¨**ï¼ˆType Safetyï¼‰ï¼šé˜²æ­¢ç±»å‹é”™è¯¯
- **æ— æ˜¾å¼ç±»å‹å£°æ˜**ï¼ˆImplicit Type Inferenceï¼‰ï¼šå¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œä¸éœ€è¦æ‰‹åŠ¨æ ‡æ³¨ç±»å‹
- **æ”¯æŒå¤šæ€ï¼ˆPolymorphismï¼‰**ï¼šå¯ä»¥æ¨å¯¼å‡ºæ³›å‹ç±»å‹

ğŸ’¡ **åœ¨ Haskell ä¸­ï¼Œå³ä½¿ä¸å†™ç±»å‹ç­¾åï¼Œç¼–è¯‘å™¨ä»èƒ½è‡ªåŠ¨æ¨å¯¼å‡ºæ­£ç¡®çš„ç±»å‹ã€‚**

------

#### **2. Haskell çš„ç±»å‹æ¨æ–­è¿‡ç¨‹**

Haskell ä½¿ç”¨ **Hindley-Milnerï¼ˆHMï¼‰ç±»å‹æ¨å¯¼ç®—æ³•**ï¼Œå®ƒåŸºäº **ç±»å‹å˜é‡ï¼ˆType Variablesï¼‰** å’Œ **çº¦æŸæ±‚è§£ï¼ˆConstraint Solvingï¼‰** è¿›è¡Œæ¨å¯¼ã€‚æ¨å¯¼è¿‡ç¨‹å¦‚ä¸‹ï¼š

1. **åˆ†æå˜é‡ç±»å‹**
   - ç¡®å®šå˜é‡çš„åˆå§‹ç±»å‹ï¼ˆå¦‚ `Int`ã€`Bool`ã€`a` ç­‰ï¼‰
2. **æ„å»ºçº¦æŸï¼ˆConstraintsï¼‰**
   - ç¡®ä¿ç±»å‹ç¬¦åˆ Lambda è®¡ç®—è§„åˆ™ï¼ˆå¦‚ `f x` éœ€è¦ `f` æ˜¯ `x -> y` ç±»å‹ï¼‰
3. **æ±‚è§£ç±»å‹æ–¹ç¨‹**
   - é€šè¿‡ **ç»Ÿä¸€ç®—æ³•ï¼ˆUnification Algorithmï¼‰** è§£å†³ç±»å‹çº¦æŸ
4. **æœ€ç»ˆç”Ÿæˆæœ€ä¸€èˆ¬çš„ç±»å‹ï¼ˆMost General Type, MGTï¼‰**
   - ç”Ÿæˆ **æ³›å‹ç±»å‹**ï¼ˆå¦‚ `a -> a`ï¼‰

ğŸ’¡ **Haskell ä¼šä¸ºæ¯ä¸ªè¡¨è¾¾å¼æ‰¾åˆ°â€œæœ€é€šç”¨çš„ç±»å‹â€ï¼Œä¿è¯ä»£ç çš„çµæ´»æ€§å’Œå¯å¤ç”¨æ€§ã€‚**

------

#### **3. å¤šæ€ç±»å‹ä¸æ³›å‹**

Haskell å…è®¸ç±»å‹æ¨æ–­ **è‡ªåŠ¨æ¨å¯¼æ³›å‹ç±»å‹**ï¼Œä¾‹å¦‚ï¼š

```haskell
identity x = x
```

ç¼–è¯‘å™¨æ¨å¯¼å‡ºï¼š

```haskell
identity :: a -> a
```

è¿™é‡Œï¼š

- `a` æ˜¯ **ç±»å‹å˜é‡**ï¼Œå¯ä»¥åŒ¹é…ä»»ä½•ç±»å‹
- `identity` **é€‚ç”¨äºä»»æ„ç±»å‹çš„è¾“å…¥**

**ç¤ºä¾‹ï¼šä¸åŒç±»å‹çš„ `identity`**

```haskell
print (identity 42)      -- Int
print (identity "Hello") -- String
print (identity True)    -- Bool
```

ğŸ’¡ **Haskell è‡ªåŠ¨æ¨å¯¼å‡º `identity` æ˜¯æ³›å‹å‡½æ•°ï¼Œå¹¶é€‚ç”¨äºä»»ä½•ç±»å‹ã€‚**

------

#### **4. ç±»å‹æ¨æ–­çš„é™åˆ¶**

è™½ç„¶ Haskell çš„ç±»å‹æ¨å¯¼éå¸¸å¼ºå¤§ï¼Œä½†ä»æœ‰ä¸€äº›é™åˆ¶ï¼š

#### **4.1 æ— æ³•æ¨å¯¼å­˜åœ¨æ­§ä¹‰çš„ç±»å‹**

æŸäº›æƒ…å†µä¸‹ï¼ŒHaskell æ— æ³•è‡ªåŠ¨æ¨å¯¼ç±»å‹ï¼Œä¾‹å¦‚ï¼š

```haskell
f x = read x + 1
```

ç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼š

```
Ambiguous type variable â€˜aâ€™ arising from a use of â€˜readâ€™
```

åŸå› ï¼š

- `read x` çš„è¿”å›ç±»å‹æ˜¯ **ä¸ç¡®å®šçš„**ï¼Œå¯èƒ½æ˜¯ `Int`ã€`Double`ã€`Float`
- éœ€è¦æ˜¾å¼æŒ‡å®šç±»å‹ï¼Œä¾‹å¦‚ï¼š

```haskell
f x = (read x :: Int) + 1
```

------

#### **4.2 é«˜é˜¶å‡½æ•°çš„æ¨å¯¼**

å¯¹äºé«˜é˜¶å‡½æ•°ï¼ŒHaskell ä»ç„¶å¯ä»¥è¿›è¡Œæ¨å¯¼ï¼š

```haskell
applyTwice f x = f (f x)
```

æ¨å¯¼å‡ºï¼š

```haskell
applyTwice :: (a -> a) -> a -> a
```

è§£é‡Šï¼š

- `f` å¿…é¡»æ˜¯ **a -> a** ç±»å‹ï¼ˆå³ `f` å¿…é¡»ä½œç”¨äº `a` å¹¶è¿”å› `a`ï¼‰
- `applyTwice` æ¥å— `f` å’Œ `x`ï¼Œæœ€ç»ˆè¿”å› `x` çš„åŒç±»å‹ç»“æœ

ğŸ’¡ **Haskell èƒ½å¤Ÿè‡ªåŠ¨æ¨å¯¼å¤æ‚é«˜é˜¶å‡½æ•°çš„ç±»å‹ã€‚**

------

#### **5. ä»£ç ç¤ºä¾‹ï¼šHaskell å¦‚ä½•æ¨å¯¼ Lambda è¡¨è¾¾å¼çš„ç±»å‹**

#### **5.1 åŸºæœ¬ Lambda è¡¨è¾¾å¼**

```haskell
double = \x -> x * 2
```

Haskell è‡ªåŠ¨æ¨å¯¼ï¼š

```haskell
double :: Num a => a -> a
```

ğŸ’¡ **è¿™é‡Œ `Num a =>` ä»£è¡¨ `a` å¿…é¡»æ˜¯ `Num` ç±»å‹ç±»çš„æˆå‘˜ï¼ˆå¦‚ `Int`ã€`Double`ï¼‰ã€‚**

------

#### **5.2 é«˜é˜¶ Lambda è¡¨è¾¾å¼**

```haskell
applyFunc = \f x -> f x
```

æ¨å¯¼å‡ºï¼š

```haskell
applyFunc :: (a -> b) -> a -> b
```

ğŸ’¡ **`applyFunc` æ¥å—ä¸€ä¸ªå‡½æ•° `f` å’Œä¸€ä¸ªå‚æ•° `x`ï¼Œè¿”å› `f x`ï¼Œå¯ä»¥é€‚ç”¨äºä»»ä½•è¾“å…¥å’Œè¾“å‡ºç±»å‹ã€‚**

------

#### **5.3 ç»“åˆ `map` ä½¿ç”¨ Lambda**

```haskell
map (\x -> x + 1) [1,2,3]
```

æ¨å¯¼ï¼š

```haskell
map :: (a -> b) -> [a] -> [b]
```

ğŸ’¡ **Haskell æ¨å¯¼ `map` é€‚ç”¨äºä»»ä½• `a -> b` ç±»å‹çš„å‡½æ•°ï¼Œå¹¶æ˜ å°„åˆ°åˆ—è¡¨ä¸Šã€‚**

------

#### **6. ä¼˜åŒ–ä¸æœ€ä½³å®è·µ**

#### **6.1 æ˜¾å¼ç±»å‹ç­¾å**

å°½ç®¡ Haskell **å¯ä»¥è‡ªåŠ¨æ¨å¯¼ç±»å‹**ï¼Œä½†åœ¨å®è·µä¸­ï¼Œ**æ˜¾å¼å†™å‡ºç±»å‹ç­¾å** æœ‰åŠ©äºï¼š

- **æé«˜ä»£ç å¯è¯»æ€§**
- **è®©ç¼–è¯‘å™¨åœ¨æ—©æœŸæ£€æµ‹é”™è¯¯**
- **æ›´å¥½åœ°ä¼˜åŒ–ä»£ç **

ç¤ºä¾‹ï¼š

```haskell
double :: Num a => a -> a
double x = x * 2
```

ğŸ’¡ **æ˜¾å¼ç±»å‹ç­¾åå¯ä»¥è®©ä»£ç æ›´åŠ æ¸…æ™°ï¼Œå¹¶é˜²æ­¢ç±»å‹æ¨å¯¼é”™è¯¯ã€‚**

------

#### **6.2 ä½¿ç”¨ `:t` å‘½ä»¤æŸ¥çœ‹æ¨å¯¼çš„ç±»å‹**

åœ¨ GHCiï¼ˆHaskell REPLï¼‰ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ `:t` å‘½ä»¤æŸ¥çœ‹ç±»å‹æ¨å¯¼ï¼š

```haskell
ghci> :t (\x -> x * 2)
(\x -> x * 2) :: Num a => a -> a
```

ğŸ’¡ **å¯ä»¥éšæ—¶ç”¨ `:t` äº†è§£ Haskell å¦‚ä½•æ¨å¯¼ç±»å‹ã€‚**

------

#### **6.3 é¿å…ç±»å‹æ­§ä¹‰**

é¿å…åƒ `read x + 1` è¿™æ ·çš„ä¸æ˜ç¡®ç±»å‹ï¼Œå»ºè®®ï¼š

- **æ˜¾å¼æ ‡æ³¨ç±»å‹**
- **ä½¿ç”¨ `fromIntegral` è¿›è¡Œç±»å‹è½¬æ¢**

ç¤ºä¾‹ï¼š

```haskell
f x = fromIntegral (read x) + 1
```

ğŸ’¡ **ç¡®ä¿ `read` çš„ç±»å‹å¯ç¡®å®šï¼Œé¿å…ç¼–è¯‘é”™è¯¯ã€‚**

------

#### **æ€»ç»“**

| **æ¦‚å¿µ**                | **ç¤ºä¾‹**                   | **ä½œç”¨**                                |
| ----------------------- | -------------------------- | --------------------------------------- |
| **ç±»å‹æ¨æ–­**            | `identity x = x`           | è‡ªåŠ¨æ¨å¯¼ `a -> a`                       |
| **Hindley-Milner ç®—æ³•** | `\x -> x * 2`              | è‡ªåŠ¨æ¨å¯¼ `Num a => a -> a`              |
| **æ³›å‹æ¨å¯¼**            | `applyTwice f x = f (f x)` | ç”Ÿæˆ `applyTwice :: (a -> a) -> a -> a` |
| **ç±»å‹å˜é‡**            | `a -> a`                   | é€‚ç”¨äºä»»ä½•ç±»å‹                          |
| **æ­§ä¹‰ç±»å‹é—®é¢˜**        | `read x + 1`               | éœ€è¦æ˜¾å¼ç±»å‹æ ‡æ³¨                        |
| **ä¼˜åŒ–ç­–ç•¥**            | `:t` æŸ¥çœ‹ç±»å‹              | æé«˜ä»£ç å¯è¯»æ€§                          |

- **Haskell é‡‡ç”¨ Hindley-Milner ç±»å‹æ¨å¯¼ï¼Œè‡ªåŠ¨æ¨å¯¼æœ€é€šç”¨çš„ç±»å‹**
- **é™æ€ç±»å‹ç³»ç»Ÿä¿è¯äº†ç±»å‹å®‰å…¨ï¼Œé˜²æ­¢è¿è¡Œæ—¶é”™è¯¯**
- **ä½¿ç”¨ `:t` å‘½ä»¤å¯ä»¥æŸ¥çœ‹ç±»å‹æ¨å¯¼ç»“æœ**
- **åœ¨å…³é”®å‡½æ•°ä¸Šå†™æ˜¾å¼ç±»å‹ç­¾åï¼Œæé«˜ä»£ç å¯è¯»æ€§**
- **ç±»å‹æ¨å¯¼è®© Haskell ä»£ç æ›´ç®€æ´ï¼ŒåŒæ—¶ä¿è¯å®‰å…¨æ€§**

åœ¨ä¸‹ä¸€èŠ‚ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢è®¨ **Haskell çš„é«˜é˜¶å‡½æ•°ä¸æŸ¯é‡ŒåŒ–ï¼ˆCurryingï¼‰**ï¼Œä»¥åŠå¦‚ä½•ä½¿ç”¨å®ƒä»¬ä¼˜åŒ– Lambda è¡¨è¾¾å¼ï¼ğŸš€

### **7.2.3 é«˜é˜¶å‡½æ•°ä¸æŸ¯é‡ŒåŒ–ï¼ˆCurryingï¼‰**

åœ¨ Haskellï¼ˆä»¥åŠå…¶ä»–å— Lambda Calculus å½±å“çš„å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ï¼‰ä¸­ï¼Œ**é«˜é˜¶å‡½æ•°ï¼ˆHigher-Order Functionsï¼‰** å’Œ **æŸ¯é‡ŒåŒ–ï¼ˆCurryingï¼‰** æ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„æ ¸å¿ƒæ¦‚å¿µã€‚é«˜é˜¶å‡½æ•°å…è®¸å‡½æ•°ä½œä¸ºå‚æ•°å’Œè¿”å›å€¼ï¼Œè€ŒæŸ¯é‡ŒåŒ–ä½¿å¾—éƒ¨åˆ†åº”ç”¨ï¼ˆPartial Applicationï¼‰æˆä¸ºå¯èƒ½ï¼Œä»è€Œæé«˜ä»£ç çš„çµæ´»æ€§å’Œå¯ç»„åˆæ€§ã€‚

åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ¢è®¨ï¼š

1. **é«˜é˜¶å‡½æ•°çš„æ¦‚å¿µ**
2. **Haskell ä¸­çš„é«˜é˜¶å‡½æ•°**
3. **æŸ¯é‡ŒåŒ–ï¼ˆCurryingï¼‰çš„æ¦‚å¿µ**
4. **æŸ¯é‡ŒåŒ–çš„å®é™…åº”ç”¨**
5. **ä»£ç ç¤ºä¾‹ï¼šHaskell ä¸­çš„æŸ¯é‡ŒåŒ–**
6. **ä¼˜åŒ–ç­–ç•¥ä¸æœ€ä½³å®è·µ**

------

#### **1. é«˜é˜¶å‡½æ•°çš„æ¦‚å¿µ**

**é«˜é˜¶å‡½æ•°ï¼ˆHigher-Order Functions, HOFsï¼‰** æŒ‡çš„æ˜¯ï¼š

- **æ¥å—å‡½æ•°ä½œä¸ºå‚æ•°** çš„å‡½æ•°
- **è¿”å›ä¸€ä¸ªå‡½æ•°ä½œä¸ºç»“æœ** çš„å‡½æ•°

Lambda Calculus æœ¬èº«å°±æ˜¯ä¸€ä¸ªé«˜é˜¶å‡½æ•°è®¡ç®—ç³»ç»Ÿï¼Œå› ä¸ºæ‰€æœ‰è®¡ç®—éƒ½å¯ä»¥ç”¨å‡½æ•°è¡¨ç¤ºã€‚

ğŸ’¡ **Haskell å¤©ç„¶æ”¯æŒé«˜é˜¶å‡½æ•°ï¼Œæ‰€æœ‰å‡½æ•°éƒ½å¯ä»¥ä½œä¸ºå‚æ•°å’Œè¿”å›å€¼ã€‚**

------

#### **2. Haskell ä¸­çš„é«˜é˜¶å‡½æ•°**

åœ¨ Haskell ä¸­ï¼Œ**é«˜é˜¶å‡½æ•°æ— å¤„ä¸åœ¨**ï¼Œå¸¸è§çš„é«˜é˜¶å‡½æ•°åŒ…æ‹¬ï¼š

- **`map`**ï¼ˆå¯¹åˆ—è¡¨ä¸­çš„å…ƒç´ åº”ç”¨ä¸€ä¸ªå‡½æ•°ï¼‰
- **`filter`**ï¼ˆåŸºäºæ¡ä»¶ç­›é€‰åˆ—è¡¨å…ƒç´ ï¼‰
- **`foldl` / `foldr`**ï¼ˆç´¯ç§¯è®¡ç®—ï¼‰

#### **2.1 `map` ç¤ºä¾‹**

```haskell
map (\x -> x * 2) [1,2,3,4]  -- è¾“å‡º [2,4,6,8]
```

ğŸ’¡ **`map` æ˜¯ä¸€ä¸ªå…¸å‹çš„é«˜é˜¶å‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ªå‡½æ•° `f` å’Œä¸€ä¸ªåˆ—è¡¨ `xs`ï¼Œç„¶åå¯¹åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ åº”ç”¨ `f`ã€‚**

------

#### **2.2 `filter` ç¤ºä¾‹**

```haskell
filter (\x -> x `mod` 2 == 0) [1,2,3,4,5,6]  -- è¾“å‡º [2,4,6]
```

ğŸ’¡ **`filter` ä¹Ÿæ˜¯ä¸€ä¸ªé«˜é˜¶å‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ªå¸ƒå°”æ¡ä»¶å‡½æ•° `p`ï¼Œå¹¶è¿”å›æ»¡è¶³ `p` æ¡ä»¶çš„å…ƒç´ ç»„æˆçš„æ–°åˆ—è¡¨ã€‚**

------

#### **2.3 `foldl` / `foldr` ç¤ºä¾‹**

```haskell
foldl (\acc x -> acc + x) 0 [1,2,3,4,5]  -- è¾“å‡º 15
```

ğŸ’¡ **`foldl` é€šè¿‡é«˜é˜¶å‡½æ•°å®ç°ç´¯ç§¯è®¡ç®—ï¼Œä½¿å¾— `reduce` æ“ä½œå˜å¾—ä¼˜é›…è€Œé«˜æ•ˆã€‚**

------

#### **3. æŸ¯é‡ŒåŒ–ï¼ˆCurryingï¼‰çš„æ¦‚å¿µ**

**æŸ¯é‡ŒåŒ–ï¼ˆCurryingï¼‰** æ˜¯ä¸€ç§å°†**å¤šå‚æ•°å‡½æ•°**è½¬æ¢ä¸º**å•å‚æ•°å‡½æ•°é“¾**çš„æŠ€æœ¯ï¼Œå®ƒçš„æ ¸å¿ƒæ€æƒ³æ¥æºäº Lambda Calculusã€‚

åœ¨ Haskell ä¸­ï¼Œæ‰€æœ‰å‡½æ•°**é»˜è®¤æ˜¯æŸ¯é‡ŒåŒ–çš„**ï¼Œå³ï¼š

```haskell
add :: Int -> Int -> Int
add x y = x + y
```

å®é™…ä¸Šç­‰ä»·äºï¼š

```haskell
add :: Int -> (Int -> Int)
add x = \y -> x + y
```

ğŸ’¡ **æŸ¯é‡ŒåŒ–ä½¿å¾—æˆ‘ä»¬å¯ä»¥å¯¹å‡½æ•°è¿›è¡Œéƒ¨åˆ†åº”ç”¨ï¼ˆPartial Applicationï¼‰ï¼Œä»è€Œæé«˜ä»£ç çš„å¤ç”¨æ€§ã€‚**

------

#### **4. æŸ¯é‡ŒåŒ–çš„å®é™…åº”ç”¨**

æŸ¯é‡ŒåŒ–å¯ä»¥ç”¨äºï¼š

1. **éƒ¨åˆ†åº”ç”¨ï¼ˆPartial Applicationï¼‰**
2. **é«˜é˜¶å‡½æ•°ç»„åˆ**
3. **ç®¡é“åŒ–æ•°æ®æµï¼ˆPoint-Free Styleï¼‰**

------

#### **4.1 éƒ¨åˆ†åº”ç”¨**

éƒ¨åˆ†åº”ç”¨ï¼ˆPartial Applicationï¼‰æŒ‡çš„æ˜¯ï¼š

- åªæä¾›**éƒ¨åˆ†å‚æ•°**ï¼Œè¿”å›ä¸€ä¸ªæ–°çš„å‡½æ•°

ç¤ºä¾‹ï¼š

```haskell
add3 :: Int -> Int
add3 = add 3

print (add3 5)  -- è¾“å‡º 8
```

ğŸ’¡ **`add3` æ˜¯ `add` çš„éƒ¨åˆ†åº”ç”¨ï¼Œå®ƒå›ºå®šäº† `x = 3`ï¼Œè¿”å›ä¸€ä¸ªåªæ¥å— `y` çš„æ–°å‡½æ•°ã€‚**

------

#### **4.2 é«˜é˜¶å‡½æ•°ç»„åˆ**

æŸ¯é‡ŒåŒ–çš„å‡½æ•°å¯ä»¥å¾ˆæ–¹ä¾¿åœ°ä¸é«˜é˜¶å‡½æ•°ç»„åˆä½¿ç”¨ï¼š

```haskell
map (add 3) [1,2,3]  -- è¾“å‡º [4,5,6]
```

ğŸ’¡ **`add 3` ä½œä¸º `map` çš„å‚æ•°ï¼Œæ˜ å°„åˆ°åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚**

------

#### **4.3 ä½¿ç”¨ `.` è¿›è¡Œå‡½æ•°ç»„åˆ**

Haskell æä¾›äº† `.` è¿ç®—ç¬¦ç”¨äºå‡½æ•°ç»„åˆï¼š

```haskell
negateEvenNumbers = map (negate . (*2))
```

ğŸ’¡ **å‡½æ•°ç»„åˆä½¿å¾—ä»£ç æ›´ä¼˜é›…ï¼Œé¿å…æ˜¾å¼å‚æ•°ä¼ é€’ã€‚**

------

#### **5. ä»£ç ç¤ºä¾‹ï¼šHaskell ä¸­çš„æŸ¯é‡ŒåŒ–**

#### **5.1 å¤šå‚æ•°å‡½æ•°**

```haskell
multiply :: Int -> Int -> Int
multiply x y = x * y
```

Haskell è®¤ä¸º `multiply` å®é™…ä¸Šæ˜¯ï¼š

```haskell
multiply :: Int -> (Int -> Int)
multiply x = \y -> x * y
```

#### **5.2 éƒ¨åˆ†åº”ç”¨**

```haskell
double = multiply 2
print (double 10)  -- è¾“å‡º 20
```

ğŸ’¡ **éƒ¨åˆ†åº”ç”¨ `multiply 2` è¿”å›ä¸€ä¸ªæ–°çš„å‡½æ•° `double`ï¼Œåªéœ€è¦ä¸€ä¸ªå‚æ•° `y`ã€‚**

------

#### **6. ä¼˜åŒ–ç­–ç•¥ä¸æœ€ä½³å®è·µ**

#### **6.1 é€‚å½“ä½¿ç”¨æŸ¯é‡ŒåŒ–**

æŸ¯é‡ŒåŒ–å¸¦æ¥äº†çµæ´»æ€§ï¼Œä½†åœ¨æŸäº›æƒ…å†µä¸‹å¯èƒ½å½±å“å¯è¯»æ€§ã€‚å»ºè®®ï¼š

- **å½“å‡½æ•°å¯ä»¥è‡ªç„¶éƒ¨åˆ†åº”ç”¨æ—¶ï¼Œä½¿ç”¨æŸ¯é‡ŒåŒ–**
- **å¯¹äºä¸éœ€è¦æŸ¯é‡ŒåŒ–çš„å‡½æ•°ï¼Œæ˜¾å¼ä½¿ç”¨å…ƒç»„**

**ç¤ºä¾‹ï¼šé¿å…ä¸å¿…è¦çš„æŸ¯é‡ŒåŒ–**

```haskell
distance (x1, y1) (x2, y2) = sqrt ((x2 - x1)^2 + (y2 - y1)^2)
```

ğŸ’¡ **å¦‚æœæ‰€æœ‰å‚æ•°å¿…é¡»åŒæ—¶æä¾›ï¼Œä½¿ç”¨å…ƒç»„å¯ä»¥æé«˜å¯è¯»æ€§ã€‚**

------

#### **6.2 ä½¿ç”¨ `.` è¿›è¡Œå‡½æ•°ç»„åˆ**

å‡½æ•°ç»„åˆå¯ä»¥å‡å°‘å‚æ•°ï¼Œæé«˜ä»£ç ç®€æ´æ€§ï¼š

```haskell
f = negate . (*2)
```

ç­‰ä»·äºï¼š

```haskell
f x = negate (x * 2)
```

ğŸ’¡ **ä½¿ç”¨ `.` è¿›è¡Œå‡½æ•°ç»„åˆå¯ä»¥å‡å°‘åµŒå¥—ï¼Œæé«˜å¯è¯»æ€§ã€‚**

------

#### **6.3 é¿å…è¿‡åº¦ä½¿ç”¨åŒ¿åå‡½æ•°**

åœ¨é«˜é˜¶å‡½æ•°ä¸­ï¼ŒæŸ¯é‡ŒåŒ–é€šå¸¸æ¯”åŒ¿åå‡½æ•°æ›´ç®€æ´ï¼š

```haskell
map (\x -> x + 1) [1,2,3]
```

ä¼˜åŒ–ä¸ºï¼š

```haskell
map (+1) [1,2,3]
```

ğŸ’¡ **ç›´æ¥ä½¿ç”¨éƒ¨åˆ†åº”ç”¨ `(+1)` ä»£æ›¿ `\x -> x + 1`ï¼Œé¿å…å†—ä½™ Lambda è¡¨è¾¾å¼ã€‚**

------

#### **æ€»ç»“**

| **æ¦‚å¿µ**             | **ç¤ºä¾‹**             | **ä½œç”¨**                     |
| -------------------- | -------------------- | ---------------------------- |
| **é«˜é˜¶å‡½æ•°**         | `map, filter, foldl` | æ¥å—æˆ–è¿”å›å‡½æ•°               |
| **æŸ¯é‡ŒåŒ–**           | `add x y = x + y`    | è½¬æ¢å¤šå‚æ•°å‡½æ•°ä¸ºå•å‚æ•°å‡½æ•°é“¾ |
| **éƒ¨åˆ†åº”ç”¨**         | `add3 = add 3`       | é¢„è®¾éƒ¨åˆ†å‚æ•°ï¼Œè¿”å›æ–°å‡½æ•°     |
| **å‡½æ•°ç»„åˆ**         | `negate . (*2)`      | ç»„åˆå¤šä¸ªå‡½æ•°ï¼Œæé«˜å¯è¯»æ€§     |
| **é¿å…è¿‡åº¦åŒ¿åå‡½æ•°** | `map (+1) xs`        | é¿å… `\x -> x + 1`           |

- **é«˜é˜¶å‡½æ•°å…è®¸ä¼ é€’å’Œè¿”å›å‡½æ•°ï¼Œæé«˜ä»£ç çµæ´»æ€§**
- **æŸ¯é‡ŒåŒ–ä½¿å¾—éƒ¨åˆ†åº”ç”¨å’Œå‡½æ•°ç»„åˆæ›´æ–¹ä¾¿**
- **Haskell é»˜è®¤ä½¿ç”¨æŸ¯é‡ŒåŒ–ï¼Œæ‰€æœ‰å‡½æ•°éƒ½æ˜¯å•å‚æ•°å‡½æ•°é“¾**
- **ä½¿ç”¨ `.` è¿›è¡Œå‡½æ•°ç»„åˆï¼Œé¿å…ä¸å¿…è¦çš„å‚æ•°ä¼ é€’**
- **åœ¨é«˜é˜¶å‡½æ•°ä¸­ï¼Œä¼˜å…ˆä½¿ç”¨æŸ¯é‡ŒåŒ–ï¼Œè€Œä¸æ˜¯åŒ¿åå‡½æ•°**

åœ¨ä¸‹ä¸€èŠ‚ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢è®¨ **Haskell ä¸å‘½ä»¤å¼è¯­è¨€çš„æ¯”è¾ƒ**ï¼Œä»¥åŠ **ä¸ºä»€ä¹ˆå‡½æ•°å¼ç¼–ç¨‹åœ¨å¹¶å‘å’Œå¹¶è¡Œè®¡ç®—ä¸­æ›´å…·ä¼˜åŠ¿**ï¼ğŸš€

### **7.3.1 çŠ¶æ€ä¸å¯å˜å˜é‡çš„ç¼ºå¤±ï¼ˆæˆ–æ¨¡æ‹Ÿï¼‰**

Haskell ä½œä¸º**çº¯å‡½æ•°å¼è¯­è¨€**ï¼Œå¤©ç”Ÿä¸æ”¯æŒ **å¯å˜å˜é‡ï¼ˆMutable Variablesï¼‰** å’Œ **å¯å˜çŠ¶æ€ï¼ˆMutable Stateï¼‰**ã€‚ä¸å‘½ä»¤å¼è¯­è¨€ï¼ˆå¦‚ Pythonã€Javaã€Cï¼‰ä¸åŒï¼ŒHaskell ä¸­çš„å˜é‡**ä¸€æ—¦è¢«å®šä¹‰ï¼Œå°±ä¸èƒ½æ›´æ”¹**ã€‚è¿™ç§**æ— çŠ¶æ€ï¼ˆStatelessï¼‰** è®¾è®¡æºè‡ª Lambda Calculusï¼Œç¡®ä¿ç¨‹åºçš„**å¼•ç”¨é€æ˜æ€§ï¼ˆReferential Transparencyï¼‰**ï¼Œå¸¦æ¥äº†æ›´é«˜çš„**å¯é¢„æµ‹æ€§ã€å¯å¹¶è¡Œæ€§å’Œå¯æµ‹è¯•æ€§**ã€‚

ç„¶è€Œï¼Œåœ¨å®é™…ç¼–ç¨‹ä¸­ï¼Œæˆ‘ä»¬å¸¸å¸¸éœ€è¦**æ¨¡æ‹Ÿå¯å˜çŠ¶æ€**ï¼Œå¦‚ï¼š

- è®¡æ•°å™¨ï¼ˆCounterï¼‰
- ç´¯åŠ å™¨ï¼ˆAccumulatorï¼‰
- å…¨å±€å˜é‡ï¼ˆGlobal Variablesï¼‰
- I/O æ“ä½œï¼ˆå¦‚æ–‡ä»¶è¯»å†™ï¼‰

æœ¬èŠ‚å°†æ¢è®¨ï¼š

1. **Haskell ä¸ºä»€ä¹ˆä¸æ”¯æŒå¯å˜çŠ¶æ€**
2. **å¦‚ä½•åœ¨ Haskell ä¸­æ¨¡æ‹Ÿå¯å˜å˜é‡**
3. **ä½¿ç”¨ `State` Monad å¤„ç†çŠ¶æ€**
4. **ä½¿ç”¨ `IORef` å’Œ `STRef` å®ç°å¯å˜å˜é‡**
5. **ä»£ç ç¤ºä¾‹ï¼šæ¨¡æ‹Ÿå¯å˜å˜é‡**
6. **Haskell çš„æ— çŠ¶æ€è®¾è®¡å¯¹å¹¶è¡Œè®¡ç®—çš„å½±å“**

------

#### **1. Haskell ä¸ºä»€ä¹ˆä¸æ”¯æŒå¯å˜çŠ¶æ€ï¼Ÿ**

åœ¨ Haskell ä¸­ï¼Œå˜é‡**æ˜¯ä¸å¯å˜çš„**ï¼Œå³ï¼š

```haskell
x = 5
x = x + 1  -- ç¼–è¯‘é”™è¯¯ï¼å˜é‡ä¸èƒ½è¢«é‡æ–°èµ‹å€¼
```

ğŸ’¡ **ä¸å¯å˜å˜é‡å¸¦æ¥çš„ä¼˜åŠ¿ï¼š**

- **å¼•ç”¨é€æ˜æ€§ï¼ˆReferential Transparencyï¼‰**ï¼šç›¸åŒè¾“å…¥å§‹ç»ˆè¿”å›ç›¸åŒè¾“å‡º
- **æ— å‰¯ä½œç”¨ï¼ˆNo Side Effectsï¼‰**ï¼šå‡½æ•°è°ƒç”¨ä¸ä¼šä¿®æ”¹å¤–éƒ¨çŠ¶æ€
- **æ›´å¥½çš„å¯æµ‹è¯•æ€§ï¼ˆTestabilityï¼‰**ï¼šæ— éœ€è€ƒè™‘çŠ¶æ€å˜åŒ–
- **è‡ªåŠ¨å¹¶è¡ŒåŒ–ï¼ˆAutomatic Parallelizationï¼‰**ï¼šå‡½æ•°ä¹‹é—´æ— çŠ¶æ€ä¾èµ–

ç„¶è€Œï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬**ç¡®å®éœ€è¦æ¨¡æ‹Ÿå¯å˜çŠ¶æ€**ï¼Œè¿™å°±å¼•å‡ºäº† **çŠ¶æ€ç®¡ç†æŠ€æœ¯**ã€‚

------

#### **2. å¦‚ä½•åœ¨ Haskell ä¸­æ¨¡æ‹Ÿå¯å˜å˜é‡**

#### **2.1 é€šè¿‡é€’å½’å®ç°ç´¯åŠ å™¨**

åœ¨ Haskell ä¸­ï¼Œæœ€å¸¸è§çš„**æ¨¡æ‹Ÿå¯å˜å˜é‡çš„æ–¹æ³•**æ˜¯ä½¿ç”¨ **é€’å½’ï¼ˆRecursionï¼‰** ä¼ é€’**æ–°çš„çŠ¶æ€å€¼**ã€‚

#### **ç¤ºä¾‹ï¼šé€’å½’æ¨¡æ‹Ÿè®¡æ•°å™¨**

```haskell
counter :: Int -> IO ()
counter n = do
    print n
    counter (n + 1)  -- é€’å½’è°ƒç”¨ï¼Œæ¨¡æ‹Ÿå˜é‡æ›´æ–°
```

ğŸ’¡ **å˜é‡ `n` æœ¬èº«æ²¡æœ‰æ”¹å˜ï¼Œè€Œæ˜¯é€šè¿‡é€’å½’ä¼ é€’æ–°çš„å€¼ã€‚**

#### **ç¤ºä¾‹ï¼šé€’å½’ç´¯åŠ **

```haskell
sumList :: [Int] -> Int -> Int
sumList [] acc = acc
sumList (x:xs) acc = sumList xs (acc + x)
```

ğŸ’¡ **`acc` ä½œä¸ºç´¯åŠ å˜é‡ï¼Œæ¯æ¬¡é€’å½’ä¼ é€’æ–°çš„å€¼ï¼Œæ¨¡æ‹Ÿå˜é‡æ›´æ–°ã€‚**

------

#### **3. ä½¿ç”¨ `State` Monad å¤„ç†çŠ¶æ€**

é€’å½’æ–¹æ³•è™½ç„¶å¯è¡Œï¼Œä½†å¦‚æœä»£ç å¤æ‚ï¼Œå¯èƒ½å¯¼è‡´éš¾ä»¥ç»´æŠ¤ã€‚å› æ­¤ï¼ŒHaskell æä¾›äº† **`State` Monad**ï¼Œç”¨äºæ¨¡æ‹Ÿ**å¯å˜çŠ¶æ€**ã€‚

#### **3.1 `State` Monad åŸºæœ¬ç”¨æ³•**

`State` Monad å…è®¸æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªçŠ¶æ€ `s`ï¼Œå¹¶é€šè¿‡ `State s a` ç±»å‹çš„è®¡ç®—å‡½æ•°æ›´æ–°å®ƒï¼š

```haskell
import Control.Monad.State

increment :: State Int Int
increment = do
    x <- get    -- è·å–å½“å‰çŠ¶æ€
    put (x + 1) -- æ›´æ–°çŠ¶æ€
    return x
```

ğŸ’¡ **`get` è·å–å½“å‰çŠ¶æ€ï¼Œ`put` è®¾å®šæ–°çŠ¶æ€ã€‚**

------

#### **3.2 `State` Monad è®¡ç®—ç¤ºä¾‹**

```haskell
runState increment 5  -- ç»“æœï¼š(5,6)
```

è§£é‡Šï¼š

- `increment` è¯»å–å½“å‰å€¼ `5`
- `increment` å°†çŠ¶æ€æ›´æ–°ä¸º `6`
- è¿”å› `(5,6)`ï¼Œå…¶ä¸­ `5` æ˜¯æ—§çŠ¶æ€ï¼Œ`6` æ˜¯æ–°çŠ¶æ€

#### **ç¤ºä¾‹ï¼šä½¿ç”¨ `State` Monad è®¡ç®—ç´¯åŠ **

```haskell
sumState :: [Int] -> State Int Int
sumState [] = get
sumState (x:xs) = do
    modify (+ x)  -- æ›´æ–°çŠ¶æ€
    sumState xs
```

ğŸ’¡ **`modify (+ x)` æ˜¯ `put (x + s)` çš„ç®€å†™ï¼Œç”¨äºæ›´æ–°çŠ¶æ€ã€‚**

è¿è¡Œï¼š

```haskell
runState (sumState [1,2,3,4]) 0  -- ç»“æœï¼š(10, 10)
```

------

#### **4. ä½¿ç”¨ `IORef` å’Œ `STRef` å®ç°å¯å˜å˜é‡**

åœ¨æŸäº›æƒ…å†µä¸‹ï¼ˆå¦‚ I/O æ“ä½œï¼‰ï¼Œæˆ‘ä»¬ä»ç„¶éœ€è¦**çœŸæ­£çš„å¯å˜å˜é‡**ã€‚Haskell æä¾›ï¼š

- **`IORef`**ï¼ˆé€‚ç”¨äº `IO` æ“ä½œï¼‰
- **`STRef`**ï¼ˆé€‚ç”¨äºçº¯è®¡ç®—ä¸­çš„çŠ¶æ€å˜æ›´ï¼‰

#### **4.1 ä½¿ç”¨ `IORef` åˆ›å»ºå¯å˜å˜é‡**

```haskell
import Data.IORef

main = do
    counter <- newIORef 0   -- åˆ›å»ºå¯å˜å˜é‡
    modifyIORef counter (+1)  -- é€’å¢
    value <- readIORef counter
    print value  -- è¾“å‡º 1
```

ğŸ’¡ **`newIORef` åˆ›å»ºå¯å˜å˜é‡ï¼Œ`modifyIORef` ä¿®æ”¹å®ƒï¼Œ`readIORef` è¯»å–å€¼ã€‚**

------

#### **4.2 ä½¿ç”¨ `STRef` åœ¨çº¯è®¡ç®—ä¸­ä½¿ç”¨å¯å˜çŠ¶æ€**

`STRef` å…è®¸æˆ‘ä»¬åœ¨**çº¯è®¡ç®—ï¼ˆé `IO`ï¼‰**ä¸­åˆ›å»ºå¯å˜å˜é‡ï¼š

```haskell
import Control.Monad.ST
import Data.STRef

sumListST :: [Int] -> Int
sumListST xs = runST $ do
    acc <- newSTRef 0
    mapM_ (\x -> modifySTRef acc (+x)) xs
    readSTRef acc
```

ğŸ’¡ **`STRef` æä¾›äº†**â€œä¼ªå¯å˜å˜é‡â€**ï¼Œä½†ä»ç„¶ä¿è¯äº†**çº¯å‡½æ•°å¼ç¼–ç¨‹**çš„ç‰¹æ€§ã€‚

------

#### **5. ä»£ç ç¤ºä¾‹ï¼šHaskell å¦‚ä½•æ¨¡æ‹Ÿå¯å˜å˜é‡**

#### **5.1 é€’å½’æ¨¡æ‹ŸçŠ¶æ€**

```haskell
count :: Int -> IO ()
count n = do
    print n
    count (n + 1)
```

ğŸ’¡ **é€’å½’ä¼ é€’ `n`ï¼Œé¿å…å¯å˜å˜é‡ã€‚**

------

#### **5.2 `State` Monad ç»´æŠ¤çŠ¶æ€**

```haskell
import Control.Monad.State

incrementState :: State Int Int
incrementState = do
    x <- get
    put (x + 1)
    return x
```

è¿è¡Œï¼š

```haskell
runState incrementState 5  -- è¾“å‡º (5,6)
```

ğŸ’¡ **`State` Monad è®©çŠ¶æ€å˜æ›´æ›´åŠ ç»“æ„åŒ–ã€‚**

------

#### **5.3 `IORef` å®ç°çœŸæ­£çš„å¯å˜å˜é‡**

```haskell
import Data.IORef

main = do
    counter <- newIORef 0
    modifyIORef counter (+1)
    value <- readIORef counter
    print value  -- è¾“å‡º 1
```

ğŸ’¡ **`IORef` å…è®¸åœ¨ `IO` æ“ä½œä¸­ä½¿ç”¨å¯å˜çŠ¶æ€ã€‚**

------

#### **6. Haskell çš„æ— çŠ¶æ€è®¾è®¡å¯¹å¹¶è¡Œè®¡ç®—çš„å½±å“**

ç”±äº Haskell **ä¸æ”¯æŒå¯å˜çŠ¶æ€**ï¼Œå®ƒå¤©ç”Ÿé€‚ç”¨äº**å¹¶è¡Œè®¡ç®—**ï¼š

1. **çº¯å‡½æ•°å¼ç¼–ç¨‹å¤©ç„¶æ— ç«äº‰æ¡ä»¶ï¼ˆRace Conditionï¼‰**
2. **ä¸éœ€è¦åŠ é”ï¼ˆLock-Freeï¼‰ï¼Œå¹¶è¡Œè®¡ç®—æ›´é«˜æ•ˆ**
3. **è‡ªåŠ¨è¿›è¡Œæƒ°æ€§æ±‚å€¼ï¼ˆLazy Evaluationï¼‰ï¼Œå‡å°‘è®¡ç®—å¼€é”€**
4. **å¯ä»¥ä½¿ç”¨ `par` å’Œ `pseq` è¿›è¡Œå¹¶è¡Œè®¡ç®—**

ğŸ’¡ **Haskell çš„æ— çŠ¶æ€è®¾è®¡ï¼Œä½¿å…¶æˆä¸ºé«˜æ•ˆå¹¶è¡Œè®¡ç®—çš„æœ€ä½³é€‰æ‹©ä¹‹ä¸€ã€‚**

------

#### **æ€»ç»“**

| **æ–¹æ³•**         | **å®ç°æ–¹å¼**               | **é€‚ç”¨åœºæ™¯**       |
| ---------------- | -------------------------- | ------------------ |
| **é€’å½’ä¼ é€’çŠ¶æ€** | é€’å½’å‡½æ•°å‚æ•°               | é€‚ç”¨äºç®€å•è®¡ç®—     |
| **State Monad**  | `State s a`                | é€‚ç”¨äºå¤æ‚çŠ¶æ€å˜æ›´ |
| **IORef**        | `newIORef` / `modifyIORef` | é€‚ç”¨äº `IO` æ“ä½œ   |
| **STRef**        | `newSTRef` / `modifySTRef` | é€‚ç”¨äºçº¯è®¡ç®—       |

- **Haskell å˜é‡æ˜¯ä¸å¯å˜çš„**
- **å¯ä»¥ä½¿ç”¨é€’å½’æˆ– `State` Monad æ¨¡æ‹ŸçŠ¶æ€**
- **`IORef` å’Œ `STRef` æä¾›çœŸæ­£çš„å¯å˜å˜é‡**
- **æ— çŠ¶æ€è®¾è®¡ä½¿ Haskell é€‚ç”¨äºå¹¶è¡Œè®¡ç®—**

åœ¨ä¸‹ä¸€èŠ‚ï¼Œæˆ‘ä»¬å°†æ¢è®¨ **çº¯å‡½æ•°å¼ç¼–ç¨‹å¯¹å¹¶å‘ä¸å¹¶è¡Œçš„ä¼˜åŠ¿**ï¼ğŸš€

### **7.3.2 çº¯å‡½æ•°å¼ç¼–ç¨‹å¯¹å¹¶å‘ä¸å¹¶è¡Œçš„ä¼˜åŠ¿**

åœ¨ç°ä»£è®¡ç®—ä¸­ï¼Œå¹¶å‘ï¼ˆConcurrencyï¼‰å’Œå¹¶è¡Œï¼ˆParallelismï¼‰æ˜¯æå‡ç¨‹åºæ€§èƒ½çš„å…³é”®ã€‚ç„¶è€Œï¼Œåœ¨ä¼ ç»Ÿçš„å‘½ä»¤å¼ç¼–ç¨‹è¯­è¨€ï¼ˆå¦‚ Cã€Javaã€Pythonï¼‰ä¸­ï¼Œå®ç°é«˜æ•ˆçš„å¹¶å‘ä¸å¹¶è¡Œè®¡ç®—å¹¶ä¸å®¹æ˜“ï¼ŒåŸå› åŒ…æ‹¬ï¼š

- **å…±äº«å¯å˜çŠ¶æ€** å¯¼è‡´ç«æ€æ¡ä»¶ï¼ˆRace Conditionï¼‰
- **éœ€è¦æ˜¾å¼åŠ é”**ï¼ˆMutexã€Semaphoreï¼‰ï¼Œå¸¦æ¥åŒæ­¥å¼€é”€
- **æ­»é”ï¼ˆDeadlockï¼‰** å’Œ **æ´»é”ï¼ˆLivelockï¼‰** é—®é¢˜
- **éš¾ä»¥æ¨ç†å’Œè°ƒè¯•** å¤šçº¿ç¨‹ç¨‹åºçš„æ‰§è¡Œé¡ºåº

ç›¸æ¯”ä¹‹ä¸‹ï¼Œ**çº¯å‡½æ•°å¼ç¼–ç¨‹ï¼ˆPure Functional Programmingï¼‰** æä¾›äº†ä¸€ç§ **æ— å‰¯ä½œç”¨ã€æ— å…±äº«çŠ¶æ€ã€å¯é¢„æµ‹** çš„è®¡ç®—æ¨¡å‹ï¼Œä½¿å¾— **å¹¶å‘ä¸å¹¶è¡Œè®¡ç®—æ›´åŠ å®‰å…¨å’Œé«˜æ•ˆ**ã€‚æœ¬èŠ‚å°†æ¢è®¨ï¼š

1. **å¹¶å‘ vs. å¹¶è¡Œ**
2. **çº¯å‡½æ•°å¼ç¼–ç¨‹å¦‚ä½•æ¶ˆé™¤ç«æ€æ¡ä»¶**
3. **Haskell å¦‚ä½•é«˜æ•ˆæ”¯æŒå¹¶å‘**
4. **Haskell å¦‚ä½•å®ç°å¹¶è¡Œè®¡ç®—**
5. **ä»£ç ç¤ºä¾‹ï¼šå¹¶å‘ä¸å¹¶è¡Œçš„ Haskell å®ç°**
6. **Haskell åœ¨å¤§è§„æ¨¡è®¡ç®—ä¸­çš„åº”ç”¨**

------

#### **1. å¹¶å‘ vs. å¹¶è¡Œ**

åœ¨è®¨è®º **å¹¶å‘ï¼ˆConcurrencyï¼‰** å’Œ **å¹¶è¡Œï¼ˆParallelismï¼‰** ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆåŒºåˆ†å®ƒä»¬çš„æ¦‚å¿µï¼š

| **æ¦‚å¿µ**                | **å®šä¹‰**                                 | **ç¤ºä¾‹**                   |
| ----------------------- | ---------------------------------------- | -------------------------- |
| **å¹¶å‘ï¼ˆConcurrencyï¼‰** | è®©å¤šä¸ªä»»åŠ¡åœ¨åŒä¸€æ—¶é—´æ®µå†…äº¤é”™æ‰§è¡Œ         | å¤šä¸ªç”¨æˆ·è®¿é—® Web æœåŠ¡å™¨    |
| **å¹¶è¡Œï¼ˆParallelismï¼‰** | è®©å¤šä¸ªä»»åŠ¡**åŒæ—¶æ‰§è¡Œ**ï¼Œå……åˆ†åˆ©ç”¨å¤šæ ¸ CPU | è®¡ç®—æœºåŒæ—¶è¿è¡Œå¤šä¸ª AI ä»»åŠ¡ |

ğŸ’¡ **å¹¶å‘å¼ºè°ƒâ€œåŒæ—¶ç®¡ç†å¤šä¸ªä»»åŠ¡â€ï¼Œè€Œå¹¶è¡Œå¼ºè°ƒâ€œåŒæ—¶æ‰§è¡Œå¤šä¸ªä»»åŠ¡â€ã€‚**

------

#### **2. çº¯å‡½æ•°å¼ç¼–ç¨‹å¦‚ä½•æ¶ˆé™¤ç«æ€æ¡ä»¶**

åœ¨ä¼ ç»Ÿçš„å‘½ä»¤å¼ç¼–ç¨‹ä¸­ï¼Œå¤šä¸ªçº¿ç¨‹å…±äº«**å¯å˜çŠ¶æ€**ï¼Œä¾‹å¦‚ï¼š

```c
int counter = 0;

void increment() {
    counter += 1;  // å¯èƒ½å¯¼è‡´ç«æ€æ¡ä»¶
}
```

å¦‚æœä¸¤ä¸ªçº¿ç¨‹åŒæ—¶æ‰§è¡Œ `increment()`ï¼Œå®ƒä»¬å¯èƒ½ä¼šè¦†ç›–å½¼æ­¤çš„ä¿®æ”¹ï¼Œå¯¼è‡´ç«æ€æ¡ä»¶ã€‚

åœ¨ **çº¯å‡½æ•°å¼ç¼–ç¨‹ï¼ˆå¦‚ Haskellï¼‰** ä¸­ï¼Œ**æ²¡æœ‰å¯å˜çŠ¶æ€**ï¼Œæ‰€æœ‰å‡½æ•°éƒ½æ˜¯**æ— å‰¯ä½œç”¨ï¼ˆSide-effect Freeï¼‰**ï¼Œå³ï¼š

```haskell
increment :: Int -> Int
increment x = x + 1
```

ğŸ’¡ **æ¯æ¬¡è°ƒç”¨ `increment` éƒ½è¿”å›ä¸€ä¸ªæ–°çš„å€¼ï¼Œä¸ä¼šä¿®æ”¹åŸå§‹æ•°æ®ï¼Œå› æ­¤æ²¡æœ‰ç«æ€æ¡ä»¶ï¼**

#### **2.1 çº¯å‡½æ•°çš„ç‰¹æ€§**

- **å¼•ç”¨é€æ˜æ€§ï¼ˆReferential Transparencyï¼‰**ï¼šç›¸åŒè¾“å…¥å§‹ç»ˆå¾—åˆ°ç›¸åŒè¾“å‡º
- **æ— å‰¯ä½œç”¨ï¼ˆNo Side Effectsï¼‰**ï¼šå‡½æ•°ä¸ä¾èµ–å¤–éƒ¨çŠ¶æ€
- **è‡ªåŠ¨å¹¶è¡ŒåŒ–ï¼ˆAutomatic Parallelizationï¼‰**ï¼šç”±äºæ— çŠ¶æ€ï¼ŒHaskell ç¼–è¯‘å™¨å¯ä»¥è‡ªåŠ¨å¹¶è¡Œæ‰§è¡Œå‡½æ•°

ğŸ’¡ **è¿™äº›ç‰¹æ€§è®© Haskell åœ¨å¹¶å‘å’Œå¹¶è¡Œè®¡ç®—ä¸­å…·æœ‰å¤©ç„¶ä¼˜åŠ¿ã€‚**

------

#### **3. Haskell å¦‚ä½•é«˜æ•ˆæ”¯æŒå¹¶å‘**

Haskell é€šè¿‡ **è½»é‡çº§çº¿ç¨‹ï¼ˆLightweight Threadsï¼‰** å’Œ **MVarã€STMï¼ˆè½¯ä»¶äº‹åŠ¡å†…å­˜ï¼‰** æ¥å®ç°é«˜æ•ˆå¹¶å‘ã€‚

#### **3.1 Haskell çš„è½»é‡çº§çº¿ç¨‹**

Haskell æä¾› `forkIO` åˆ›å»º **ç”¨æˆ·çº§çº¿ç¨‹ï¼ˆUser-Level Threadsï¼‰**ï¼Œå®ƒæ¯”æ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼ˆOS Threadsï¼‰æ›´è½»é‡ï¼š

```haskell
import Control.Concurrent

main = do
    forkIO (putStrLn "Hello from thread!")
    putStrLn "Hello from main!"
```

ğŸ’¡ **Haskell çº¿ç¨‹æ˜¯â€œç»¿è‰²çº¿ç¨‹â€ï¼Œå®ƒä»¬ç”± Haskell è¿è¡Œæ—¶ç®¡ç†ï¼Œä¸ä¾èµ–æ“ä½œç³»ç»Ÿçº¿ç¨‹ã€‚**

------

#### **3.2 MVarï¼šç”¨äºåŒæ­¥çº¿ç¨‹**

`MVar`ï¼ˆMutable Variableï¼‰ æ˜¯ Haskell **å®‰å…¨çš„çº¿ç¨‹é—´é€šä¿¡æœºåˆ¶**ï¼š

```haskell
import Control.Concurrent.MVar

main = do
    mvar <- newEmptyMVar
    forkIO (putMVar mvar "Data from thread")
    msg <- takeMVar mvar
    putStrLn msg
```

ğŸ’¡ **`MVar` æä¾›äº†ä¸€ä¸ªå®‰å…¨çš„æ–¹å¼åœ¨ä¸åŒçº¿ç¨‹é—´ä¼ é€’æ•°æ®ã€‚**

------

#### **3.3 STMï¼ˆè½¯ä»¶äº‹åŠ¡å†…å­˜ï¼‰**

Haskell çš„ **STMï¼ˆSoftware Transactional Memoryï¼‰** æä¾› **æ— é”ï¼ˆLock-freeï¼‰å¹¶å‘æ§åˆ¶**ï¼š

```haskell
import Control.Concurrent.STM

main = do
    counter <- atomically $ newTVar 0
    atomically $ modifyTVar counter (+1)
    val <- atomically $ readTVar counter
    print val  -- è¾“å‡º 1
```

ğŸ’¡ **STM å…è®¸å¤šä¸ªçº¿ç¨‹å®‰å…¨åœ°ä¿®æ”¹å…±äº«å˜é‡ï¼Œé¿å…ç«æ€æ¡ä»¶ã€‚**

------

#### **4. Haskell å¦‚ä½•å®ç°å¹¶è¡Œè®¡ç®—**

Haskell é€šè¿‡ `par` å’Œ `pseq` æä¾› **æ˜¾å¼å¹¶è¡Œè®¡ç®—**ã€‚

#### **4.1 `par` è¿›è¡Œå¹¶è¡Œè®¡ç®—**

`par` å¯ä»¥è®© Haskell **åœ¨å¤šä¸ª CPU æ ¸å¿ƒä¸ŠåŒæ—¶è®¡ç®—**ï¼š

```haskell
import Control.Parallel

fib :: Int -> Int
fib 0 = 1
fib 1 = 1
fib n = fib (n-1) + fib (n-2)

main = do
    let a = fib 35
    let b = fib 36
    let result = a `par` (b `pseq` (a + b))
    print result
```

ğŸ’¡ **`par` è®© `a` å’Œ `b` å¹¶è¡Œè®¡ç®—ï¼Œ`pseq` ç¡®ä¿ `b` è®¡ç®—å®Œæˆåæ‰åˆå¹¶ç»“æœã€‚**

------

#### **5. ä»£ç ç¤ºä¾‹ï¼šå¹¶å‘ä¸å¹¶è¡Œçš„ Haskell å®ç°**

#### **5.1 å¹¶å‘ï¼šä½¿ç”¨ `forkIO`**

```haskell
import Control.Concurrent

main = do
    forkIO (putStrLn "Thread 1 running")
    forkIO (putStrLn "Thread 2 running")
    putStrLn "Main thread running"
```

ğŸ’¡ **`forkIO` å¯åŠ¨å¤šä¸ªçº¿ç¨‹å¹¶å‘æ‰§è¡Œä»»åŠ¡ã€‚**

------

#### **5.2 STMï¼šæ— é”å¹¶å‘**

```haskell
import Control.Concurrent.STM

main = do
    counter <- atomically $ newTVar 0
    atomically $ modifyTVar counter (+1)
    val <- atomically $ readTVar counter
    print val  -- è¾“å‡º 1
```

ğŸ’¡ **STM æä¾›äº†åŸå­åŒ–çš„äº‹åŠ¡æ“ä½œï¼Œé¿å…æ•°æ®ç«äº‰ã€‚**

------

#### **5.3 å¹¶è¡Œè®¡ç®—ï¼šä½¿ç”¨ `par`**

```haskell
import Control.Parallel

main = do
    let x = fib 35
    let y = fib 36
    let result = x `par` (y `pseq` (x + y))
    print result
```

ğŸ’¡ **`par` è®© `x` å’Œ `y` åœ¨å¤šä¸ªæ ¸å¿ƒä¸Šå¹¶è¡Œè®¡ç®—ï¼Œæé«˜æ€§èƒ½ã€‚**

------

#### **6. Haskell åœ¨å¤§è§„æ¨¡è®¡ç®—ä¸­çš„åº”ç”¨**

Haskell çš„å¹¶è¡Œè®¡ç®—èƒ½åŠ›ä½¿å…¶åœ¨ä»¥ä¸‹é¢†åŸŸæœ‰é‡è¦åº”ç”¨ï¼š

1. **å¤§è§„æ¨¡æ•°æ®åˆ†æ**ï¼ˆBig Data Processingï¼‰
2. **é‡‘èè®¡ç®—**ï¼ˆQuantitative Financeï¼‰
3. **é«˜æ€§èƒ½è®¡ç®—ï¼ˆHPCï¼‰**
4. **åŒºå—é“¾ä¸åŠ å¯†è´§å¸**ï¼ˆCryptographyï¼‰
5. **AI/æœºå™¨å­¦ä¹ ä¸­çš„å¤§è§„æ¨¡è®¡ç®—**

ğŸ’¡ **Haskell çš„æ— çŠ¶æ€ç‰¹æ€§è®©å®ƒéå¸¸é€‚åˆé«˜å¹¶å‘å’Œé«˜ååçš„è®¡ç®—ä»»åŠ¡ã€‚**

------

#### **æ€»ç»“**

| **æ¦‚å¿µ**       | **Haskell æ–¹æ¡ˆ**        | **ä¼˜åŠ¿**                        |
| -------------- | ----------------------- | ------------------------------- |
| **æ— ç«æ€æ¡ä»¶** | çº¯å‡½æ•°                  | ä¸å¯å˜æ•°æ®ï¼Œé¿å… Race Condition |
| **é«˜æ•ˆå¹¶å‘**   | `forkIO`, `MVar`, `STM` | è½»é‡çº§çº¿ç¨‹ï¼Œæ— é”å¹¶å‘            |
| **è‡ªåŠ¨å¹¶è¡Œ**   | `par`, `pseq`           | è‡ªåŠ¨åˆ©ç”¨å¤šæ ¸ CPU                |
| **å¯é¢„æµ‹æ€§**   | çº¯å‡½æ•°æ— å‰¯ä½œç”¨          | æ˜“äºæ¨ç†å’Œè°ƒè¯•                  |

- **Haskell é€šè¿‡æ— çŠ¶æ€è®¾è®¡æ¶ˆé™¤äº†ç«æ€æ¡ä»¶**
- **`forkIO` æä¾›é«˜æ•ˆå¹¶å‘ï¼Œ`STM` æä¾›å®‰å…¨äº‹åŠ¡**
- **`par` å’Œ `pseq` å…è®¸æ˜¾å¼å¹¶è¡Œè®¡ç®—**
- **æ— é”å¹¶è¡Œæé«˜æ€§èƒ½ï¼Œé€‚ç”¨äºå¤§è§„æ¨¡è®¡ç®—**

åœ¨ä¸‹ä¸€èŠ‚ï¼Œæˆ‘ä»¬å°†æ¢è®¨ **Haskell åœ¨å®é™…é¡¹ç›®ä¸­çš„åº”ç”¨**ï¼Œä»¥åŠå¦‚ä½•ä¼˜åŒ–å‡½æ•°å¼ç¼–ç¨‹ä»£ç ï¼ğŸš€

### **7.4.1 ç”¨ Haskell å®šä¹‰ Church æ•°å’Œå¸ƒå°”æ“ä½œ**

Lambda Calculus å¯ä»¥è¡¨ç¤º**å¸ƒå°”å€¼ã€è‡ªç„¶æ•°ã€ç®—æœ¯è¿ç®—**ç­‰è®¡ç®—æ¦‚å¿µï¼Œå…¶ä¸­ **Church Encoding** æ˜¯ä¸€ç§**çº¯å‡½æ•°å¼è¡¨ç¤ºæ–¹æ³•**ï¼Œå®ƒå°†**å¸ƒå°”å€¼ã€æ•°å€¼ã€åˆ—è¡¨**ç­‰æ¦‚å¿µ**å…¨éƒ¨è¡¨ç¤ºä¸º Lambda è¡¨è¾¾å¼**ã€‚åœ¨ Haskell ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥å®ç° Church ç¼–ç ï¼Œä»¥æ›´æ·±å…¥åœ°ç†è§£ Lambda Calculus åœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„ä½œç”¨ã€‚

åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ï¼š

1. **å®šä¹‰ Church å¸ƒå°”å€¼**ï¼ˆ`true`, `false`ï¼‰å¹¶å®ç°åŸºæœ¬æ“ä½œï¼ˆ`and`, `or`, `not`ï¼‰
2. **å®šä¹‰ Church æ•°**ï¼ˆ`zero`, `succ`ï¼‰å¹¶å®ç°åŸºæœ¬ç®—æœ¯è¿ç®—ï¼ˆ`add`, `mul`ï¼‰
3. **ç¼–å†™ Haskell ä»£ç ï¼ŒéªŒè¯ Church æ•°å’Œå¸ƒå°”è®¡ç®—**
4. **åˆ†æ Church ç¼–ç åœ¨ Haskell ä¸­çš„åº”ç”¨**

------

#### **1. Church å¸ƒå°”å€¼ï¼ˆChurch Booleansï¼‰**

åœ¨ Lambda Calculus ä¸­ï¼Œå¸ƒå°”å€¼ `true` å’Œ `false` å¯ä»¥è¿™æ ·å®šä¹‰ï¼š

```haskell
true  = \x y -> x
false = \x y -> y
```

è§£é‡Šï¼š

- **`true` é€‰æ‹©ç¬¬ä¸€ä¸ªå‚æ•°**
- **`false` é€‰æ‹©ç¬¬äºŒä¸ªå‚æ•°**

#### **1.1 é€»è¾‘è¿ç®—**

æˆ‘ä»¬å¯ä»¥å®šä¹‰ **é€»è¾‘æ“ä½œ**ï¼š

```haskell
-- AND: true and false = false
andChurch = \p q -> p q false  

-- OR:  true or false = true
orChurch = \p q -> p true q   

-- NOT: not true = false
notChurch = \p -> p false true 
```

ğŸ’¡ **è¿™äº›å®šä¹‰å®Œå…¨åŸºäº Lambda è®¡ç®—ï¼Œæ²¡æœ‰ä½¿ç”¨ Haskell è¯­è¨€å†…ç½®çš„ `Bool`ã€‚**

------

#### **1.2 Church å¸ƒå°”è¿ç®—æµ‹è¯•**

```haskell
main :: IO ()
main = do
    let bTrue  = true
    let bFalse = false
    putStrLn "Church Boolean Operations:"
    print ((andChurch bTrue bFalse) "True" "False")  -- False
    print ((orChurch bTrue bFalse) "True" "False")   -- True
    print ((notChurch bTrue) "True" "False")         -- False
```

è¿è¡Œç»“æœï¼š

```
Church Boolean Operations:
False
True
False
```

ğŸ’¡ **Haskell ä»¥å­—ç¬¦ä¸² `"True" "False"` ä½œä¸º `true` å’Œ `false` ç»“æœçš„æµ‹è¯•å€¼ã€‚**

------

#### **2. Church æ•°ï¼ˆChurch Numeralsï¼‰**

#### **2.1 å®šä¹‰ Church æ•°**

åœ¨ Lambda Calculus ä¸­ï¼Œ**è‡ªç„¶æ•° n å¯ä»¥è¡¨ç¤ºä¸ºä¸€ä¸ªå‡½æ•°ï¼Œåº”ç”¨å®ƒ n æ¬¡**ï¼š

```haskell
zero  = \f x -> x         -- 0: åº”ç”¨ 0 æ¬¡
one   = \f x -> f x       -- 1: åº”ç”¨ 1 æ¬¡
two   = \f x -> f (f x)   -- 2: åº”ç”¨ 2 æ¬¡
three = \f x -> f (f (f x))  -- 3: åº”ç”¨ 3 æ¬¡
```

ğŸ’¡ **Church æ•° `n` ä»£è¡¨â€œå¯¹å‡½æ•° `f` è¿›è¡Œ `n` æ¬¡åº”ç”¨â€ã€‚**

------

#### **2.2 å®šä¹‰åç»§å‡½æ•°**

æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªåç»§å‡½æ•° `succ`ï¼Œç”¨äºè®¡ç®— `n + 1`ï¼š

```haskell
succChurch = \n f x -> f (n f x)
```

è§£é‡Šï¼š

- `n f x` è®¡ç®— `n` æ¬¡åº”ç”¨ `f`
- `f (n f x)` è®© `n + 1` æ¬¡åº”ç”¨ `f`

------

#### **2.3 Church æ•°çš„ç®—æœ¯è¿ç®—**

#### **2.3.1 åŠ æ³•ï¼ˆAdditionï¼‰**

```haskell
addChurch = \m n f x -> m f (n f x)
```

è§£é‡Šï¼š

- `n f x` å…ˆåº”ç”¨ `n` æ¬¡ `f`
- `m f (n f x)` å†åº”ç”¨ `m` æ¬¡ `f`ï¼Œå¾—åˆ° `m + n`

#### **2.3.2 ä¹˜æ³•ï¼ˆMultiplicationï¼‰**

```haskell
mulChurch = \m n f -> m (n f)
```

è§£é‡Šï¼š

- `n f` ä»£è¡¨ â€œ`f` åº”ç”¨ `n` æ¬¡â€
- `m (n f)` ä»£è¡¨ â€œè®© `f` è¢«åº”ç”¨ `m * n` æ¬¡â€

------

#### **2.4 Church æ•°è®¡ç®—ç¤ºä¾‹**

```haskell
churchToInt n = n (+1) 0  -- å°† Church æ•°è½¬æ¢ä¸º Haskell æ•´æ•°

main :: IO ()
main = do
    let c0 = zero
    let c1 = one
    let c2 = two
    let c3 = three
    putStrLn "Church Numerals:"
    print (churchToInt (succChurch c2))  -- 3
    print (churchToInt (addChurch c2 c3))  -- 5
    print (churchToInt (mulChurch c2 c3))  -- 6
```

ğŸ’¡ **`churchToInt` é€šè¿‡ `(+1) 0` è®¡ç®— Church æ•°çš„å®é™…å€¼ã€‚**

------

#### **3. Church ç¼–ç åœ¨ Haskell ä¸­çš„åº”ç”¨**

Church ç¼–ç çš„æ€æƒ³**å¯å‘äº† Haskell è®¸å¤šæ¦‚å¿µ**ï¼Œå¦‚ï¼š

1. **Lambda è¡¨è¾¾å¼å’ŒåŒ¿åå‡½æ•°**
   - Haskell å…è®¸ä½¿ç”¨ `\x -> x + 1` å½¢å¼å®šä¹‰åŒ¿åå‡½æ•°ï¼Œä¸ Lambda Calculus ç›´æ¥å¯¹åº”ã€‚
2. **é«˜é˜¶å‡½æ•°**
   - Church ç¼–ç **å°†æ•°å€¼ã€å¸ƒå°”å€¼è¡¨ç¤ºä¸ºå‡½æ•°**ï¼Œè¿™ä¸ Haskell çš„**é«˜é˜¶å‡½æ•°**æ€æƒ³å®Œå…¨ä¸€è‡´ã€‚
3. **æƒ°æ€§æ±‚å€¼**
   - Church ç¼–ç è®¡ç®—**ä¾èµ–äºå‡½æ•°åº”ç”¨**ï¼Œè¿™ä¸ Haskell çš„**æƒ°æ€§æ±‚å€¼ï¼ˆLazy Evaluationï¼‰** æœºåˆ¶ç±»ä¼¼ã€‚
4. **ç±»å‹ç³»ç»Ÿ**
   - Haskell å…è®¸ä½¿ç”¨ `newtype` å’Œ `data` å®šä¹‰ä»£æ•°æ•°æ®ç±»å‹ï¼Œç±»ä¼¼äº Church ç¼–ç ã€‚

------

#### **4. æ€»ç»“**

| **æ¦‚å¿µ**     | **Lambda Calculus å®šä¹‰**           | **Haskell å®ç°**                      |
| ------------ | ---------------------------------- | ------------------------------------- |
| **å¸ƒå°”å€¼**   | `true = Î»x y. x` `false = Î»x y. y` | `true = \x y -> x`                    |
| **é€»è¾‘è¿ç®—** | `and = Î»p q. p q false`            | `andChurch = \p q -> p q false`       |
| **è‡ªç„¶æ•°**   | `zero = Î»f x. x` `one = Î»f x. f x` | `zero = \f x -> x`                    |
| **åŠ æ³•**     | `add = Î»m n f x. m f (n f x)`      | `addChurch = \m n f x -> m f (n f x)` |
| **ä¹˜æ³•**     | `mul = Î»m n f. m (n f)`            | `mulChurch = \m n f -> m (n f)`       |

------

#### **å…³é”®ç»“è®º**

- **Church ç¼–ç æ˜¯ä¸€ç§å®Œå…¨åŸºäº Lambda è¡¨è¾¾å¼çš„æ•°å­¦è®¡ç®—æ–¹å¼**ã€‚
- **Haskell èƒ½å¤Ÿç›´æ¥å®ç° Church ç¼–ç ï¼Œä½¿å¾—å‡½æ•°å¼ç¼–ç¨‹ä¸ Lambda Calculus ç´§å¯†ç»“åˆ**ã€‚
- **Haskell è®¸å¤šæ¦‚å¿µï¼ˆåŒ¿åå‡½æ•°ã€é«˜é˜¶å‡½æ•°ã€æƒ°æ€§æ±‚å€¼ï¼‰éƒ½å—åˆ° Church ç¼–ç çš„å¯å‘**ã€‚

åœ¨ä¸‹ä¸€èŠ‚ï¼Œæˆ‘ä»¬å°†æ¢è®¨ **Church ç¼–ç ä¸çº¯ Lambda è®¡ç®—çš„å¯¹åº”å…³ç³»**ï¼Œè¿›ä¸€æ­¥æ·±å…¥ç†è§£å‡½æ•°å¼ç¼–ç¨‹çš„æ ¸å¿ƒæ€æƒ³ï¼ğŸš€

### **7.4.2 å±•ç¤º Church ç¼–ç ä¸çº¯ Lambda Calculus çš„å¯¹åº”å…³ç³»**

åœ¨ä¸Šä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬åœ¨ Haskell ä¸­å®ç°äº† **Church å¸ƒå°”å€¼** å’Œ **Church æ•°**ï¼Œå¹¶å±•ç¤ºäº†åŸºæœ¬çš„é€»è¾‘å’Œç®—æœ¯è¿ç®—ã€‚è¿™äº›å®šä¹‰å®Œå…¨éµå¾ª **Lambda Calculus**ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨ Haskell å†…ç½®çš„ `Bool` æˆ– `Int` ç±»å‹ï¼Œè€Œæ˜¯ **çº¯ç²¹åœ°é€šè¿‡ Lambda è¡¨è¾¾å¼æ¥è¡¨ç¤ºæ‰€æœ‰è®¡ç®—**ã€‚

æœ¬èŠ‚æˆ‘ä»¬å°†è¿›ä¸€æ­¥æ¢è®¨ï¼š

1. **Church ç¼–ç ä¸ Lambda Calculus çš„æ•°å­¦åŸºç¡€**
2. **Haskell å®ç° Church ç¼–ç ä¸ Lambda Calculus å®šä¹‰çš„å¯¹åº”å…³ç³»**
3. **Lambda æ¼”ç®—å¦‚ä½•å®Œå…¨æ¨¡æ‹Ÿ Haskell è®¡ç®—**
4. **ä» Lambda Calculus åˆ° Haskellï¼šå¦‚ä½•ä¼˜åŒ–å®ç°**
5. **ä»£ç ç¤ºä¾‹ï¼šç”¨ Lambda è®¡ç®—ç­‰æ•ˆ Haskell ä»£ç **

------

#### **1. Church ç¼–ç ä¸ Lambda Calculus çš„æ•°å­¦åŸºç¡€**

Lambda Calculus æä¾›äº†ä¸€ç§**æœ€å°åŒ–çš„è®¡ç®—æ¨¡å‹**ï¼Œæ‰€æœ‰è®¡ç®—éƒ½å¯ä»¥é€šè¿‡ï¼š

- **å˜é‡ï¼ˆVariableï¼‰** `x`
- **æŠ½è±¡ï¼ˆAbstractionï¼‰** `Î»x. E`
- **åº”ç”¨ï¼ˆApplicationï¼‰** `(E1 E2)`

ğŸ’¡ **Church Encoding è¯æ˜äº†**ï¼šâ€œ**å‡½æ•°æœ¬èº«è¶³å¤Ÿè¡¨è¾¾æ‰€æœ‰è®¡ç®—**â€ï¼Œä¸éœ€è¦é¢å¤–çš„æ•°æ®ç±»å‹ï¼Œå¦‚ `Int` æˆ– `Bool`ã€‚

#### **1.1 çº¯ Lambda è®¡ç®—ä¸­çš„ Church æ•°**

åœ¨ Lambda Calculus ä¸­ï¼š

- **æ•°å€¼è¡¨ç¤º**ï¼š`n` ä»£è¡¨â€œå¯¹å‡½æ•° `f` åº”ç”¨ `n` æ¬¡â€ï¼š

  ```
  0 â‰¡ Î»f. Î»x. x
  1 â‰¡ Î»f. Î»x. f x
  2 â‰¡ Î»f. Î»x. f (f x)
  ```

  åœ¨ Haskell ä¸­çš„ç­‰æ•ˆå®ç°ï¼š

  ```haskell
  zero  = \f x -> x
  one   = \f x -> f x
  two   = \f x -> f (f x)
  ```

- **å¸ƒå°”å€¼è¡¨ç¤º**ï¼š

  ```
  true â‰¡ Î»x. Î»y. x
  false â‰¡ Î»x. Î»y. y
  ```

  åœ¨ Haskell ä¸­ï¼š

  ```haskell
  true  = \x y -> x
  false = \x y -> y
  ```

ğŸ’¡ **å¯ä»¥çœ‹åˆ°ï¼ŒHaskell ä»£ç å’Œ Lambda Calculus å…¬å¼å®Œå…¨å¯¹åº”**ã€‚

------

#### **2. Haskell å®ç° Church ç¼–ç ä¸ Lambda Calculus å®šä¹‰çš„å¯¹åº”å…³ç³»**

Haskell æœ¬è´¨ä¸Šæ˜¯ **Lambda Calculus çš„æ‰©å±•**ï¼Œå¹¶ä¸”ï¼š

1. **æ‰€æœ‰ Haskell å‡½æ•°å®é™…ä¸Šæ˜¯ Lambda è¡¨è¾¾å¼**
2. **Haskell å…è®¸ç›´æ¥è¡¨è¾¾ Church ç¼–ç **
3. **Haskell çš„å‡½æ•°å¼è®¡ç®—è§„åˆ™ä¸ Lambda Calculus ç›¸åŒ**

------

#### **2.1 é€»è¾‘è¿ç®—çš„çº¯ Lambda æ¼”ç®—å®ç°**

åœ¨ Lambda Calculus ä¸­ï¼š

```
and = Î»p. Î»q. p q false
or  = Î»p. Î»q. p true q
not = Î»p. p false true
```

åœ¨ Haskell ä¸­ï¼š

```haskell
andChurch = \p q -> p q false
orChurch  = \p q -> p true q
notChurch = \p -> p false true
```

ğŸ’¡ **å®Œå…¨ä¸€è‡´ï¼Haskell ä»£ç ç›´æ¥å¯¹åº” Lambda Calculus å…¬å¼ã€‚**

------

#### **2.2 ç®—æœ¯è¿ç®—çš„çº¯ Lambda æ¼”ç®—å®ç°**

åœ¨ Lambda Calculus ä¸­ï¼š

```
succ = Î»n. Î»f. Î»x. f (n f x)
add  = Î»m. Î»n. Î»f. Î»x. m f (n f x)
mul  = Î»m. Î»n. Î»f. m (n f)
```

åœ¨ Haskell ä¸­ï¼š

```haskell
succChurch = \n f x -> f (n f x)
addChurch  = \m n f x -> m f (n f x)
mulChurch  = \m n f -> m (n f)
```

ğŸ’¡ **è¿™è¯æ˜äº† Haskell å‡½æ•°çš„å®šä¹‰æ–¹å¼ä¸ Lambda Calculus è®¡ç®—å®Œå…¨ä¸€è‡´ã€‚**

------

#### **3. Lambda Calculus å¦‚ä½•å®Œå…¨æ¨¡æ‹Ÿ Haskell è®¡ç®—**

Haskell å…è®¸æˆ‘ä»¬ç›´æ¥**æµ‹è¯• Lambda Calculus çš„è®¡ç®—è§„åˆ™**ã€‚

#### **3.1 æµ‹è¯• Church é€»è¾‘è¿ç®—**

```haskell
main = do
    let bTrue  = true
    let bFalse = false
    putStrLn "Church Boolean Operations:"
    print ((andChurch bTrue bFalse) "True" "False")  -- False
    print ((orChurch bTrue bFalse) "True" "False")   -- True
    print ((notChurch bTrue) "True" "False")         -- False
```

**ç»“æœï¼š**

```
Church Boolean Operations:
False
True
False
```

ğŸ’¡ **ç»“æœä¸é¢„æœŸå®Œå…¨ä¸€è‡´ï¼Œè¯´æ˜ Church å¸ƒå°”å€¼å¯ä»¥å®Œç¾æ¨¡æ‹Ÿ Haskell çš„ `Bool` ç±»å‹ã€‚**

------

#### **3.2 æµ‹è¯• Church æ•°çš„ç®—æœ¯è®¡ç®—**

```haskell
churchToInt n = n (+1) 0  -- å°† Church æ•°è½¬æ¢ä¸º Haskell æ•´æ•°

main = do
    putStrLn "Church Numerals:"
    print (churchToInt (succChurch two))  -- 3
    print (churchToInt (addChurch two three))  -- 5
    print (churchToInt (mulChurch two three))  -- 6
```

**ç»“æœï¼š**

```
Church Numerals:
3
5
6
```

ğŸ’¡ **Haskell ä»£ç å‡†ç¡®åœ°è®¡ç®—å‡ºäº† Church æ•°çš„åŠ æ³•å’Œä¹˜æ³•ï¼**

------

#### **4. ä» Lambda Calculus åˆ° Haskellï¼šå¦‚ä½•ä¼˜åŒ–å®ç°**

è™½ç„¶ Church ç¼–ç åœ¨æ•°å­¦ä¸Šå¾ˆä¼˜é›…ï¼Œä½†åœ¨å®é™…ç¼–ç¨‹ä¸­ï¼Œ**ä½¿ç”¨åŸç”Ÿæ•°æ®ç±»å‹ï¼ˆå¦‚ `Int`ã€`Bool`ï¼‰é€šå¸¸æ›´é«˜æ•ˆ**ã€‚å› æ­¤ï¼ŒHaskell æä¾›äº†ä¸€äº›ä¼˜åŒ–ç­–ç•¥ï¼š

#### **4.1 ä½¿ç”¨ `newtype` ä»£æ›¿çº¯ Lambda å®šä¹‰**

```haskell
newtype ChurchBool = ChurchBool (forall a. a -> a -> a)

true'  = ChurchBool (\x y -> x)
false' = ChurchBool (\x y -> y)
```

ğŸ’¡ **è¿™æ ·å¯ä»¥å°è£… Church ç¼–ç ï¼Œæé«˜å¯è¯»æ€§ã€‚**

------

#### **4.2 ä½¿ç”¨ `data` è®© Church æ•°ä¸ Haskell `Int` äº’æ“ä½œ**

```haskell
data ChurchNum = ChurchNum (forall a. (a -> a) -> a -> a)

toInt :: ChurchNum -> Int
toInt (ChurchNum n) = n (+1) 0
```

ğŸ’¡ **è¿™æ · Church æ•°å¯ä»¥æ›´æ–¹ä¾¿åœ°è½¬æ¢ä¸º Haskell `Int` ç±»å‹ã€‚**

------

#### **5. ä»£ç ç¤ºä¾‹ï¼šç”¨ Lambda è®¡ç®—ç­‰æ•ˆ Haskell ä»£ç **

Haskell **æœ¬èº«å°±åƒ Lambda Calculus**ï¼Œå¯ä»¥ç›´æ¥å®ç° Church è®¡ç®—ï¼š

```haskell
true  = \x y -> x
false = \x y -> y
andChurch = \p q -> p q false
orChurch  = \p q -> p true q
notChurch = \p -> p false true

zero  = \f x -> x
one   = \f x -> f x
two   = \f x -> f (f x)
three = \f x -> f (f (f x))

succChurch = \n f x -> f (n f x)
addChurch  = \m n f x -> m f (n f x)
mulChurch  = \m n f -> m (n f)

main = do
    print ((andChurch true false) "True" "False")
    print (succChurch two (\x -> x + 1) 0) -- 3
    print (addChurch two three (\x -> x + 1) 0) -- 5
    print (mulChurch two three (\x -> x + 1) 0) -- 6
```

ğŸ’¡ **Lambda Calculus è®¡ç®—å¯ä»¥ç›´æ¥ç”¨ Haskell è¡¨è¾¾ï¼ŒéªŒè¯å…¶æ­£ç¡®æ€§ï¼**

------

#### **æ€»ç»“**

| **æ¦‚å¿µ**     | **Lambda Calculus å®šä¹‰**            | **Haskell å®ç°**          |
| ------------ | ----------------------------------- | ------------------------- |
| **å¸ƒå°”å€¼**   | `Î»x. Î»y. x`                         | `\x y -> x`               |
| **æ•°å€¼**     | `Î»f. Î»x. f (f x)`                   | `\f x -> f (f x)`         |
| **é€»è¾‘è¿ç®—** | `and = Î»p. Î»q. p q false`           | `\p q -> p q false`       |
| **åŠ æ³•**     | `add = Î»m. Î»n. Î»f. Î»x. m f (n f x)` | `\m n f x -> m f (n f x)` |

Haskell **å®Œç¾ç»§æ‰¿äº† Lambda Calculus**ï¼Œå¹¶ä¼˜åŒ–äº†å…¶è®¡ç®—æ–¹å¼ï¼Œä½¿å…¶æ›´æ˜“è¯»ã€æ›´é«˜æ•ˆï¼ğŸš€

### **7.5.1 æƒ°æ€§æ±‚å€¼ç­–ç•¥å¯¹æ€§èƒ½çš„å½±å“**

Haskell ä½œä¸ºä¸€é—¨ **çº¯å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€**ï¼Œé‡‡ç”¨äº†ä¸€ç§ç‹¬ç‰¹çš„è®¡ç®—ç­–ç•¥ï¼š**æƒ°æ€§æ±‚å€¼ï¼ˆLazy Evaluationï¼‰**ã€‚ä¸å‘½ä»¤å¼ç¼–ç¨‹è¯­è¨€ï¼ˆå¦‚ Cã€Javaã€Pythonï¼‰é‡‡ç”¨çš„**ä¸¥æ ¼æ±‚å€¼ï¼ˆEager Evaluationï¼‰**ä¸åŒï¼ŒHaskell **ä»…åœ¨éœ€è¦æ—¶è®¡ç®—è¡¨è¾¾å¼çš„å€¼**ã€‚è¿™ä¸€ç­–ç•¥ä¸ä»…å½±å“ç¨‹åºçš„æ‰§è¡Œæ–¹å¼ï¼Œè¿˜å¸¦æ¥äº†æ€§èƒ½ä¸Šçš„ä¼˜åŠ¿å’ŒæŒ‘æˆ˜ã€‚

æœ¬èŠ‚å°†æ¢è®¨ï¼š

1. **ä»€ä¹ˆæ˜¯æƒ°æ€§æ±‚å€¼ï¼Ÿ**
2. **Haskell å¦‚ä½•å®ç°æƒ°æ€§æ±‚å€¼**
3. **æƒ°æ€§æ±‚å€¼å¯¹æ€§èƒ½çš„ä¼˜åŠ¿**
4. **æƒ°æ€§æ±‚å€¼å¯èƒ½å¸¦æ¥çš„é—®é¢˜**
5. **å¦‚ä½•ä¼˜åŒ–æƒ°æ€§æ±‚å€¼ï¼Œæé«˜æ€§èƒ½**
6. **ä»£ç ç¤ºä¾‹ï¼šæƒ°æ€§æ±‚å€¼ vs. ä¸¥æ ¼æ±‚å€¼çš„å¯¹æ¯”**
7. **Haskell è¿è¡Œæ—¶å¦‚ä½•å¤„ç†æƒ°æ€§æ±‚å€¼**

------

#### **1. ä»€ä¹ˆæ˜¯æƒ°æ€§æ±‚å€¼ï¼Ÿ**

**æƒ°æ€§æ±‚å€¼ï¼ˆLazy Evaluationï¼‰** æ˜¯ä¸€ç§ **â€œæŒ‰éœ€è®¡ç®—â€** çš„ç­–ç•¥ï¼Œå³ï¼š

- **è¡¨è¾¾å¼ä¸ä¼šç«‹å³æ±‚å€¼**ï¼Œè€Œæ˜¯æ„é€ ä¸€ä¸ª **Thunk**ï¼ˆå»¶è¿Ÿè®¡ç®—çš„å ä½ç¬¦ï¼‰ã€‚
- **åªæœ‰å½“è®¡ç®—ç»“æœè¢«éœ€è¦æ—¶ï¼ŒThunk æ‰ä¼šçœŸæ­£æ‰§è¡Œ**ã€‚
- **æ‰§è¡Œä¸€æ¬¡åï¼Œç»“æœä¼šè¢«ç¼“å­˜ï¼ˆMemoizationï¼‰**ï¼Œé¿å…é‡å¤è®¡ç®—ã€‚

ğŸ’¡ **ç®€å•ç†è§£ï¼šå¦‚æœä¸€ä¸ªè¡¨è¾¾å¼çš„è®¡ç®—ç»“æœä¸ä¼šè¢«ä½¿ç”¨ï¼Œå®ƒå°±æ°¸è¿œä¸ä¼šè¢«è®¡ç®—ã€‚**

------

#### **2. Haskell å¦‚ä½•å®ç°æƒ°æ€§æ±‚å€¼**

åœ¨ Haskell ä¸­ï¼Œæ‰€æœ‰è®¡ç®—**é»˜è®¤**éƒ½æ˜¯æƒ°æ€§æ±‚å€¼ã€‚ä¾‹å¦‚ï¼š

```haskell
square x = x * x

main = print (square (2 + 3))
```

åœ¨ **ä¸¥æ ¼æ±‚å€¼** è¯­è¨€ä¸­ï¼ˆå¦‚ Pythonï¼‰ï¼Œè®¡ç®—æ­¥éª¤å¦‚ä¸‹ï¼š

1. `2 + 3` è®¡ç®—å‡º `5`
2. `square 5` è®¡ç®—å‡º `25`
3. è¾“å‡º `25`

ä½†åœ¨ Haskellï¼ˆæƒ°æ€§æ±‚å€¼ï¼‰ä¸­ï¼Œè®¡ç®—æ­¥éª¤å¦‚ä¸‹ï¼š

1. **ä¸ä¼šç«‹å³è®¡ç®— `2 + 3`ï¼Œè€Œæ˜¯åˆ›å»ºä¸€ä¸ª Thunk**
2. åªæœ‰å½“ `square` éœ€è¦ `x` çš„å€¼æ—¶ï¼ŒThunk æ‰ä¼šè®¡ç®— `2 + 3`
3. è®¡ç®—å‡º `square 5 = 25`ï¼Œç„¶åè¾“å‡º

ğŸ’¡ **åªæœ‰ `print` éœ€è¦æœ€ç»ˆçš„æ•°å€¼ï¼Œæ‰ä¼šçœŸæ­£æ‰§è¡Œè®¡ç®—**ã€‚

------

#### **3. æƒ°æ€§æ±‚å€¼å¯¹æ€§èƒ½çš„ä¼˜åŠ¿**

æƒ°æ€§æ±‚å€¼å¸¦æ¥äº† **è‹¥å¹²æ€§èƒ½ä¼˜åŒ–**ï¼ŒåŒ…æ‹¬ï¼š

#### **3.1 é¿å…ä¸å¿…è¦çš„è®¡ç®—**

åœ¨å‘½ä»¤å¼è¯­è¨€ä¸­ï¼Œå‡½æ•°çš„æ‰€æœ‰å‚æ•°éƒ½ä¼šè¢«æ±‚å€¼ï¼š

```python
def first(a, b):
    return a
print(first(1, 1/0))  # è¿è¡Œæ—¶é”™è¯¯ï¼ˆé™¤é›¶é”™è¯¯ï¼‰
```

ä½†åœ¨ Haskellï¼š

```haskell
first a b = a
main = print (first 1 (1 `div` 0))  -- æ²¡æœ‰é”™è¯¯
```

ğŸ’¡ **å› ä¸º `b` æ²¡æœ‰è¢«ä½¿ç”¨ï¼Œ`1 `div` 0` ä¹Ÿä¸ä¼šè¢«è®¡ç®—ï¼**

------

#### **3.2 å…è®¸æ— é™æ•°æ®ç»“æ„**

æƒ°æ€§æ±‚å€¼ä½¿å¾— **æ— é™åˆ—è¡¨ï¼ˆInfinite Listsï¼‰** æˆä¸ºå¯èƒ½ï¼š

```haskell
naturals = [1..]  -- æ— é™é€’å¢åºåˆ—
firstTen = take 10 naturals
```

ğŸ’¡ **å³ä½¿ `naturals` æ˜¯æ— é™çš„ï¼ŒHaskell ä¹Ÿä¸ä¼šè®¡ç®—å®ƒçš„æ‰€æœ‰å…ƒç´ ï¼Œè€Œæ˜¯æŒ‰éœ€è®¡ç®—å‰ 10 ä¸ªã€‚**

------

#### **3.3 æé«˜æ€§èƒ½ï¼Œå‡å°‘è®¡ç®—æˆæœ¬**

å¦‚æœä¸€ä¸ªå€¼åœ¨è®¡ç®—è¿‡ç¨‹ä¸­è¢«å¤šæ¬¡ä½¿ç”¨ï¼ŒHaskell åªä¼šè®¡ç®— **ä¸€æ¬¡** å¹¶ç¼“å­˜ç»“æœï¼š

```haskell
slowFunction = (1 + 2) * (1 + 2)  -- `1 + 2` åªè®¡ç®—ä¸€æ¬¡
```

ğŸ’¡ **é¿å…é‡å¤è®¡ç®—ï¼Œæé«˜æ•ˆç‡ï¼**

------

#### **4. æƒ°æ€§æ±‚å€¼å¯èƒ½å¸¦æ¥çš„é—®é¢˜**

è™½ç„¶æƒ°æ€§æ±‚å€¼å¸¦æ¥äº†å¾ˆå¤šä¼˜åŒ–ï¼Œä½†å®ƒä¹Ÿå¯èƒ½å½±å“æ€§èƒ½ï¼Œä¸»è¦é—®é¢˜åŒ…æ‹¬ï¼š

#### **4.1 ç©ºé—´æ³„æ¼ï¼ˆSpace Leakï¼‰**

æƒ°æ€§æ±‚å€¼å¯èƒ½å¯¼è‡´ç¨‹åº**å ç”¨è¿‡å¤šå†…å­˜**ï¼Œå› ä¸ºå®ƒå­˜å‚¨äº†å¤§é‡ **Thunk** è€Œæ²¡æœ‰ç«‹å³æ‰§è¡Œï¼š

```haskell
sum' [] = 0
sum' (x:xs) = x + sum' xs

main = print (sum' [1..1000000])  -- å¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼
```

ğŸ’¡ **åœ¨ `sum'` è®¡ç®—è¿‡ç¨‹ä¸­ï¼ŒThunk å¯èƒ½ä¼šå ç”¨å¤§é‡å†…å­˜ï¼Œè€Œä¸ä¼šç«‹å³é‡Šæ”¾ã€‚**

**è§£å†³æ–¹æ¡ˆï¼š** ä½¿ç”¨ `seq` æˆ– **ä¸¥æ ¼æ±‚å€¼**ï¼Œç¡®ä¿è®¡ç®—ä¸ä¼šç´¯ç§¯è¿‡å¤šçš„ Thunkï¼š

```haskell
sumStrict [] acc = acc
sumStrict (x:xs) acc = let newAcc = acc + x in newAcc `seq` sumStrict xs newAcc
```

ğŸ’¡ **å¼ºåˆ¶ `newAcc` ç«‹å³è®¡ç®—ï¼Œé¿å… Thunk è¿‡åº¦ç§¯ç´¯ã€‚**

------

#### **4.2 ä»£ç å¯è¯»æ€§ä¸‹é™**

æƒ°æ€§æ±‚å€¼å¯èƒ½å¯¼è‡´**ä»£ç æ‰§è¡Œé¡ºåºéš¾ä»¥é¢„æµ‹**ï¼š

```haskell
debug x = trace ("Evaluating " ++ show x) x
main = print (debug 1 + debug 2)
```

ğŸ’¡ **æƒ°æ€§æ±‚å€¼å¯èƒ½ä¼šæ”¹å˜ `debug` è¾“å‡ºçš„é¡ºåºï¼Œå½±å“è°ƒè¯•ã€‚**

**è§£å†³æ–¹æ¡ˆ**ï¼š

- ä½¿ç”¨ `seq` å¼ºåˆ¶æ±‚å€¼
- ä½¿ç”¨ `deepseq` å®Œå…¨å±•å¼€æ•°æ®ç»“æ„

------

#### **5. å¦‚ä½•ä¼˜åŒ–æƒ°æ€§æ±‚å€¼ï¼Œæé«˜æ€§èƒ½**

#### **5.1 ä½¿ç”¨ `seq` æ§åˆ¶æ±‚å€¼**

`seq` å¼ºåˆ¶è®¡ç®— **ç¬¬ä¸€ä¸ªå‚æ•°**ï¼Œç„¶åè¿”å› **ç¬¬äºŒä¸ªå‚æ•°**ï¼š

```haskell
strictSum a b = a `seq` b `seq` (a + b)
```

ğŸ’¡ **é¿å…æƒ°æ€§æ±‚å€¼å¯¼è‡´çš„ Thunk ç§¯ç´¯ï¼Œæé«˜æ•ˆç‡ã€‚**

------

#### **5.2 ä½¿ç”¨ `deepseq` å®Œå…¨æ±‚å€¼**

å¯¹äºå¤æ‚æ•°æ®ç»“æ„ï¼ˆå¦‚åˆ—è¡¨ï¼‰ï¼Œ`deepseq` å¯ä»¥**å®Œå…¨å±•å¼€**ï¼š

```haskell
import Control.DeepSeq
main = deepseq [1..1000000] (print "Done!")  -- ç«‹å³è®¡ç®—åˆ—è¡¨
```

ğŸ’¡ **é¿å… Thunk è¿‡åº¦ç§¯ç´¯ï¼Œå‡å°‘å†…å­˜å ç”¨ã€‚**

------

#### **5.3 ä½¿ç”¨ `Bang Patterns` å¼ºåˆ¶æ±‚å€¼**

Haskell å…è®¸ä½¿ç”¨ `!` ç¬¦å·æ ‡è®° **å¼ºåˆ¶æ±‚å€¼**ï¼š

```haskell
sum' !acc [] = acc
sum' !acc (x:xs) = sum' (acc + x) xs
```

ğŸ’¡ **ç¡®ä¿ `acc` ç«‹å³æ±‚å€¼ï¼Œè€Œä¸æ˜¯åˆ›å»º Thunkã€‚**

------

#### **6. ä»£ç ç¤ºä¾‹ï¼šæƒ°æ€§æ±‚å€¼ vs. ä¸¥æ ¼æ±‚å€¼çš„å¯¹æ¯”**

```haskell
-- æƒ°æ€§æ±‚å€¼
lazySum [] = 0
lazySum (x:xs) = x + lazySum xs

-- ä¸¥æ ¼æ±‚å€¼
strictSum acc [] = acc
strictSum acc (x:xs) = let newAcc = acc + x in newAcc `seq` strictSum newAcc xs
```

ğŸ’¡ **`strictSum` ç‰ˆæœ¬é¿å…äº† Thunk è¿‡åº¦ç§¯ç´¯ï¼Œæé«˜äº†æ€§èƒ½ã€‚**

------

#### **7. Haskell è¿è¡Œæ—¶å¦‚ä½•å¤„ç†æƒ°æ€§æ±‚å€¼**

Haskell **GHC è¿è¡Œæ—¶ç³»ç»Ÿ**ï¼ˆRTSï¼‰é‡‡ç”¨ **Graph Reduction** æ–¹å¼æ‰§è¡Œæƒ°æ€§æ±‚å€¼ï¼š

1. **åˆ›å»º Thunk**
2. **åªæœ‰å½“å€¼è¢«éœ€è¦æ—¶ï¼Œè®¡ç®— Thunk**
3. **è®¡ç®—åï¼Œæ›¿æ¢ Thunk ä¸ºæœ€ç»ˆå€¼**
4. **ç¼“å­˜ç»“æœï¼Œé¿å…é‡å¤è®¡ç®—**

ğŸ’¡ **è¿™ä½¿å¾— Haskell åœ¨ä¸å½±å“æ•ˆç‡çš„æƒ…å†µä¸‹ï¼Œå®ç°äº†â€œæŒ‰éœ€è®¡ç®—â€ç­–ç•¥ã€‚**

------

#### **æ€»ç»“**

| **æ¦‚å¿µ**                | **ä¼˜ç‚¹**                         | **æ½œåœ¨é—®é¢˜**     |
| ----------------------- | -------------------------------- | ---------------- |
| **æƒ°æ€§æ±‚å€¼**            | é¿å…ä¸å¿…è¦è®¡ç®—ï¼Œæ”¯æŒæ— é™æ•°æ®ç»“æ„ | å¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼ |
| **`seq` å¼ºåˆ¶æ±‚å€¼**      | æ§åˆ¶æƒ°æ€§æ±‚å€¼ï¼Œå‡å°‘ Thunk ç§¯ç´¯    | éœ€è¦æ‰‹åŠ¨ä¼˜åŒ–     |
| **`deepseq` å½»åº•æ±‚å€¼**  | é€‚ç”¨äºå¤æ‚æ•°æ®ç»“æ„               | å¯èƒ½å½±å“æ€§èƒ½     |
| **Bang Patterns (`!`)** | æé«˜è®¡ç®—æ•ˆç‡                     | ä»£ç å¯è¯»æ€§ç¨å·®   |

- **Haskell é‡‡ç”¨æƒ°æ€§æ±‚å€¼ï¼Œæé«˜æ•ˆç‡**
- **é¿å…ä¸å¿…è¦è®¡ç®—ï¼Œæ”¯æŒæ— é™æ•°æ®ç»“æ„**
- **å¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼ï¼Œéœ€ä½¿ç”¨ `seq`ã€`deepseq` è¿›è¡Œä¼˜åŒ–**
- **Haskell GHC è¿è¡Œæ—¶é€šè¿‡å›¾å½’çº¦ï¼ˆGraph Reductionï¼‰æ‰§è¡Œè®¡ç®—**

åœ¨ä¸‹ä¸€èŠ‚ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢è®¨ **Haskell ç¼–è¯‘å™¨ï¼ˆGHCï¼‰çš„ä¼˜åŒ–è¿‡ç¨‹**ï¼Œäº†è§£å¦‚ä½•è®© Haskell ä»£ç è¿è¡Œå¾—æ›´å¿«ï¼ğŸš€



### **7.5.2 Haskell ç¼–è¯‘å™¨ï¼ˆGHCï¼‰çš„ä¼˜åŒ–è¿‡ç¨‹æ¦‚è¿°**

Haskell ä»£ç çš„æ‰§è¡Œæ•ˆç‡åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šä¾èµ–äºå…¶å¼ºå¤§çš„ **GHCï¼ˆGlasgow Haskell Compilerï¼‰** ç¼–è¯‘å™¨ã€‚GHC ä¸ä»…æ˜¯ Haskell è¯­è¨€çš„ä¸»è¦å®ç°ï¼Œè¿˜æä¾›äº†**å¤šç§ä¼˜åŒ–æŠ€æœ¯**ï¼Œèƒ½å¤Ÿå¤§å¹…æå‡ Haskell ç¨‹åºçš„è¿è¡Œé€Ÿåº¦ï¼Œä½¿å…¶èƒ½å¤Ÿåœ¨é«˜æ€§èƒ½è®¡ç®—ã€å¹¶å‘ç¼–ç¨‹å’Œç³»ç»Ÿç¼–ç¨‹ç­‰é¢†åŸŸè¡¨ç°å‡ºè‰²ã€‚

æœ¬èŠ‚å°†æ¢è®¨ï¼š

1. **GHC ç¼–è¯‘æµç¨‹æ¦‚è¿°**
2. **æ ¸å¿ƒä¼˜åŒ–ç­–ç•¥**
3. **æƒ°æ€§æ±‚å€¼ä¸ä¼˜åŒ–**
4. **GHC è¿è¡Œæ—¶ä¼˜åŒ–**
5. **ä»£ç ç¤ºä¾‹ï¼šGHC ä¼˜åŒ–å‰åå¯¹æ¯”**
6. **å¦‚ä½•ä½¿ç”¨ GHC è¿›è¡Œæ€§èƒ½ä¼˜åŒ–**
7. **GHC åœ¨é«˜æ€§èƒ½è®¡ç®—ä¸­çš„åº”ç”¨**

------

#### **1. GHC ç¼–è¯‘æµç¨‹æ¦‚è¿°**

GHC çš„ç¼–è¯‘æµç¨‹ä¸»è¦åŒ…æ‹¬ä»¥ä¸‹å‡ ä¸ªé˜¶æ®µï¼š

```
Haskell æºä»£ç  â†’ è§£æï¼ˆParsingï¼‰â†’ è¯­æ³•æ ‘è½¬æ¢ï¼ˆCoreï¼‰â†’ æœ€ä¼˜åŒ–è½¬æ¢ï¼ˆSTG, Cmmï¼‰â†’ ä»£ç ç”Ÿæˆï¼ˆLLVM æˆ– Native Codeï¼‰
```

ğŸ’¡ **GHC é‡‡ç”¨å¤šå±‚æ¬¡ä¼˜åŒ–ï¼Œä»é«˜çº§åˆ°ä½çº§å±‚å±‚ä¼˜åŒ– Haskell ä»£ç ã€‚**

#### **1.1 GHC ç¼–è¯‘å™¨çš„ä¸»è¦é˜¶æ®µ**

| **é˜¶æ®µ**                                           | **ä½œç”¨**                                                 |
| -------------------------------------------------- | -------------------------------------------------------- |
| **è§£æï¼ˆParsingï¼‰**                                | è§£æ Haskell ä»£ç ï¼Œæ„å»ºè¯­æ³•æ ‘                            |
| **ç±»å‹æ£€æŸ¥ï¼ˆType Checkingï¼‰**                      | ç¡®ä¿ä»£ç ç¬¦åˆ Haskell ç±»å‹ç³»ç»Ÿ                            |
| **è½¬æ¢ä¸º Core è¯­è¨€ï¼ˆCore Representationï¼‰**        | å°† Haskell ä»£ç è½¬æ¢ä¸º GHC Coreï¼ˆç®€åŒ–çš„ Lambda Calculusï¼‰ |
| **ä¼˜åŒ–ï¼ˆOptimizationï¼‰**                           | è¿›è¡Œé«˜å±‚ä¼˜åŒ–ï¼ˆå¦‚å‡½æ•°å†…è”ã€æ¶ˆé™¤å†—ä½™è®¡ç®—ï¼‰                 |
| **è½¬æ¢ä¸º STG è¯­è¨€ï¼ˆSpineless Tagless G-machineï¼‰** | ç”¨äºæ§åˆ¶å†…å­˜åˆ†é…ã€åƒåœ¾å›æ”¶å’Œæ±‚å€¼                         |
| **è½¬æ¢ä¸º Cmm è¯­è¨€ï¼ˆä½çº§ä¸­é—´ä»£ç ï¼‰**                | ç±»ä¼¼äº C è¯­è¨€çš„ä¸­é—´è¡¨ç¤º                                  |
| **ä»£ç ç”Ÿæˆï¼ˆCode Generationï¼‰**                    | ç”Ÿæˆæœ¬æœºä»£ç ï¼ˆNativeï¼‰æˆ– LLVM IR ä»£ç                     |

ğŸ’¡ **GHC çš„ Core è¯­è¨€æ˜¯ Lambda Calculus çš„æ‰©å±•ï¼ŒSTG è¯­è¨€åˆ™è´Ÿè´£æ§åˆ¶æ±‚å€¼ç­–ç•¥ã€‚**

------

#### **2. æ ¸å¿ƒä¼˜åŒ–ç­–ç•¥**

GHC é‡‡ç”¨äº†ä¸€ç³»åˆ—**é«˜æ•ˆçš„ä¼˜åŒ–æŠ€æœ¯**ï¼Œä¸»è¦åŒ…æ‹¬ï¼š

- **å‡½æ•°å†…è”ï¼ˆInliningï¼‰**
- **æ¶ˆé™¤å…¬å…±å­è¡¨è¾¾å¼ï¼ˆCSE, Common Subexpression Eliminationï¼‰**
- **æ¶ˆé™¤æ­»ä»£ç ï¼ˆDead Code Eliminationï¼‰**
- **ä¸¥æ ¼æ€§åˆ†æï¼ˆStrictness Analysisï¼‰**
- **å°¾é€’å½’ä¼˜åŒ–ï¼ˆTail Recursion Optimizationï¼‰**
- **List Fusionï¼ˆåˆ—è¡¨èåˆï¼‰**
- **Unboxing ä¼˜åŒ–**

------

#### **2.1 å‡½æ•°å†…è”ï¼ˆInliningï¼‰**

å†…è”ä¼˜åŒ–æ˜¯å°†å°å‡½æ•°**ç›´æ¥å±•å¼€**ï¼Œé¿å…å‡½æ•°è°ƒç”¨çš„å¼€é”€ï¼š

```haskell
square x = x * x
sumSquares = square 3 + square 4
```

åœ¨ä¼˜åŒ–åï¼ŒGHC å¯èƒ½ä¼šç›´æ¥è½¬æ¢ä¸ºï¼š

```haskell
sumSquares = (3 * 3) + (4 * 4)  -- é¿å…å‡½æ•°è°ƒç”¨
```

ğŸ’¡ **å‡å°‘å‡½æ•°è°ƒç”¨å¼€é”€ï¼Œæé«˜è®¡ç®—é€Ÿåº¦ã€‚**

------

#### **2.2 æ¶ˆé™¤å…¬å…±å­è¡¨è¾¾å¼ï¼ˆCSEï¼‰**

å¦‚æœåŒä¸€ä¸ªå­è¡¨è¾¾å¼åœ¨å¤šä¸ªåœ°æ–¹å‡ºç°ï¼ŒGHC ä¼šè¿›è¡Œ**åˆå¹¶**ï¼š

```haskell
let x = (3 + 4) in x * x
```

ä¼˜åŒ–åï¼š

```haskell
let x = 7 in x * x  -- è®¡ç®— `3 + 4` åªæ‰§è¡Œä¸€æ¬¡
```

ğŸ’¡ **é¿å…é‡å¤è®¡ç®—ï¼Œæå‡æ€§èƒ½ã€‚**

------

#### **2.3 ä¸¥æ ¼æ€§åˆ†æï¼ˆStrictness Analysisï¼‰**

ç”±äº Haskell é‡‡ç”¨ **æƒ°æ€§æ±‚å€¼**ï¼Œä½†æŸäº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›å¼ºåˆ¶æ±‚å€¼ï¼š

```haskell
f x y = x + y
```

é»˜è®¤æƒ…å†µä¸‹ï¼ŒHaskell ä¼šå»¶è¿Ÿ `x + y` çš„è®¡ç®—ï¼Œä½† GHC **å¯èƒ½ä¼šåˆ†æå‡º `f` åœ¨æ‰€æœ‰æƒ…å†µä¸‹éƒ½ä¼šè®¡ç®— `x + y`**ï¼Œå› æ­¤å¯ä»¥ä¼˜åŒ–ï¼š

```haskell
f !x !y = x + y
```

ğŸ’¡ **é¿å… Thunk è¿‡åº¦ç§¯ç´¯ï¼Œæé«˜å†…å­˜åˆ©ç”¨ç‡ã€‚**

------

#### **2.4 List Fusionï¼ˆåˆ—è¡¨èåˆï¼‰**

GHC ä½¿ç”¨ **åˆ—è¡¨èåˆï¼ˆList Fusionï¼‰** ä¼˜åŒ–åˆ—è¡¨æ“ä½œï¼š

```haskell
sum (map (*2) [1..100])
```

é€šå¸¸ä¼šå…ˆè®¡ç®— `[2,4,6,...]` å† `sum` è®¡ç®—ï¼Œä½† GHC ç›´æ¥ä¼˜åŒ–ä¸ºï¼š

```haskell
sum [2,4,6,...]
```

ğŸ’¡ **é¿å…ç”Ÿæˆä¸­é—´åˆ—è¡¨ï¼Œæé«˜æ€§èƒ½ã€‚**

------

#### **3. æƒ°æ€§æ±‚å€¼ä¸ä¼˜åŒ–**

GHC **ä¸ä¼šå¯¹æ‰€æœ‰ä»£ç æƒ°æ€§æ±‚å€¼**ï¼Œè€Œæ˜¯è¿›è¡Œ **æ™ºèƒ½ä¼˜åŒ–**ï¼š

1. **å¦‚æœè¡¨è¾¾å¼åªè¢«ç”¨ä¸€æ¬¡ï¼Œåˆ™ç«‹å³æ±‚å€¼**
2. **å¦‚æœè¡¨è¾¾å¼éœ€è¦å¤šæ¬¡ä½¿ç”¨ï¼Œåˆ™ç¼“å­˜ï¼ˆMemoizationï¼‰**
3. **å¦‚æœ Thunk è¿‡å¤šï¼ŒGHC å¯èƒ½è‡ªåŠ¨è½¬æ¢ä¸ºä¸¥æ ¼æ±‚å€¼**

ğŸ’¡ **GHC ä¼šæ ¹æ®ç¨‹åºä¸Šä¸‹æ–‡è°ƒæ•´æƒ°æ€§æ±‚å€¼ç­–ç•¥ï¼Œæé«˜è¿è¡Œæ•ˆç‡ã€‚**

------

#### **4. GHC è¿è¡Œæ—¶ä¼˜åŒ–**

é™¤äº†ç¼–è¯‘ä¼˜åŒ–ï¼ŒGHC è¿˜æä¾›äº† **è¿è¡Œæ—¶ï¼ˆRuntimeï¼‰ä¼˜åŒ–**ï¼š

- **åƒåœ¾å›æ”¶ï¼ˆGarbage Collection, GCï¼‰**
- **å¤šæ ¸å¹¶è¡Œæ‰§è¡Œï¼ˆParallel Executionï¼‰**
- **è‡ªåŠ¨å¹¶è¡ŒåŒ–ï¼ˆAutomatic Parallelizationï¼‰**
- **LLVM ä»£ç ç”Ÿæˆï¼ˆLLVM Code Generationï¼‰**

ğŸ’¡ **GHC è¿è¡Œæ—¶ç³»ç»Ÿï¼ˆRTSï¼‰ä¼˜åŒ–äº†å†…å­˜ç®¡ç†å’Œçº¿ç¨‹è°ƒåº¦ï¼Œæé«˜ Haskell ç¨‹åºçš„æ•´ä½“æ•ˆç‡ã€‚**

------

#### **5. ä»£ç ç¤ºä¾‹ï¼šGHC ä¼˜åŒ–å‰åå¯¹æ¯”**

#### **5.1 ä»£ç ä¼˜åŒ–å‰**

```haskell
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
```

ğŸ’¡ **è¿™ä¸ªç‰ˆæœ¬è®¡ç®— `fib 40` ä¼šéå¸¸æ…¢ï¼Œå› ä¸ºå®ƒè¿›è¡Œäº†å¤§é‡é‡å¤è®¡ç®—ã€‚**

------

#### **5.2 ä»£ç ä¼˜åŒ–å**

```haskell
fib' n = fibHelper n (0, 1)
  where
    fibHelper 0 (a, _) = a
    fibHelper n (a, b) = fibHelper (n-1) (b, a+b)
```

ğŸ’¡ **æ”¹ç”¨å°¾é€’å½’ä¼˜åŒ–ï¼Œé¿å…é‡å¤è®¡ç®—ï¼Œæå‡æ•ˆç‡ï¼**

------

#### **6. å¦‚ä½•ä½¿ç”¨ GHC è¿›è¡Œæ€§èƒ½ä¼˜åŒ–**

GHC æä¾›å¤šç§ä¼˜åŒ–é€‰é¡¹ï¼š

- `-O0`ï¼ˆæ— ä¼˜åŒ–ï¼Œé€‚ç”¨äºè°ƒè¯•ï¼‰
- `-O1`ï¼ˆåŸºæœ¬ä¼˜åŒ–ï¼‰
- `-O2`ï¼ˆé«˜çº§ä¼˜åŒ–ï¼‰
- `-fllvm`ï¼ˆä½¿ç”¨ LLVM è¿›è¡Œä¼˜åŒ–ï¼‰

#### **6.1 ä½¿ç”¨ `-O2` è¿›è¡Œä¼˜åŒ–ç¼–è¯‘**

```bash
ghc -O2 myprogram.hs -o myprogram
```

ğŸ’¡ **é»˜è®¤æƒ…å†µä¸‹ï¼Œ`-O2` å·²ç»èƒ½å¤§å¹…æå‡ Haskell ä»£ç çš„æ€§èƒ½ã€‚**

------

#### **6.2 ä½¿ç”¨ `-ddump-simpl` æŸ¥çœ‹ä¼˜åŒ–åçš„ Core ä»£ç **

```bash
ghc -O2 -ddump-simpl myprogram.hs
```

ğŸ’¡ **å¯ä»¥æŸ¥çœ‹ GHC è¿›è¡Œçš„ä¼˜åŒ–è¿‡ç¨‹ï¼Œåˆ†æ Core ä»£ç çš„å˜åŒ–ã€‚**

------

#### **7. GHC åœ¨é«˜æ€§èƒ½è®¡ç®—ä¸­çš„åº”ç”¨**

ç”±äº GHC **å…·å¤‡å¼ºå¤§çš„ä¼˜åŒ–èƒ½åŠ›**ï¼ŒHaskell å·²è¢«ç”¨äºï¼š

- **å¤§è§„æ¨¡å¹¶å‘ç³»ç»Ÿ**ï¼ˆå¦‚ Facebook Messengerï¼‰
- **é‡‘èè®¡ç®—**ï¼ˆå¦‚é«˜é¢‘äº¤æ˜“ç³»ç»Ÿï¼‰
- **åˆ†å¸ƒå¼è®¡ç®—**ï¼ˆå¦‚ Cloud Haskell æ¡†æ¶ï¼‰
- **AI å’Œæœºå™¨å­¦ä¹ **ï¼ˆå¦‚ Haskell å®ç°çš„æ·±åº¦å­¦ä¹ åº“ï¼‰

ğŸ’¡ **Haskell ç»“åˆ GHC ä¼˜åŒ–ï¼Œèƒ½åœ¨å®é™…å·¥ç¨‹ä¸­è¾¾åˆ°æ¥è¿‘ C/C++ çš„æ€§èƒ½ï¼**

------

#### **æ€»ç»“**

| **ä¼˜åŒ–æŠ€æœ¯**                | **ä½œç”¨**                           |
| --------------------------- | ---------------------------------- |
| **å‡½æ•°å†…è”ï¼ˆInliningï¼‰**    | å‡å°‘å‡½æ•°è°ƒç”¨å¼€é”€                   |
| **å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤ï¼ˆCSEï¼‰** | é¿å…é‡å¤è®¡ç®—                       |
| **ä¸¥æ ¼æ€§åˆ†æ**              | è®©ä»£ç è‡ªåŠ¨è½¬æ¢ä¸ºä¸¥æ ¼æ±‚å€¼ï¼Œæé«˜æ•ˆç‡ |
| **List Fusion**             | é¿å…ä¸­é—´åˆ—è¡¨ï¼Œæé«˜åˆ—è¡¨è®¡ç®—é€Ÿåº¦     |
| **LLVM ä»£ç ä¼˜åŒ–**           | ç”Ÿæˆé«˜æ•ˆçš„æœºå™¨ä»£ç                  |

- **GHC æä¾›å¤šå±‚æ¬¡ä¼˜åŒ–ï¼Œä½¿ Haskell ä»£ç è¿è¡Œæ›´å¿«**
- **é»˜è®¤æƒ°æ€§æ±‚å€¼ï¼Œä½† GHC ä¼šæ ¹æ®æƒ…å†µæ™ºèƒ½ä¼˜åŒ–**
- **ä½¿ç”¨ `-O2` ç¼–è¯‘é€‰é¡¹å¯ä»¥è·å¾—æœ€ä½³ä¼˜åŒ–**
- **Haskell ç»“åˆ GHCï¼Œèƒ½åœ¨å¹¶å‘ã€é«˜æ€§èƒ½è®¡ç®—ç­‰é¢†åŸŸå‘æŒ¥ä¼˜åŠ¿**

### **ç¬¬7ç«  æ€»ç»“**

æœ¬ç« æ¢è®¨äº† Lambda Calculus åœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„æ ¸å¿ƒä½œç”¨ï¼Œä»¥åŠå®ƒå¦‚ä½•å½±å“ç°ä»£å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ï¼ˆå¦‚ Haskellã€Lispã€Schemeã€MLï¼‰çš„è®¾è®¡ã€‚æˆ‘ä»¬æ·±å…¥ç ”ç©¶äº† Haskell ä½œä¸º Lambda Calculus çš„ç›´æ¥ç»§æ‰¿è€…ï¼Œå…¶å¦‚ä½•åˆ©ç”¨åŒ¿åå‡½æ•°ã€é«˜é˜¶å‡½æ•°ã€æŸ¯é‡ŒåŒ–ç­‰ç‰¹æ€§æ„å»ºå¼ºå¤§çš„å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼ã€‚

æ­¤å¤–ï¼Œæˆ‘ä»¬å¯¹æ¯”äº†å‡½æ•°å¼ç¼–ç¨‹ä¸å‘½ä»¤å¼ç¼–ç¨‹çš„ä¸åŒï¼Œç‰¹åˆ«æ˜¯åœ¨**çŠ¶æ€ç®¡ç†ã€å¹¶å‘ä¸å¹¶è¡Œè®¡ç®—**æ–¹é¢çš„ä¼˜åŠ¿ã€‚Haskell çš„**æ— çŠ¶æ€æ¨¡å‹**å’Œ**æƒ°æ€§æ±‚å€¼ç­–ç•¥**ä½¿å…¶åœ¨å¹¶å‘è®¡ç®—å’Œé«˜æ€§èƒ½è®¡ç®—ä¸­è¡¨ç°ä¼˜å¼‚ï¼ŒåŒæ—¶ GHC ç¼–è¯‘å™¨æä¾›äº†ä¸€ç³»åˆ—ä¼˜åŒ–æ‰‹æ®µï¼Œä½¿å¾— Haskell ä»£ç å¯ä»¥æ¥è¿‘ C è¯­è¨€çš„æ‰§è¡Œæ•ˆç‡ã€‚

åœ¨å®è·µéƒ¨åˆ†ï¼Œæˆ‘ä»¬ç”¨ Haskell å®ç°äº† **Church ç¼–ç ï¼ˆæ•°å€¼ä¸å¸ƒå°”è¿ç®—ï¼‰**ï¼Œå¹¶åˆ†æäº†å®ƒä»¬ä¸çº¯ Lambda Calculus çš„æ•°å­¦å¯¹åº”å…³ç³»ï¼ŒéªŒè¯äº† Haskell ä½œä¸º Lambda Calculus ç›´æ¥æ‰©å±•çš„ç†è®ºåŸºç¡€ã€‚

æœ€åï¼Œæˆ‘ä»¬æ¢è®¨äº† Haskell çš„**æ€§èƒ½ä¼˜åŒ–**ï¼ŒåŒ…æ‹¬æƒ°æ€§æ±‚å€¼çš„å½±å“ä»¥åŠ GHC ç¼–è¯‘å™¨çš„ä¼˜åŒ–ç­–ç•¥ï¼Œå¦‚ **å‡½æ•°å†…è”ã€ä¸¥æ ¼æ€§åˆ†æã€List Fusion** ç­‰ï¼Œä½¿å¾— Haskell æ—¢èƒ½ä¿æŒè¡¨è¾¾åŠ›ï¼Œåˆèƒ½åœ¨æ€§èƒ½ä¸Šä¸å‘½ä»¤å¼è¯­è¨€ç«äº‰ã€‚

æœ¬ç« ä¸ºåç»­ç« èŠ‚å¥ å®šäº†ç†è®ºå’Œå®è·µåŸºç¡€ï¼Œä½¿æˆ‘ä»¬èƒ½å¤Ÿè¿›ä¸€æ­¥æ¢ç´¢ Lambda Calculus åœ¨ç¼–ç¨‹è¯­è¨€è®¾è®¡ã€ç¼–è¯‘å™¨ä¼˜åŒ–ä»¥åŠåº”ç”¨å¼€å‘ä¸­çš„æ›´æ·±å±‚æ¬¡å½±å“ã€‚